#pragma once

#include "labrador.h"

#include "types.h"
#include "utils.h"
#include "shared.h"
#include "oracle.h"
#include "test_helpers.h"

/// @brief Struct that proves the base case of the Labrador
struct LabradorBaseProver {
  /// The problem instance being proven.
  /// @note this instance mutates as the proof goes on.
  LabradorInstance lab_inst;
  /// The witness for the LabradorInstance.
  /// S consists of r vectors of dim n arranged in row major order
  std::vector<Rq> S;
  /// Fiat-Shamir Oracle
  Oracle oracle;

  // constructors

  /// Constructs a prover with an external seed for the random oracle.
  LabradorBaseProver(
    const LabradorInstance& lab_inst, const std::vector<Rq>& S, const std::byte* oracle_seed, size_t oracle_seed_len)
      : lab_inst(lab_inst), S(S), oracle(create_oracle_seed(oracle_seed, oracle_seed_len, lab_inst))
  {
    if (S.size() != lab_inst.param.r * lab_inst.param.n) { throw std::invalid_argument("S must have size r * n"); }
  }
  /// Constructs a prover with and copies the given random oracle as its oracle.
  LabradorBaseProver(const LabradorInstance& lab_inst, const std::vector<Rq>& S, const Oracle& oracle)
      : lab_inst(lab_inst), S(S), oracle(oracle)
  {
    if (S.size() != lab_inst.param.r * lab_inst.param.n) { throw std::invalid_argument("S must have size r * n"); }
  }

  /// Performs the aggregation of the const-zero constraints
  /// @note This *modifies* the `lab_inst`. It takes num_aggregation_rounds many random
  /// linear combinations of the const-zero constraints and saves them as an equality
  /// constraint. Afterwards it deletes all const-zero constraints.
  /// @param S_hat The NTT of the witness S
  /// @param G_hat The matrix S@S^t in NTT form
  ///  @param p The result of applying the JL projection to the witness
  /// @param psi Random Zq elements for aggregating the const-zero constraints
  /// @param omega Random Zq elements for aggregating the JL projection constraints
  /// @param JL_i The nonce for the JL projection
  /// @param seed1 Verifier's first challenge seed
  /// @return num_aggregation_rounds number of polynomials representing the constant terms for the new equality
  /// constraints
  std::vector<Tq> agg_const_zero_constraints(
    const std::vector<Tq>& S_hat,
    const std::vector<Tq>& G_hat,
    const std::vector<Zq>& p,
    const std::vector<Zq>& psi,
    const std::vector<Zq>& omega,
    size_t JL_i,
    const std::vector<std::byte>& seed1);

  /// Prover uses this function to select a valid JL projection for which the norm condition is satisfied .
  /// @returns (JL_i, p) such that [seed, JL_i] is the seed for the valid JL projection and
  /// p is the result of applying this JL projection to the witness
  std::pair<size_t, std::vector<Zq>> select_valid_jl_proj(std::byte* seed, size_t seed_len) const;

  /// Performs the base case proof for the given Labrador instance
  /// @return (base_case_proof, proof transcript) such that the Verifier can use the prover_msg in the transcript and
  /// the base_case_proof for verification
  /// @note can only be called once meaningfully on the given `lab_inst`
  std::pair<LabradorBaseCaseProof, PartialTranscript> base_case_prover();
};

/// @brief Struct that performs the Prover actions for the entire Labrador protocol
struct LabradorProver {
  /// The problem instance being proven.
  /// @note This instance mutates as the proof goes on.
  LabradorInstance lab_inst;

  /// The witness matrix S, consisting of r vectors of dimension n, arranged in row-major order.
  std::vector<Rq> S;

  /// The random oracle used for Fiat-Shamir challenges throughout the protocol.
  Oracle oracle;

  /// Number of times the Prover recurses the Labrador protocol
  size_t NUM_REC;

  // constructors

  /// @brief constructs a Prover given a labrador instance, witness, an oracle seed and the number of recursions
  LabradorProver(
    const LabradorInstance& lab_inst,
    const std::vector<Rq>& S,
    const std::byte* oracle_seed,
    size_t oracle_seed_len,
    size_t NUM_REC)
      : lab_inst(lab_inst), S(S), oracle(create_oracle_seed(oracle_seed, oracle_seed_len, lab_inst)), NUM_REC(NUM_REC)
  {
    if (S.size() != lab_inst.param.r * lab_inst.param.n) { throw std::invalid_argument("S must have size r * n"); }
  }

  /// @brief Prepares the recursion witness for the next round of protocol
  /// @param prev_param LabradorParam used in the previous round
  /// @param pf The base case proof generated by the previous round
  /// @param base0 Decomposition basis for z in pf
  /// @param mu Recursion parameter mu
  /// @param nu Recursion parameter nu
  /// @return r_prime X n_prime big Rq witness for the recursion problem
  static std::vector<Rq> prepare_recursion_witness(
    const LabradorParam& prev_param, const LabradorBaseCaseProof& pf, uint32_t base0, size_t mu, size_t nu);

  std::pair<std::vector<PartialTranscript>, LabradorBaseCaseProof> prove();
};
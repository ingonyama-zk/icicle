#pragma once

#include "labrador.h"

#include "types.h"
#include "utils.h"
#include "shared.h"
#include "oracle.h"
#include "test_helpers.h"

/// @brief Struct to verify the base case of the Labrador protocol
struct LabradorBaseVerifier {
  /// The problem instance being verified.
  /// @note this instance mutates as the verification goes on.
  LabradorInstance lab_inst;
  /// The transcript for the proof. Only trs.prover_msg are given by the Prover. The rest of the fields are generated by
  /// the Verifier when the constructor is called.
  PartialTranscript trs;
  /// Fiat Shamir oracle
  Oracle oracle;

  /// Constructs a verifier with an external seed for the random oracle.
  /// Also generates the correct transcript using `prover_msg`
  LabradorBaseVerifier(
    const LabradorInstance& lab_inst,
    const BaseProverMessages& prover_msg,
    const std::byte* oracle_seed,
    size_t oracle_seed_len)
      : lab_inst(lab_inst), trs(), oracle(create_oracle_seed(oracle_seed, oracle_seed_len, lab_inst))
  {
    trs.prover_msg = prover_msg;
    create_transcript();
  }

  /// @brief Constructs a verifier by copying the random oracle.
  /// Also generates the correct transcript using `prover_msg`
  LabradorBaseVerifier(const LabradorInstance& lab_inst, const BaseProverMessages& prover_msg, const Oracle& oracle)
      : lab_inst(lab_inst), trs(), oracle(oracle)
  {
    trs.prover_msg = prover_msg;
    create_transcript();
  }

  /// @brief Verifies transcript messages are valid and also aggregates the `lab_inst` into the correct final constraint
  /// Use part_verify for a round if it will be recursed over
  /// @return True if verification passes
  /// @note This modifies `lab_inst`
  bool part_verify();

  /// @brief Verifies the transcript and the base_proof for the problem.
  /// Use this function if this is the final round and the protocol doesn't recurse again.
  /// @param base_proof LabradorBaseCaseProof generated by LabradorBaseProver when calling base_case_prover for the same
  /// instance and oracle.
  /// @return True if verification passes
  /// @note This modifies `lab_inst`
  bool fully_verify(const LabradorBaseCaseProof& base_proof);

  /// Performs the aggregation of the const-zero constraints
  /// @note This *modifies* the `lab_inst`. It takes num_aggregation_rounds many random
  /// linear combinations of the const-zero constraints and saves them as an equality
  /// constraint. Afterwards it deletes all const-zero constraints.
  void agg_const_zero_constraints();

  // internal

  /// @brief Fills up trs correctly assuming trs.prover_msg are correctly filled
  void create_transcript();

  /// @brief Only verifies that the base_proof satisfies all the requires constraints.
  /// @param base_proof LabradorBaseCaseProof generated by LabradorBaseProver when calling base_case_prover for the same
  /// instance and oracle.
  /// @return True if verification passes
  bool _verify_base_proof(const LabradorBaseCaseProof& base_proof) const;
};

/// @brief Struct that performs the Verifier actions for the entire Labrador protocol, counterpart to LabradorProver
struct LabradorVerifier {
  /// The problem instance being proven.
  LabradorInstance lab_inst;
  /// The random oracle used for Fiat-Shamir challenges throughout the protocol.
  Oracle oracle;
  /// BaseProverMessages sent by the prover in each recursive round of the protocol (NUM_REC long)
  const std::vector<BaseProverMessages> prover_msgs;
  /// Base case proof provided by the prover for the last round
  LabradorBaseCaseProof final_proof;
  /// Number of times the Labrador protocol recurses
  size_t NUM_REC;

  // constructor

  LabradorVerifier(
    const LabradorInstance& lab_inst,
    const std::vector<BaseProverMessages>& prover_msgs,
    const LabradorBaseCaseProof& final_proof,
    const std::byte* oracle_seed,
    size_t oracle_seed_len,
    size_t NUM_REC)
      : lab_inst(lab_inst), prover_msgs(prover_msgs), final_proof(final_proof),
        oracle(create_oracle_seed(oracle_seed, oracle_seed_len, lab_inst)), NUM_REC(NUM_REC)
  {
    if (prover_msgs.size() != NUM_REC) { throw std::invalid_argument("prover_msgs.size() must equal NUM_REC"); }
  }
  /// Verifies whether the proof given by the Prover is valid or not
  bool verify();
};

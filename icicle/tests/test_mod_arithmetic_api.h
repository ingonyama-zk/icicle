#pragma once

#include <cstdint>
#include <gtest/gtest.h>
#include <sys/types.h>
#include <fstream>


#include "icicle/runtime.h"
#include "icicle/vec_ops.h"
#include "icicle/ntt.h"

#include "icicle/fields/field_config.h"
#include "icicle/utils/log.h"
#include "icicle/backend/ntt_config.h"

#include "icicle/program/symbol.h"
#include "icicle/program/program.h"
#include "icicle/program/returning_value_program.h"
#include "../backend/cpu/include/cpu_program_executor.h"

#include "test_base.h"

using namespace field_config;
using namespace icicle;

// TODO Hadar - add tests that test different configurations of data on device or on host.

static bool VERBOSE = true;
static int ITERS = 1;

class ModArithTestBase : public IcicleTestBase
{
};
template <typename T>
class ModArithTest : public ModArithTestBase
{
public:
  void random_samples(T* arr, uint64_t count)
  {
    for (uint64_t i = 0; i < count; i++)
      arr[i] = i < 1000 ? T::rand_host() : arr[i - 1000];
  }
};

#ifdef EXT_FIELD
typedef testing::Types<scalar_t, extension_t> FTImplementations;
#elif defined(RING)
typedef testing::Types<scalar_t, scalar_rns_t> FTImplementations;
#elif defined(FIELD)
typedef testing::Types<scalar_t> FTImplementations;
#else
  #error invalid type for ring and field test
#endif


constexpr uint32_t best_layers_sub_logn[25][3] = {
  {0, 0, 0},
  {1, 0, 0},
  {2, 0, 0},
  {3, 0, 0},
  {4, 0, 0},
  {5, 0, 0},
  {3, 3, 0},
  {4, 3, 0},

   {4, 4, 0},
   {5, 4, 0},
   {5, 5, 0},
   {4, 4, 3},
   {4, 4, 4},
   {5, 4, 4},
   {5, 5, 4},
   {5, 5, 5},
   {5, 5, 6},
   {5, 5, 7},
   {5, 5, 8},
   {5, 5, 9},
   {5, 5, 10},
   {5, 5, 11},
   {5, 5, 12},
   {5, 5, 13},
   {5, 5, 14}};

  constexpr uint32_t layers_sub_logn_nof_devisions[25]={
    1,1, 2, 4, 7, 11, 16, 22, 29, 37, 46,
    56, 67, 79, 92, 106, 121, 137, 154, 172, 191,
    211, 232, 254, 277
  };

  constexpr uint32_t layers_sub_logn[25][277][3] = {
    { {0, 0, 0} },
    { {1, 0, 0} },
    { {2, 0, 0}, {1, 1, 0} },
    { {1, 1, 1}, {1, 2, 0}, {3, 0, 0}, {2, 1, 0} },
    { {1, 1, 2}, {1, 2, 1}, {4, 0, 0}, {1, 3, 0}, {2, 1, 1}, {2, 2, 0}, {3, 1, 0} },
    { {1, 1, 3}, {1, 2, 2}, {5, 0, 0}, {1, 3, 1}, {1, 4, 0}, {2, 1, 2}, {2, 2, 1}, {2, 3, 0}, {3, 1, 1}, {3, 2, 0}, {4, 1, 0} },
    { {1, 1, 4}, {1, 2, 3}, {3, 3, 0}, {1, 3, 2}, {1, 4, 1}, {1, 5, 0}, {2, 1, 3}, {2, 2, 2}, {2, 3, 1}, {2, 4, 0}, {3, 1, 2}, {3, 2, 1}, {4, 1, 1}, {4, 2, 0}, {5, 1, 0}, {6, 0, 0} },
    { {1, 1, 5}, {1, 2, 4}, {4, 3, 0}, {1, 3, 3}, {1, 4, 2}, {1, 5, 1}, {1, 6, 0}, {2, 1, 4}, {2, 2, 3}, {2, 3, 2}, {2, 4, 1}, {2, 5, 0}, {3, 1, 3}, {3, 2, 2}, {3, 3, 1}, {3, 4, 0}, {4, 1, 2}, {4, 2, 1}, {5, 1, 1}, {5, 2, 0}, {6, 1, 0}, {7, 0, 0} },
    { {1, 1, 6}, {1, 2, 5}, {4, 4, 0}, {1, 3, 4}, {1, 4, 3}, {1, 5, 2}, {1, 6, 1}, {1, 7, 0}, {2, 1, 5}, {2, 2, 4}, {2, 3, 3}, {2, 4, 2}, {2, 5, 1}, {2, 6, 0}, {3, 1, 4}, {3, 2, 3}, {3, 3, 2}, {3, 4, 1}, {3, 5, 0}, {4, 1, 3}, {4, 2, 2}, {4, 3, 1}, {5, 1, 2}, {5, 2, 1}, {5, 3, 0}, {6, 1, 1}, {6, 2, 0}, {7, 1, 0}, {8, 0, 0} },
    { {1, 1, 7}, {1, 2, 6}, {5, 4, 0}, {1, 3, 5}, {1, 4, 4}, {1, 5, 3}, {1, 6, 2}, {1, 7, 1}, {1, 8, 0}, {2, 1, 6}, {2, 2, 5}, {2, 3, 4}, {2, 4, 3}, {2, 5, 2}, {2, 6, 1}, {2, 7, 0}, {3, 1, 5}, {3, 2, 4}, {3, 3, 3}, {3, 4, 2}, {3, 5, 1}, {3, 6, 0}, {4, 1, 4}, {4, 2, 3}, {4, 3, 2}, {4, 4, 1}, {4, 5, 0}, {5, 1, 3}, {5, 2, 2}, {5, 3, 1}, {6, 1, 2}, {6, 2, 1}, {6, 3, 0}, {7, 1, 1}, {7, 2, 0}, {8, 1, 0}, {9, 0, 0} },
    { {1, 1, 8}, {1, 2, 7}, {5, 5, 0}, {1, 3, 6}, {1, 4, 5}, {1, 5, 4}, {1, 6, 3}, {1, 7, 2}, {1, 8, 1}, {1, 9, 0}, {2, 1, 7}, {2, 2, 6}, {2, 3, 5}, {2, 4, 4}, {2, 5, 3}, {2, 6, 2}, {2, 7, 1}, {2, 8, 0}, {3, 1, 6}, {3, 2, 5}, {3, 3, 4}, {3, 4, 3}, {3, 5, 2}, {3, 6, 1}, {3, 7, 0}, {4, 1, 5}, {4, 2, 4}, {4, 3, 3}, {4, 4, 2}, {4, 5, 1}, {4, 6, 0}, {5, 1, 4}, {5, 2, 3}, {5, 3, 2}, {5, 4, 1}, {6, 1, 3}, {6, 2, 2}, {6, 3, 1}, {6, 4, 0}, {7, 1, 2}, {7, 2, 1}, {7, 3, 0}, {8, 1, 1}, {8, 2, 0}, {9, 1, 0}, {10, 0, 0} },
    { {1, 1, 9}, {1, 2, 8}, {4, 4, 3}, {1, 3, 7}, {1, 4, 6}, {1, 5, 5}, {1, 6, 4}, {1, 7, 3}, {1, 8, 2}, {1, 9, 1}, {1, 10, 0}, {2, 1, 8}, {2, 2, 7}, {2, 3, 6}, {2, 4, 5}, {2, 5, 4}, {2, 6, 3}, {2, 7, 2}, {2, 8, 1}, {2, 9, 0}, {3, 1, 7}, {3, 2, 6}, {3, 3, 5}, {3, 4, 4}, {3, 5, 3}, {3, 6, 2}, {3, 7, 1}, {3, 8, 0}, {4, 1, 6}, {4, 2, 5}, {4, 3, 4}, {4, 5, 2}, {4, 6, 1}, {4, 7, 0}, {5, 1, 5}, {5, 2, 4}, {5, 3, 3}, {5, 4, 2}, {5, 5, 1}, {5, 6, 0}, {6, 1, 4}, {6, 2, 3}, {6, 3, 2}, {6, 4, 1}, {6, 5, 0}, {7, 1, 3}, {7, 2, 2}, {7, 3, 1}, {7, 4, 0}, {8, 1, 2}, {8, 2, 1}, {8, 3, 0}, {9, 1, 1}, {9, 2, 0}, {10, 1, 0}, {11, 0, 0} },
    { {1, 1, 10}, {1, 2, 9}, {4, 4, 4}, {1, 3, 8}, {1, 4, 7}, {1, 5, 6}, {1, 6, 5}, {1, 7, 4}, {1, 8, 3}, {1, 9, 2}, {1, 10, 1}, {1, 11, 0}, {2, 1, 9}, {2, 2, 8}, {2, 3, 7}, {2, 4, 6}, {2, 5, 5}, {2, 6, 4}, {2, 7, 3}, {2, 8, 2}, {2, 9, 1}, {2, 10, 0}, {3, 1, 8}, {3, 2, 7}, {3, 3, 6}, {3, 4, 5}, {3, 5, 4}, {3, 6, 3}, {3, 7, 2}, {3, 8, 1}, {3, 9, 0}, {4, 1, 7}, {4, 2, 6}, {4, 3, 5}, {4, 5, 3}, {4, 6, 2}, {4, 7, 1}, {4, 8, 0}, {5, 1, 6}, {5, 2, 5}, {5, 3, 4}, {5, 4, 3}, {5, 5, 2}, {5, 6, 1}, {5, 7, 0}, {6, 1, 5}, {6, 2, 4}, {6, 3, 3}, {6, 4, 2}, {6, 5, 1}, {6, 6, 0}, {7, 1, 4}, {7, 2, 3}, {7, 3, 2}, {7, 4, 1}, {7, 5, 0}, {8, 1, 3}, {8, 2, 2}, {8, 3, 1}, {8, 4, 0}, {9, 1, 2}, {9, 2, 1}, {9, 3, 0}, {10, 1, 1}, {10, 2, 0}, {11, 1, 0}, {12, 0, 0} },
    { {1, 1, 11}, {1, 2, 10}, {5, 4, 4}, {1, 3, 9}, {1, 4, 8}, {1, 5, 7}, {1, 6, 6}, {1, 7, 5}, {1, 8, 4}, {1, 9, 3}, {1, 10, 2}, {1, 11, 1}, {1, 12, 0}, {2, 1, 10}, {2, 2, 9}, {2, 3, 8}, {2, 4, 7}, {2, 5, 6}, {2, 6, 5}, {2, 7, 4}, {2, 8, 3}, {2, 9, 2}, {2, 10, 1}, {2, 11, 0}, {3, 1, 9}, {3, 2, 8}, {3, 3, 7}, {3, 4, 6}, {3, 5, 5}, {3, 6, 4}, {3, 7, 3}, {3, 8, 2}, {3, 9, 1}, {3, 10, 0}, {4, 1, 8}, {4, 2, 7}, {4, 3, 6}, {4, 4, 5}, {4, 5, 4}, {4, 6, 3}, {4, 7, 2}, {4, 8, 1}, {4, 9, 0}, {5, 1, 7}, {5, 2, 6}, {5, 3, 5}, {5, 5, 3}, {5, 6, 2}, {5, 7, 1}, {5, 8, 0}, {6, 1, 6}, {6, 2, 5}, {6, 3, 4}, {6, 4, 3}, {6, 5, 2}, {6, 6, 1}, {6, 7, 0}, {7, 1, 5}, {7, 2, 4}, {7, 3, 3}, {7, 4, 2}, {7, 5, 1}, {7, 6, 0}, {8, 1, 4}, {8, 2, 3}, {8, 3, 2}, {8, 4, 1}, {8, 5, 0}, {9, 1, 3}, {9, 2, 2}, {9, 3, 1}, {9, 4, 0}, {10, 1, 2}, {10, 2, 1}, {10, 3, 0}, {11, 1, 1}, {11, 2, 0}, {12, 1, 0}, {13, 0, 0} },
    { {1, 1, 12}, {1, 2, 11}, {5, 5, 4}, {1, 3, 10}, {1, 4, 9}, {1, 5, 8}, {1, 6, 7}, {1, 7, 6}, {1, 8, 5}, {1, 9, 4}, {1, 10, 3}, {1, 11, 2}, {1, 12, 1}, {1, 13, 0}, {2, 1, 11}, {2, 2, 10}, {2, 3, 9}, {2, 4, 8}, {2, 5, 7}, {2, 6, 6}, {2, 7, 5}, {2, 8, 4}, {2, 9, 3}, {2, 10, 2}, {2, 11, 1}, {2, 12, 0}, {3, 1, 10}, {3, 2, 9}, {3, 3, 8}, {3, 4, 7}, {3, 5, 6}, {3, 6, 5}, {3, 7, 4}, {3, 8, 3}, {3, 9, 2}, {3, 10, 1}, {3, 11, 0}, {4, 1, 9}, {4, 2, 8}, {4, 3, 7}, {4, 4, 6}, {4, 5, 5}, {4, 6, 4}, {4, 7, 3}, {4, 8, 2}, {4, 9, 1}, {4, 10, 0}, {5, 1, 8}, {5, 2, 7}, {5, 3, 6}, {5, 4, 5}, {5, 6, 3}, {5, 7, 2}, {5, 8, 1}, {5, 9, 0}, {6, 1, 7}, {6, 2, 6}, {6, 3, 5}, {6, 4, 4}, {6, 5, 3}, {6, 6, 2}, {6, 7, 1}, {6, 8, 0}, {7, 1, 6}, {7, 2, 5}, {7, 3, 4}, {7, 4, 3}, {7, 5, 2}, {7, 6, 1}, {7, 7, 0}, {8, 1, 5}, {8, 2, 4}, {8, 3, 3}, {8, 4, 2}, {8, 5, 1}, {8, 6, 0}, {9, 1, 4}, {9, 2, 3}, {9, 3, 2}, {9, 4, 1}, {9, 5, 0}, {10, 1, 3}, {10, 2, 2}, {10, 3, 1}, {10, 4, 0}, {11, 1, 2}, {11, 2, 1}, {11, 3, 0}, {12, 1, 1}, {12, 2, 0}, {13, 1, 0}, {14, 0, 0} },
    { {1, 1, 13}, {1, 2, 12}, {5, 5, 5}, {1, 3, 11}, {1, 4, 10}, {1, 5, 9}, {1, 6, 8}, {1, 7, 7}, {1, 8, 6}, {1, 9, 5}, {1, 10, 4}, {1, 11, 3}, {1, 12, 2}, {1, 13, 1}, {1, 14, 0}, {2, 1, 12}, {2, 2, 11}, {2, 3, 10}, {2, 4, 9}, {2, 5, 8}, {2, 6, 7}, {2, 7, 6}, {2, 8, 5}, {2, 9, 4}, {2, 10, 3}, {2, 11, 2}, {2, 12, 1}, {2, 13, 0}, {3, 1, 11}, {3, 2, 10}, {3, 3, 9}, {3, 4, 8}, {3, 5, 7}, {3, 6, 6}, {3, 7, 5}, {3, 8, 4}, {3, 9, 3}, {3, 10, 2}, {3, 11, 1}, {3, 12, 0}, {4, 1, 10}, {4, 2, 9}, {4, 3, 8}, {4, 4, 7}, {4, 5, 6}, {4, 6, 5}, {4, 7, 4}, {4, 8, 3}, {4, 9, 2}, {4, 10, 1}, {4, 11, 0}, {5, 1, 9}, {5, 2, 8}, {5, 3, 7}, {5, 4, 6}, {5, 6, 4}, {5, 7, 3}, {5, 8, 2}, {5, 9, 1}, {5, 10, 0}, {6, 1, 8}, {6, 2, 7}, {6, 3, 6}, {6, 4, 5}, {6, 5, 4}, {6, 6, 3}, {6, 7, 2}, {6, 8, 1}, {6, 9, 0}, {7, 1, 7}, {7, 2, 6}, {7, 3, 5}, {7, 4, 4}, {7, 5, 3}, {7, 6, 2}, {7, 7, 1}, {7, 8, 0}, {8, 1, 6}, {8, 2, 5}, {8, 3, 4}, {8, 4, 3}, {8, 5, 2}, {8, 6, 1}, {8, 7, 0}, {9, 1, 5}, {9, 2, 4}, {9, 3, 3}, {9, 4, 2}, {9, 5, 1}, {9, 6, 0}, {10, 1, 4}, {10, 2, 3}, {10, 3, 2}, {10, 4, 1}, {10, 5, 0}, {11, 1, 3}, {11, 2, 2}, {11, 3, 1}, {11, 4, 0}, {12, 1, 2}, {12, 2, 1}, {12, 3, 0}, {13, 1, 1}, {13, 2, 0}, {14, 1, 0}, {15, 0, 0} },
    { {1, 1, 14}, {1, 2, 13}, {5, 5, 6}, {1, 3, 12}, {1, 4, 11}, {1, 5, 10}, {1, 6, 9}, {1, 7, 8}, {1, 8, 7}, {1, 9, 6}, {1, 10, 5}, {1, 11, 4}, {1, 12, 3}, {1, 13, 2}, {1, 14, 1}, {1, 15, 0}, {2, 1, 13}, {2, 2, 12}, {2, 3, 11}, {2, 4, 10}, {2, 5, 9}, {2, 6, 8}, {2, 7, 7}, {2, 8, 6}, {2, 9, 5}, {2, 10, 4}, {2, 11, 3}, {2, 12, 2}, {2, 13, 1}, {2, 14, 0}, {3, 1, 12}, {3, 2, 11}, {3, 3, 10}, {3, 4, 9}, {3, 5, 8}, {3, 6, 7}, {3, 7, 6}, {3, 8, 5}, {3, 9, 4}, {3, 10, 3}, {3, 11, 2}, {3, 12, 1}, {3, 13, 0}, {4, 1, 11}, {4, 2, 10}, {4, 3, 9}, {4, 4, 8}, {4, 5, 7}, {4, 6, 6}, {4, 7, 5}, {4, 8, 4}, {4, 9, 3}, {4, 10, 2}, {4, 11, 1}, {4, 12, 0}, {5, 1, 10}, {5, 2, 9}, {5, 3, 8}, {5, 4, 7}, {5, 6, 5}, {5, 7, 4}, {5, 8, 3}, {5, 9, 2}, {5, 10, 1}, {5, 11, 0}, {6, 1, 9}, {6, 2, 8}, {6, 3, 7}, {6, 4, 6}, {6, 5, 5}, {6, 6, 4}, {6, 7, 3}, {6, 8, 2}, {6, 9, 1}, {6, 10, 0}, {7, 1, 8}, {7, 2, 7}, {7, 3, 6}, {7, 4, 5}, {7, 5, 4}, {7, 6, 3}, {7, 7, 2}, {7, 8, 1}, {7, 9, 0}, {8, 1, 7}, {8, 2, 6}, {8, 3, 5}, {8, 4, 4}, {8, 5, 3}, {8, 6, 2}, {8, 7, 1}, {8, 8, 0}, {9, 1, 6}, {9, 2, 5}, {9, 3, 4}, {9, 4, 3}, {9, 5, 2}, {9, 6, 1}, {9, 7, 0}, {10, 1, 5}, {10, 2, 4}, {10, 3, 3}, {10, 4, 2}, {10, 5, 1}, {10, 6, 0}, {11, 1, 4}, {11, 2, 3}, {11, 3, 2}, {11, 4, 1}, {11, 5, 0}, {12, 1, 3}, {12, 2, 2}, {12, 3, 1}, {12, 4, 0}, {13, 1, 2}, {13, 2, 1}, {13, 3, 0}, {14, 1, 1}, {14, 2, 0}, {15, 1, 0}, {16, 0, 0} },
    { {1, 1, 15}, {1, 2, 14}, {5, 5, 7}, {1, 3, 13}, {1, 4, 12}, {1, 5, 11}, {1, 6, 10}, {1, 7, 9}, {1, 8, 8}, {1, 9, 7}, {1, 10, 6}, {1, 11, 5}, {1, 12, 4}, {1, 13, 3}, {1, 14, 2}, {1, 15, 1}, {1, 16, 0}, {2, 1, 14}, {2, 2, 13}, {2, 3, 12}, {2, 4, 11}, {2, 5, 10}, {2, 6, 9}, {2, 7, 8}, {2, 8, 7}, {2, 9, 6}, {2, 10, 5}, {2, 11, 4}, {2, 12, 3}, {2, 13, 2}, {2, 14, 1}, {2, 15, 0}, {3, 1, 13}, {3, 2, 12}, {3, 3, 11}, {3, 4, 10}, {3, 5, 9}, {3, 6, 8}, {3, 7, 7}, {3, 8, 6}, {3, 9, 5}, {3, 10, 4}, {3, 11, 3}, {3, 12, 2}, {3, 13, 1}, {3, 14, 0}, {4, 1, 12}, {4, 2, 11}, {4, 3, 10}, {4, 4, 9}, {4, 5, 8}, {4, 6, 7}, {4, 7, 6}, {4, 8, 5}, {4, 9, 4}, {4, 10, 3}, {4, 11, 2}, {4, 12, 1}, {4, 13, 0}, {5, 1, 11}, {5, 2, 10}, {5, 3, 9}, {5, 4, 8}, {5, 6, 6}, {5, 7, 5}, {5, 8, 4}, {5, 9, 3}, {5, 10, 2}, {5, 11, 1}, {5, 12, 0}, {6, 1, 10}, {6, 2, 9}, {6, 3, 8}, {6, 4, 7}, {6, 5, 6}, {6, 6, 5}, {6, 7, 4}, {6, 8, 3}, {6, 9, 2}, {6, 10, 1}, {6, 11, 0}, {7, 1, 9}, {7, 2, 8}, {7, 3, 7}, {7, 4, 6}, {7, 5, 5}, {7, 6, 4}, {7, 7, 3}, {7, 8, 2}, {7, 9, 1}, {7, 10, 0}, {8, 1, 8}, {8, 2, 7}, {8, 3, 6}, {8, 4, 5}, {8, 5, 4}, {8, 6, 3}, {8, 7, 2}, {8, 8, 1}, {8, 9, 0}, {9, 1, 7}, {9, 2, 6}, {9, 3, 5}, {9, 4, 4}, {9, 5, 3}, {9, 6, 2}, {9, 7, 1}, {9, 8, 0}, {10, 1, 6}, {10, 2, 5}, {10, 3, 4}, {10, 4, 3}, {10, 5, 2}, {10, 6, 1}, {10, 7, 0}, {11, 1, 5}, {11, 2, 4}, {11, 3, 3}, {11, 4, 2}, {11, 5, 1}, {11, 6, 0}, {12, 1, 4}, {12, 2, 3}, {12, 3, 2}, {12, 4, 1}, {12, 5, 0}, {13, 1, 3}, {13, 2, 2}, {13, 3, 1}, {13, 4, 0}, {14, 1, 2}, {14, 2, 1}, {14, 3, 0}, {15, 1, 1}, {15, 2, 0}, {16, 1, 0}, {17, 0, 0} },
    { {1, 1, 16}, {1, 2, 15}, {5, 5, 8}, {1, 3, 14}, {1, 4, 13}, {1, 5, 12}, {1, 6, 11}, {1, 7, 10}, {1, 8, 9}, {1, 9, 8}, {1, 10, 7}, {1, 11, 6}, {1, 12, 5}, {1, 13, 4}, {1, 14, 3}, {1, 15, 2}, {1, 16, 1}, {1, 17, 0}, {2, 1, 15}, {2, 2, 14}, {2, 3, 13}, {2, 4, 12}, {2, 5, 11}, {2, 6, 10}, {2, 7, 9}, {2, 8, 8}, {2, 9, 7}, {2, 10, 6}, {2, 11, 5}, {2, 12, 4}, {2, 13, 3}, {2, 14, 2}, {2, 15, 1}, {2, 16, 0}, {3, 1, 14}, {3, 2, 13}, {3, 3, 12}, {3, 4, 11}, {3, 5, 10}, {3, 6, 9}, {3, 7, 8}, {3, 8, 7}, {3, 9, 6}, {3, 10, 5}, {3, 11, 4}, {3, 12, 3}, {3, 13, 2}, {3, 14, 1}, {3, 15, 0}, {4, 1, 13}, {4, 2, 12}, {4, 3, 11}, {4, 4, 10}, {4, 5, 9}, {4, 6, 8}, {4, 7, 7}, {4, 8, 6}, {4, 9, 5}, {4, 10, 4}, {4, 11, 3}, {4, 12, 2}, {4, 13, 1}, {4, 14, 0}, {5, 1, 12}, {5, 2, 11}, {5, 3, 10}, {5, 4, 9}, {5, 6, 7}, {5, 7, 6}, {5, 8, 5}, {5, 9, 4}, {5, 10, 3}, {5, 11, 2}, {5, 12, 1}, {5, 13, 0}, {6, 1, 11}, {6, 2, 10}, {6, 3, 9}, {6, 4, 8}, {6, 5, 7}, {6, 6, 6}, {6, 7, 5}, {6, 8, 4}, {6, 9, 3}, {6, 10, 2}, {6, 11, 1}, {6, 12, 0}, {7, 1, 10}, {7, 2, 9}, {7, 3, 8}, {7, 4, 7}, {7, 5, 6}, {7, 6, 5}, {7, 7, 4}, {7, 8, 3}, {7, 9, 2}, {7, 10, 1}, {7, 11, 0}, {8, 1, 9}, {8, 2, 8}, {8, 3, 7}, {8, 4, 6}, {8, 5, 5}, {8, 6, 4}, {8, 7, 3}, {8, 8, 2}, {8, 9, 1}, {8, 10, 0}, {9, 1, 8}, {9, 2, 7}, {9, 3, 6}, {9, 4, 5}, {9, 5, 4}, {9, 6, 3}, {9, 7, 2}, {9, 8, 1}, {9, 9, 0}, {10, 1, 7}, {10, 2, 6}, {10, 3, 5}, {10, 4, 4}, {10, 5, 3}, {10, 6, 2}, {10, 7, 1}, {10, 8, 0}, {11, 1, 6}, {11, 2, 5}, {11, 3, 4}, {11, 4, 3}, {11, 5, 2}, {11, 6, 1}, {11, 7, 0}, {12, 1, 5}, {12, 2, 4}, {12, 3, 3}, {12, 4, 2}, {12, 5, 1}, {12, 6, 0}, {13, 1, 4}, {13, 2, 3}, {13, 3, 2}, {13, 4, 1}, {13, 5, 0}, {14, 1, 3}, {14, 2, 2}, {14, 3, 1}, {14, 4, 0}, {15, 1, 2}, {15, 2, 1}, {15, 3, 0}, {16, 1, 1}, {16, 2, 0}, {17, 1, 0}, {18, 0, 0} },
    { {1, 1, 17}, {1, 2, 16}, {5, 5, 9}, {1, 3, 15}, {1, 4, 14}, {1, 5, 13}, {1, 6, 12}, {1, 7, 11}, {1, 8, 10}, {1, 9, 9}, {1, 10, 8}, {1, 11, 7}, {1, 12, 6}, {1, 13, 5}, {1, 14, 4}, {1, 15, 3}, {1, 16, 2}, {1, 17, 1}, {1, 18, 0}, {2, 1, 16}, {2, 2, 15}, {2, 3, 14}, {2, 4, 13}, {2, 5, 12}, {2, 6, 11}, {2, 7, 10}, {2, 8, 9}, {2, 9, 8}, {2, 10, 7}, {2, 11, 6}, {2, 12, 5}, {2, 13, 4}, {2, 14, 3}, {2, 15, 2}, {2, 16, 1}, {2, 17, 0}, {3, 1, 15}, {3, 2, 14}, {3, 3, 13}, {3, 4, 12}, {3, 5, 11}, {3, 6, 10}, {3, 7, 9}, {3, 8, 8}, {3, 9, 7}, {3, 10, 6}, {3, 11, 5}, {3, 12, 4}, {3, 13, 3}, {3, 14, 2}, {3, 15, 1}, {3, 16, 0}, {4, 1, 14}, {4, 2, 13}, {4, 3, 12}, {4, 4, 11}, {4, 5, 10}, {4, 6, 9}, {4, 7, 8}, {4, 8, 7}, {4, 9, 6}, {4, 10, 5}, {4, 11, 4}, {4, 12, 3}, {4, 13, 2}, {4, 14, 1}, {4, 15, 0}, {5, 1, 13}, {5, 2, 12}, {5, 3, 11}, {5, 4, 10}, {5, 6, 8}, {5, 7, 7}, {5, 8, 6}, {5, 9, 5}, {5, 10, 4}, {5, 11, 3}, {5, 12, 2}, {5, 13, 1}, {5, 14, 0}, {6, 1, 12}, {6, 2, 11}, {6, 3, 10}, {6, 4, 9}, {6, 5, 8}, {6, 6, 7}, {6, 7, 6}, {6, 8, 5}, {6, 9, 4}, {6, 10, 3}, {6, 11, 2}, {6, 12, 1}, {6, 13, 0}, {7, 1, 11}, {7, 2, 10}, {7, 3, 9}, {7, 4, 8}, {7, 5, 7}, {7, 6, 6}, {7, 7, 5}, {7, 8, 4}, {7, 9, 3}, {7, 10, 2}, {7, 11, 1}, {7, 12, 0}, {8, 1, 10}, {8, 2, 9}, {8, 3, 8}, {8, 4, 7}, {8, 5, 6}, {8, 6, 5}, {8, 7, 4}, {8, 8, 3}, {8, 9, 2}, {8, 10, 1}, {8, 11, 0}, {9, 1, 9}, {9, 2, 8}, {9, 3, 7}, {9, 4, 6}, {9, 5, 5}, {9, 6, 4}, {9, 7, 3}, {9, 8, 2}, {9, 9, 1}, {9, 10, 0}, {10, 1, 8}, {10, 2, 7}, {10, 3, 6}, {10, 4, 5}, {10, 5, 4}, {10, 6, 3}, {10, 7, 2}, {10, 8, 1}, {10, 9, 0}, {11, 1, 7}, {11, 2, 6}, {11, 3, 5}, {11, 4, 4}, {11, 5, 3}, {11, 6, 2}, {11, 7, 1}, {11, 8, 0}, {12, 1, 6}, {12, 2, 5}, {12, 3, 4}, {12, 4, 3}, {12, 5, 2}, {12, 6, 1}, {12, 7, 0}, {13, 1, 5}, {13, 2, 4}, {13, 3, 3}, {13, 4, 2}, {13, 5, 1}, {13, 6, 0}, {14, 1, 4}, {14, 2, 3}, {14, 3, 2}, {14, 4, 1}, {14, 5, 0}, {15, 1, 3}, {15, 2, 2}, {15, 3, 1}, {15, 4, 0}, {16, 1, 2}, {16, 2, 1}, {16, 3, 0}, {17, 1, 1}, {17, 2, 0}, {18, 1, 0}, {19, 0, 0} },
    { {1, 1, 18}, {1, 2, 17}, {5, 5, 10}, {1, 3, 16}, {1, 4, 15}, {1, 5, 14}, {1, 6, 13}, {1, 7, 12}, {1, 8, 11}, {1, 9, 10}, {1, 10, 9}, {1, 11, 8}, {1, 12, 7}, {1, 13, 6}, {1, 14, 5}, {1, 15, 4}, {1, 16, 3}, {1, 17, 2}, {1, 18, 1}, {1, 19, 0}, {2, 1, 17}, {2, 2, 16}, {2, 3, 15}, {2, 4, 14}, {2, 5, 13}, {2, 6, 12}, {2, 7, 11}, {2, 8, 10}, {2, 9, 9}, {2, 10, 8}, {2, 11, 7}, {2, 12, 6}, {2, 13, 5}, {2, 14, 4}, {2, 15, 3}, {2, 16, 2}, {2, 17, 1}, {2, 18, 0}, {3, 1, 16}, {3, 2, 15}, {3, 3, 14}, {3, 4, 13}, {3, 5, 12}, {3, 6, 11}, {3, 7, 10}, {3, 8, 9}, {3, 9, 8}, {3, 10, 7}, {3, 11, 6}, {3, 12, 5}, {3, 13, 4}, {3, 14, 3}, {3, 15, 2}, {3, 16, 1}, {3, 17, 0}, {4, 1, 15}, {4, 2, 14}, {4, 3, 13}, {4, 4, 12}, {4, 5, 11}, {4, 6, 10}, {4, 7, 9}, {4, 8, 8}, {4, 9, 7}, {4, 10, 6}, {4, 11, 5}, {4, 12, 4}, {4, 13, 3}, {4, 14, 2}, {4, 15, 1}, {4, 16, 0}, {5, 1, 14}, {5, 2, 13}, {5, 3, 12}, {5, 4, 11}, {5, 6, 9}, {5, 7, 8}, {5, 8, 7}, {5, 9, 6}, {5, 10, 5}, {5, 11, 4}, {5, 12, 3}, {5, 13, 2}, {5, 14, 1}, {5, 15, 0}, {6, 1, 13}, {6, 2, 12}, {6, 3, 11}, {6, 4, 10}, {6, 5, 9}, {6, 6, 8}, {6, 7, 7}, {6, 8, 6}, {6, 9, 5}, {6, 10, 4}, {6, 11, 3}, {6, 12, 2}, {6, 13, 1}, {6, 14, 0}, {7, 1, 12}, {7, 2, 11}, {7, 3, 10}, {7, 4, 9}, {7, 5, 8}, {7, 6, 7}, {7, 7, 6}, {7, 8, 5}, {7, 9, 4}, {7, 10, 3}, {7, 11, 2}, {7, 12, 1}, {7, 13, 0}, {8, 1, 11}, {8, 2, 10}, {8, 3, 9}, {8, 4, 8}, {8, 5, 7}, {8, 6, 6}, {8, 7, 5}, {8, 8, 4}, {8, 9, 3}, {8, 10, 2}, {8, 11, 1}, {8, 12, 0}, {9, 1, 10}, {9, 2, 9}, {9, 3, 8}, {9, 4, 7}, {9, 5, 6}, {9, 6, 5}, {9, 7, 4}, {9, 8, 3}, {9, 9, 2}, {9, 10, 1}, {9, 11, 0}, {10, 1, 9}, {10, 2, 8}, {10, 3, 7}, {10, 4, 6}, {10, 5, 5}, {10, 6, 4}, {10, 7, 3}, {10, 8, 2}, {10, 9, 1}, {10, 10, 0}, {11, 1, 8}, {11, 2, 7}, {11, 3, 6}, {11, 4, 5}, {11, 5, 4}, {11, 6, 3}, {11, 7, 2}, {11, 8, 1}, {11, 9, 0}, {12, 1, 7}, {12, 2, 6}, {12, 3, 5}, {12, 4, 4}, {12, 5, 3}, {12, 6, 2}, {12, 7, 1}, {12, 8, 0}, {13, 1, 6}, {13, 2, 5}, {13, 3, 4}, {13, 4, 3}, {13, 5, 2}, {13, 6, 1}, {13, 7, 0}, {14, 1, 5}, {14, 2, 4}, {14, 3, 3}, {14, 4, 2}, {14, 5, 1}, {14, 6, 0}, {15, 1, 4}, {15, 2, 3}, {15, 3, 2}, {15, 4, 1}, {15, 5, 0}, {16, 1, 3}, {16, 2, 2}, {16, 3, 1}, {16, 4, 0}, {17, 1, 2}, {17, 2, 1}, {17, 3, 0}, {18, 1, 1}, {18, 2, 0}, {19, 1, 0}, {20, 0, 0} },
    { {1, 1, 19}, {1, 2, 18}, {5, 5, 11}, {1, 3, 17}, {1, 4, 16}, {1, 5, 15}, {1, 6, 14}, {1, 7, 13}, {1, 8, 12}, {1, 9, 11}, {1, 10, 10}, {1, 11, 9}, {1, 12, 8}, {1, 13, 7}, {1, 14, 6}, {1, 15, 5}, {1, 16, 4}, {1, 17, 3}, {1, 18, 2}, {1, 19, 1}, {1, 20, 0}, {2, 1, 18}, {2, 2, 17}, {2, 3, 16}, {2, 4, 15}, {2, 5, 14}, {2, 6, 13}, {2, 7, 12}, {2, 8, 11}, {2, 9, 10}, {2, 10, 9}, {2, 11, 8}, {2, 12, 7}, {2, 13, 6}, {2, 14, 5}, {2, 15, 4}, {2, 16, 3}, {2, 17, 2}, {2, 18, 1}, {2, 19, 0}, {3, 1, 17}, {3, 2, 16}, {3, 3, 15}, {3, 4, 14}, {3, 5, 13}, {3, 6, 12}, {3, 7, 11}, {3, 8, 10}, {3, 9, 9}, {3, 10, 8}, {3, 11, 7}, {3, 12, 6}, {3, 13, 5}, {3, 14, 4}, {3, 15, 3}, {3, 16, 2}, {3, 17, 1}, {3, 18, 0}, {4, 1, 16}, {4, 2, 15}, {4, 3, 14}, {4, 4, 13}, {4, 5, 12}, {4, 6, 11}, {4, 7, 10}, {4, 8, 9}, {4, 9, 8}, {4, 10, 7}, {4, 11, 6}, {4, 12, 5}, {4, 13, 4}, {4, 14, 3}, {4, 15, 2}, {4, 16, 1}, {4, 17, 0}, {5, 1, 15}, {5, 2, 14}, {5, 3, 13}, {5, 4, 12}, {5, 6, 10}, {5, 7, 9}, {5, 8, 8}, {5, 9, 7}, {5, 10, 6}, {5, 11, 5}, {5, 12, 4}, {5, 13, 3}, {5, 14, 2}, {5, 15, 1}, {5, 16, 0}, {6, 1, 14}, {6, 2, 13}, {6, 3, 12}, {6, 4, 11}, {6, 5, 10}, {6, 6, 9}, {6, 7, 8}, {6, 8, 7}, {6, 9, 6}, {6, 10, 5}, {6, 11, 4}, {6, 12, 3}, {6, 13, 2}, {6, 14, 1}, {6, 15, 0}, {7, 1, 13}, {7, 2, 12}, {7, 3, 11}, {7, 4, 10}, {7, 5, 9}, {7, 6, 8}, {7, 7, 7}, {7, 8, 6}, {7, 9, 5}, {7, 10, 4}, {7, 11, 3}, {7, 12, 2}, {7, 13, 1}, {7, 14, 0}, {8, 1, 12}, {8, 2, 11}, {8, 3, 10}, {8, 4, 9}, {8, 5, 8}, {8, 6, 7}, {8, 7, 6}, {8, 8, 5}, {8, 9, 4}, {8, 10, 3}, {8, 11, 2}, {8, 12, 1}, {8, 13, 0}, {9, 1, 11}, {9, 2, 10}, {9, 3, 9}, {9, 4, 8}, {9, 5, 7}, {9, 6, 6}, {9, 7, 5}, {9, 8, 4}, {9, 9, 3}, {9, 10, 2}, {9, 11, 1}, {9, 12, 0}, {10, 1, 10}, {10, 2, 9}, {10, 3, 8}, {10, 4, 7}, {10, 5, 6}, {10, 6, 5}, {10, 7, 4}, {10, 8, 3}, {10, 9, 2}, {10, 10, 1}, {10, 11, 0}, {11, 1, 9}, {11, 2, 8}, {11, 3, 7}, {11, 4, 6}, {11, 5, 5}, {11, 6, 4}, {11, 7, 3}, {11, 8, 2}, {11, 9, 1}, {11, 10, 0}, {12, 1, 8}, {12, 2, 7}, {12, 3, 6}, {12, 4, 5}, {12, 5, 4}, {12, 6, 3}, {12, 7, 2}, {12, 8, 1}, {12, 9, 0}, {13, 1, 7}, {13, 2, 6}, {13, 3, 5}, {13, 4, 4}, {13, 5, 3}, {13, 6, 2}, {13, 7, 1}, {13, 8, 0}, {14, 1, 6}, {14, 2, 5}, {14, 3, 4}, {14, 4, 3}, {14, 5, 2}, {14, 6, 1}, {14, 7, 0}, {15, 1, 5}, {15, 2, 4}, {15, 3, 3}, {15, 4, 2}, {15, 5, 1}, {15, 6, 0}, {16, 1, 4}, {16, 2, 3}, {16, 3, 2}, {16, 4, 1}, {16, 5, 0}, {17, 1, 3}, {17, 2, 2}, {17, 3, 1}, {17, 4, 0}, {18, 1, 2}, {18, 2, 1}, {18, 3, 0}, {19, 1, 1}, {19, 2, 0}, {20, 1, 0}, {21, 0, 0} },
    { {1, 1, 20}, {1, 2, 19}, {5, 5, 12}, {1, 3, 18}, {1, 4, 17}, {1, 5, 16}, {1, 6, 15}, {1, 7, 14}, {1, 8, 13}, {1, 9, 12}, {1, 10, 11}, {1, 11, 10}, {1, 12, 9}, {1, 13, 8}, {1, 14, 7}, {1, 15, 6}, {1, 16, 5}, {1, 17, 4}, {1, 18, 3}, {1, 19, 2}, {1, 20, 1}, {1, 21, 0}, {2, 1, 19}, {2, 2, 18}, {2, 3, 17}, {2, 4, 16}, {2, 5, 15}, {2, 6, 14}, {2, 7, 13}, {2, 8, 12}, {2, 9, 11}, {2, 10, 10}, {2, 11, 9}, {2, 12, 8}, {2, 13, 7}, {2, 14, 6}, {2, 15, 5}, {2, 16, 4}, {2, 17, 3}, {2, 18, 2}, {2, 19, 1}, {2, 20, 0}, {3, 1, 18}, {3, 2, 17}, {3, 3, 16}, {3, 4, 15}, {3, 5, 14}, {3, 6, 13}, {3, 7, 12}, {3, 8, 11}, {3, 9, 10}, {3, 10, 9}, {3, 11, 8}, {3, 12, 7}, {3, 13, 6}, {3, 14, 5}, {3, 15, 4}, {3, 16, 3}, {3, 17, 2}, {3, 18, 1}, {3, 19, 0}, {4, 1, 17}, {4, 2, 16}, {4, 3, 15}, {4, 4, 14}, {4, 5, 13}, {4, 6, 12}, {4, 7, 11}, {4, 8, 10}, {4, 9, 9}, {4, 10, 8}, {4, 11, 7}, {4, 12, 6}, {4, 13, 5}, {4, 14, 4}, {4, 15, 3}, {4, 16, 2}, {4, 17, 1}, {4, 18, 0}, {5, 1, 16}, {5, 2, 15}, {5, 3, 14}, {5, 4, 13}, {5, 6, 11}, {5, 7, 10}, {5, 8, 9}, {5, 9, 8}, {5, 10, 7}, {5, 11, 6}, {5, 12, 5}, {5, 13, 4}, {5, 14, 3}, {5, 15, 2}, {5, 16, 1}, {5, 17, 0}, {6, 1, 15}, {6, 2, 14}, {6, 3, 13}, {6, 4, 12}, {6, 5, 11}, {6, 6, 10}, {6, 7, 9}, {6, 8, 8}, {6, 9, 7}, {6, 10, 6}, {6, 11, 5}, {6, 12, 4}, {6, 13, 3}, {6, 14, 2}, {6, 15, 1}, {6, 16, 0}, {7, 1, 14}, {7, 2, 13}, {7, 3, 12}, {7, 4, 11}, {7, 5, 10}, {7, 6, 9}, {7, 7, 8}, {7, 8, 7}, {7, 9, 6}, {7, 10, 5}, {7, 11, 4}, {7, 12, 3}, {7, 13, 2}, {7, 14, 1}, {7, 15, 0}, {8, 1, 13}, {8, 2, 12}, {8, 3, 11}, {8, 4, 10}, {8, 5, 9}, {8, 6, 8}, {8, 7, 7}, {8, 8, 6}, {8, 9, 5}, {8, 10, 4}, {8, 11, 3}, {8, 12, 2}, {8, 13, 1}, {8, 14, 0}, {9, 1, 12}, {9, 2, 11}, {9, 3, 10}, {9, 4, 9}, {9, 5, 8}, {9, 6, 7}, {9, 7, 6}, {9, 8, 5}, {9, 9, 4}, {9, 10, 3}, {9, 11, 2}, {9, 12, 1}, {9, 13, 0}, {10, 1, 11}, {10, 2, 10}, {10, 3, 9}, {10, 4, 8}, {10, 5, 7}, {10, 6, 6}, {10, 7, 5}, {10, 8, 4}, {10, 9, 3}, {10, 10, 2}, {10, 11, 1}, {10, 12, 0}, {11, 1, 10}, {11, 2, 9}, {11, 3, 8}, {11, 4, 7}, {11, 5, 6}, {11, 6, 5}, {11, 7, 4}, {11, 8, 3}, {11, 9, 2}, {11, 10, 1}, {11, 11, 0}, {12, 1, 9}, {12, 2, 8}, {12, 3, 7}, {12, 4, 6}, {12, 5, 5}, {12, 6, 4}, {12, 7, 3}, {12, 8, 2}, {12, 9, 1}, {12, 10, 0}, {13, 1, 8}, {13, 2, 7}, {13, 3, 6}, {13, 4, 5}, {13, 5, 4}, {13, 6, 3}, {13, 7, 2}, {13, 8, 1}, {13, 9, 0}, {14, 1, 7}, {14, 2, 6}, {14, 3, 5}, {14, 4, 4}, {14, 5, 3}, {14, 6, 2}, {14, 7, 1}, {14, 8, 0}, {15, 1, 6}, {15, 2, 5}, {15, 3, 4}, {15, 4, 3}, {15, 5, 2}, {15, 6, 1}, {15, 7, 0}, {16, 1, 5}, {16, 2, 4}, {16, 3, 3}, {16, 4, 2}, {16, 5, 1}, {16, 6, 0}, {17, 1, 4}, {17, 2, 3}, {17, 3, 2}, {17, 4, 1}, {17, 5, 0}, {18, 1, 3}, {18, 2, 2}, {18, 3, 1}, {18, 4, 0}, {19, 1, 2}, 
    {19, 2, 1}, {19, 3, 0}, {20, 1, 1}, {20, 2, 0}, {21, 1, 0}, {22, 0, 0} },
    { {1, 1, 21}, {1, 2, 20}, {5, 5, 13}, {1, 3, 19}, {1, 4, 18}, {1, 5, 17}, {1, 6, 16}, {1, 7, 15}, {1, 8, 14}, {1, 9, 13}, {1, 10, 12}, {1, 11, 11}, {1, 12, 10}, {1, 13, 9}, {1, 14, 8}, {1, 15, 7}, {1, 16, 6}, {1, 17, 5}, {1, 18, 4}, {1, 19, 3}, {1, 20, 2}, {1, 21, 1}, {1, 22, 0}, {2, 1, 20}, {2, 2, 19}, {2, 3, 18}, {2, 4, 17}, {2, 5, 16}, {2, 6, 15}, {2, 7, 14}, {2, 8, 13}, {2, 9, 12}, {2, 10, 11}, {2, 11, 10}, {2, 12, 9}, {2, 13, 8}, {2, 14, 7}, {2, 15, 6}, {2, 16, 5}, {2, 17, 4}, {2, 18, 3}, {2, 19, 2}, {2, 20, 1}, {2, 21, 0}, {3, 1, 19}, {3, 2, 18}, {3, 3, 17}, {3, 4, 16}, {3, 5, 15}, {3, 6, 14}, {3, 7, 13}, {3, 8, 12}, {3, 9, 11}, {3, 10, 10}, {3, 11, 9}, {3, 12, 8}, {3, 13, 7}, {3, 14, 6}, {3, 15, 5}, {3, 16, 4}, {3, 17, 3}, {3, 18, 2}, {3, 19, 1}, {3, 20, 0}, {4, 1, 18}, {4, 2, 17}, {4, 3, 16}, {4, 4, 15}, {4, 5, 14}, {4, 6, 13}, {4, 7, 12}, {4, 8, 11}, {4, 9, 10}, {4, 10, 9}, {4, 11, 8}, {4, 12, 7}, {4, 13, 6}, {4, 14, 5}, {4, 15, 4}, {4, 16, 3}, {4, 17, 2}, {4, 18, 1}, {4, 19, 0}, {5, 1, 17}, {5, 2, 16}, {5, 3, 15}, {5, 4, 14}, {5, 6, 12}, {5, 7, 11}, {5, 8, 10}, {5, 9, 9}, {5, 10, 8}, {5, 11, 7}, {5, 12, 6}, {5, 13, 5}, {5, 14, 4}, {5, 15, 3}, {5, 16, 2}, {5, 17, 1}, {5, 18, 0}, {6, 1, 16}, {6, 2, 15}, {6, 3, 14}, {6, 4, 13}, {6, 5, 12}, {6, 6, 11}, {6, 7, 10}, {6, 8, 9}, {6, 9, 8}, {6, 10, 7}, {6, 11, 6}, {6, 12, 5}, {6, 13, 4}, {6, 14, 3}, {6, 15, 2}, {6, 16, 1}, {6, 17, 0}, {7, 1, 15}, {7, 2, 14}, {7, 3, 13}, {7, 4, 12}, {7, 5, 11}, {7, 6, 10}, {7, 7, 9}, {7, 8, 8}, {7, 9, 7}, {7, 10, 6}, {7, 11, 5}, {7, 12, 4}, {7, 13, 3}, {7, 14, 2}, {7, 15, 1}, {7, 16, 0}, {8, 1, 14}, {8, 2, 13}, {8, 3, 12}, {8, 4, 11}, {8, 5, 10}, {8, 6, 9}, {8, 7, 8}, {8, 8, 7}, {8, 9, 6}, {8, 10, 5}, {8, 11, 4}, {8, 12, 3}, {8, 13, 2}, {8, 14, 1}, {8, 15, 0}, {9, 1, 13}, {9, 2, 12}, {9, 3, 11}, {9, 4, 10}, {9, 5, 9}, {9, 6, 8}, {9, 7, 7}, {9, 8, 6}, {9, 9, 5}, {9, 10, 4}, {9, 11, 3}, {9, 12, 2}, {9, 13, 1}, {9, 14, 0}, {10, 1, 12}, {10, 2, 11}, {10, 3, 10}, {10, 4, 9}, {10, 5, 8}, {10, 6, 7}, {10, 7, 6}, {10, 8, 5}, {10, 9, 4}, {10, 10, 3}, {10, 11, 2}, {10, 12, 1}, {10, 13, 0}, {11, 1, 11}, {11, 2, 10}, {11, 3, 9}, {11, 4, 8}, {11, 5, 7}, {11, 6, 6}, {11, 7, 5}, {11, 8, 4}, {11, 9, 3}, {11, 10, 2}, {11, 11, 1}, {11, 12, 0}, {12, 1, 10}, {12, 2, 9}, {12, 3, 8}, {12, 4, 7}, {12, 5, 6}, {12, 6, 5}, {12, 7, 4}, {12, 8, 3}, {12, 9, 2}, {12, 10, 1}, {12, 11, 0}, {13, 1, 9}, {13, 2, 8}, {13, 3, 7}, {13, 4, 6}, {13, 5, 5}, {13, 6, 4}, {13, 7, 3}, {13, 8, 2}, {13, 9, 1}, {13, 10, 0}, {14, 1, 8}, {14, 2, 7}, {14, 3, 6}, {14, 4, 5}, {14, 5, 4}, {14, 6, 3}, {14, 7, 2}, {14, 8, 1}, {14, 9, 0}, {15, 1, 7}, {15, 2, 6}, {15, 3, 5}, {15, 4, 4}, {15, 5, 3}, {15, 6, 2}, {15, 7, 1}, {15, 8, 0}, {16, 1, 6}, {16, 2, 5}, {16, 3, 4}, {16, 4, 3}, {16, 5, 2}, {16, 6, 1}, {16, 7, 0}, {17, 1, 5}, {17, 2, 4}, {17, 3, 3}, {17, 4, 2}, {17, 5, 1}, {17, 6, 0}, {18, 1, 4}, {18, 2, 3}, {18, 3, 2}, {18, 4, 1}, {18, 5, 0}, {19, 1, 3}, {19, 2, 2}, {19, 3, 1}, {19, 4, 0}, {20, 1, 2}, {20, 2, 1}, {20, 3, 0}, {21, 1, 1}, {21, 2, 0}, {22, 1, 0}, {23, 0, 0} },
    { {1, 1, 22}, {1, 2, 21}, {5, 5, 14}, {1, 3, 20}, {1, 4, 19}, {1, 5, 18}, {1, 6, 17}, {1, 7, 16}, {1, 8, 15}, {1, 9, 14}, {1, 10, 13}, {1, 11, 12}, {1, 12, 11}, {1, 13, 10}, {1, 14, 9}, {1, 15, 8}, {1, 16, 7}, {1, 17, 6}, {1, 18, 5}, {1, 19, 4}, {1, 20, 3}, {1, 21, 2}, {1, 22, 1}, {1, 23, 0}, {2, 1, 21}, {2, 2, 20}, {2, 3, 19}, {2, 4, 18}, {2, 5, 17}, {2, 6, 16}, {2, 7, 15}, {2, 8, 14}, {2, 9, 13}, {2, 10, 12}, {2, 11, 11}, {2, 12, 10}, {2, 13, 9}, {2, 14, 8}, {2, 15, 7}, {2, 16, 6}, {2, 17, 5}, {2, 18, 4}, {2, 19, 3}, {2, 20, 2}, {2, 21, 1}, {2, 22, 0}, {3, 1, 20}, {3, 2, 19}, {3, 3, 18}, {3, 4, 17}, {3, 5, 16}, {3, 6, 15}, {3, 7, 14}, {3, 8, 13}, {3, 9, 12}, {3, 10, 11}, {3, 11, 10}, {3, 12, 9}, {3, 13, 8}, {3, 14, 7}, {3, 15, 6}, {3, 16, 5}, {3, 17, 4}, {3, 18, 3}, {3, 19, 2}, {3, 20, 1}, {3, 21, 0}, {4, 1, 19}, {4, 2, 18}, {4, 3, 17}, {4, 4, 16}, {4, 5, 15}, {4, 6, 14}, {4, 7, 13}, {4, 8, 12}, {4, 9, 11}, {4, 10, 10}, {4, 11, 9}, {4, 12, 8}, {4, 13, 7}, {4, 14, 6}, {4, 15, 5}, {4, 16, 4}, {4, 17, 3}, {4, 18, 2}, {4, 19, 1}, {4, 20, 0}, {5, 1, 18}, {5, 2, 17}, {5, 3, 16}, {5, 4, 15}, {5, 6, 13}, {5, 7, 12}, {5, 8, 11}, {5, 9, 10}, {5, 10, 9}, {5, 11, 8}, {5, 12, 7}, {5, 13, 6}, {5, 14, 5}, {5, 15, 4}, {5, 16, 3}, {5, 17, 2}, {5, 18, 1}, {5, 19, 0}, {6, 1, 17}, {6, 2, 16}, {6, 3, 15}, {6, 4, 14}, {6, 5, 13}, {6, 6, 12}, {6, 7, 11}, {6, 8, 10}, {6, 9, 9}, {6, 10, 8}, {6, 11, 7}, {6, 12, 6}, {6, 13, 5}, {6, 14, 4}, {6, 15, 3}, {6, 16, 2}, {6, 17, 1}, {6, 18, 0}, {7, 1, 16}, {7, 2, 15}, {7, 3, 14}, {7, 4, 13}, {7, 5, 12}, {7, 6, 11}, {7, 7, 10}, {7, 8, 9}, {7, 9, 8}, {7, 10, 7}, {7, 11, 6}, {7, 12, 5}, {7, 13, 4}, {7, 14, 3}, {7, 15, 2}, {7, 16, 1}, {7, 17, 0}, {8, 1, 15}, {8, 2, 14}, {8, 3, 13}, {8, 4, 12}, {8, 5, 11}, {8, 6, 10}, {8, 7, 9}, {8, 8, 8}, {8, 9, 7}, {8, 10, 6}, {8, 11, 5}, {8, 12, 4}, {8, 13, 3}, {8, 14, 2}, {8, 15, 1}, {8, 16, 0}, {9, 1, 14}, {9, 2, 13}, {9, 3, 12}, {9, 4, 11}, {9, 5, 10}, {9, 6, 9}, {9, 7, 8}, {9, 8, 7}, {9, 9, 6}, {9, 10, 5}, {9, 11, 4}, {9, 12, 3}, {9, 13, 2}, {9, 14, 1}, {9, 15, 0}, {10, 1, 13}, {10, 2, 12}, {10, 3, 11}, {10, 4, 10}, {10, 5, 9}, {10, 6, 8}, {10, 7, 7}, {10, 8, 6}, {10, 9, 5}, {10, 10, 4}, {10, 11, 3}, {10, 12, 2}, {10, 13, 1}, {10, 14, 0}, {11, 1, 12}, {11, 2, 11}, {11, 3, 10}, {11, 4, 9}, {11, 5, 8}, {11, 6, 7}, {11, 7, 6}, {11, 8, 5}, {11, 9, 4}, {11, 10, 3}, {11, 11, 2}, {11, 12, 1}, {11, 13, 0}, {12, 1, 11}, {12, 2, 10}, {12, 3, 9}, {12, 4, 8}, {12, 5, 7}, {12, 6, 6}, {12, 7, 5}, {12, 8, 4}, {12, 9, 3}, {12, 10, 2}, {12, 11, 1}, {12, 12, 0}, {13, 1, 10}, {13, 2, 9}, {13, 3, 8}, {13, 4, 7}, {13, 5, 6}, {13, 6, 5}, {13, 7, 4}, {13, 8, 3}, {13, 9, 2}, {13, 10, 1}, {13, 11, 0}, {14, 1, 9}, {14, 2, 8}, {14, 3, 7}, {14, 4, 6}, {14, 5, 5}, {14, 6, 4}, {14, 7, 3}, {14, 8, 2}, {14, 9, 1}, {14, 10, 0}, {15, 1, 8}, {15, 2, 7}, {15, 3, 6}, {15, 4, 5}, {15, 5, 4}, {15, 6, 3}, {15, 7, 2}, {15, 8, 1}, {15, 9, 0}, {16, 1, 7}, {16, 2, 6}, {16, 3, 5}, {16, 4, 4}, {16, 5, 3}, {16, 6, 2}, {16, 7, 1}, {16, 8, 0}, {17, 1, 6}, {17, 2, 5}, {17, 3, 4}, {17, 4, 3}, {17, 5, 2}, {17, 6, 1}, {17, 7, 0}, {18, 1, 5}, {18, 2, 4}, {18, 3, 3}, {18, 4, 2}, {18, 5, 1}, {18, 6, 0}, {19, 1, 4}, {19, 2, 3}, {19, 3, 2}, {19, 4, 1}, {19, 5, 0}, {20, 1, 3}, {20, 2, 2}, {20, 3, 1}, {20, 4, 0}, {21, 1, 2}, {21, 2, 1}, {21, 3, 0}, {22, 1, 1}, {22, 2, 0}, {23, 1, 0}, {24, 0, 0} }
  };

TYPED_TEST_SUITE(ModArithTest, FTImplementations);

TYPED_TEST(ModArithTest, vectorVectorOps)
{
  const uint64_t N = 1 << rand_uint_32b(3, 17);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);

  ICICLE_LOG_DEBUG << "N = " << N;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  const int total_size = N * batch_size;
  auto in_a = std::make_unique<TypeParam[]>(total_size);
  auto in_b = std::make_unique<TypeParam[]>(total_size);
  auto out_main = std::make_unique<TypeParam[]>(total_size);
  auto out_ref = std::make_unique<TypeParam[]>(total_size);

  auto vector_accumulate_wrapper =
    [](TypeParam* a, const TypeParam* b, uint64_t size, const VecOpsConfig& config, TypeParam* /*out*/) {
      return vector_accumulate(a, b, size, config);
    };

  auto run =
    [&](const std::string& dev_type, TypeParam* out, bool measure, auto vec_op_func, const char* msg, int iters) {
      Device dev = {dev_type, 0};
      icicle_set_device(dev);
      auto config = default_vec_ops_config();
      config.batch_size = batch_size;
      config.columns_batch = columns_batch;

      std::ostringstream oss;
      oss << dev_type << " " << msg;

      START_TIMER(VECADD_sync)
      for (int i = 0; i < iters; ++i) {
        ICICLE_CHECK(vec_op_func(in_a.get(), in_b.get(), N, config, out));
      }
      END_TIMER(VECADD_sync, oss.str().c_str(), measure);
    };

  // add
  ModArithTest<TypeParam>::random_samples(in_a.get(), total_size);
  ModArithTest<TypeParam>::random_samples(in_b.get(), total_size);
  if (!IcicleTestBase::is_main_device_available()) {
    for (int i = 0; i < total_size; i++) {
      out_ref[i] = in_a[i] + in_b[i];
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, vector_add<TypeParam>, "vector add",
      ITERS);
  }
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, vector_add<TypeParam>, "vector add", ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));

  // accumulate
  ModArithTest<TypeParam>::random_samples(in_a.get(), total_size);
  ModArithTest<TypeParam>::random_samples(in_b.get(), total_size);
  for (int i = 0; i < total_size; i++) { // TODO - compare gpu against cpu with inplace operations?
    out_ref[i] = in_a[i] + in_b[i];
  }
  run(
    IcicleTestBase::main_device(), nullptr, VERBOSE /*=measure*/, vector_accumulate_wrapper, "vector accumulate",
    ITERS);

  ASSERT_EQ(0, memcmp(in_a.get(), out_ref.get(), total_size * sizeof(TypeParam)));

  // sub
  ModArithTest<TypeParam>::random_samples(in_a.get(), total_size);
  ModArithTest<TypeParam>::random_samples(in_b.get(), total_size);
  if (!IcicleTestBase::is_main_device_available()) {
    for (int i = 0; i < total_size; i++) {
      out_ref[i] = in_a[i] - in_b[i];
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, vector_sub<TypeParam>, "vector sub",
      ITERS);
  }
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, vector_sub<TypeParam>, "vector sub", ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));

  // mul
  ModArithTest<TypeParam>::random_samples(in_a.get(), total_size);
  ModArithTest<TypeParam>::random_samples(in_b.get(), total_size);
  if (!IcicleTestBase::is_main_device_available()) {
    for (int i = 0; i < total_size; i++) {
      out_ref[i] = in_a[i] * in_b[i];
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, vector_mul<TypeParam>, "vector mul",
      ITERS);
  }
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, vector_mul<TypeParam>, "vector mul", ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));
}

TYPED_TEST(ModArithTest, montgomeryConversion)
{
  const uint64_t N = 1 << rand_uint_32b(3, 17);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);
  const bool is_to_montgomery = rand_uint_32b(0, 1);
  ICICLE_LOG_DEBUG << "N = " << N;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;
  ICICLE_LOG_DEBUG << "is_to_montgomery = " << is_to_montgomery;
  const int total_size = N * batch_size;
  auto in_a = std::make_unique<TypeParam[]>(total_size);
  auto out_main = std::make_unique<TypeParam[]>(total_size);
  auto out_ref = std::make_unique<TypeParam[]>(total_size);

  auto run = [&](const std::string& dev_type, TypeParam* out, bool measure, const char* msg, int iters) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);
    auto config = default_vec_ops_config();
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(MONTGOMERY)
    for (int i = 0; i < iters; ++i) {
      ICICLE_CHECK(convert_montgomery(in_a.get(), N, is_to_montgomery, config, out));
    }
    END_TIMER(MONTGOMERY, oss.str().c_str(), measure);
  };

  // convert_montgomery
  ModArithTest<TypeParam>::random_samples(in_a.get(), total_size);
  // reference
  if (!IcicleTestBase::is_main_device_available()) {
    if (is_to_montgomery) {
      for (int i = 0; i < total_size; i++) {
        out_ref[i] = TypeParam::to_montgomery(in_a[i]);
      }
    } else {
      for (int i = 0; i < total_size; i++) {
        out_ref[i] = TypeParam::from_montgomery(in_a[i]);
      }
    }
  } else {
    run(IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, "montgomery", ITERS);
  }
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, "montgomery", ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));
}

TEST_F(ModArithTestBase, VectorReduceOps)
{
  const uint64_t N = 1 << rand_uint_32b(3, 17);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);
  const int total_size = N * batch_size;

  ICICLE_LOG_DEBUG << "N = " << N;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  auto in_a = std::make_unique<scalar_t[]>(total_size);
  auto out_main = std::make_unique<scalar_t[]>(batch_size);
  auto out_ref = std::make_unique<scalar_t[]>(batch_size);

  auto vector_accumulate_wrapper =
    [](scalar_t* a, const scalar_t* b, uint64_t size, const VecOpsConfig& config, scalar_t* /*out*/) {
      return vector_accumulate(a, b, size, config);
    };

  auto run =
    [&](const std::string& dev_type, scalar_t* out, bool measure, auto vec_op_func, const char* msg, int iters) {
      Device dev = {dev_type, 0};
      icicle_set_device(dev);
      auto config = default_vec_ops_config();
      config.batch_size = batch_size;
      config.columns_batch = columns_batch;

      std::ostringstream oss;
      oss << dev_type << " " << msg;

      START_TIMER(VECADD_sync)
      for (int i = 0; i < iters; ++i) {
        ICICLE_CHECK(vec_op_func(in_a.get(), N, config, out));
      }
      END_TIMER(VECADD_sync, oss.str().c_str(), measure);
    };

  // sum
  scalar_t::rand_host_many(in_a.get(), total_size);
  // reference
  for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
    out_ref[idx_in_batch] = scalar_t::from(0);
  }
  if (!IcicleTestBase::is_main_device_available()) {
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t idx_in_N = 0; idx_in_N < N; idx_in_N++) {
        uint64_t idx_a = columns_batch ? idx_in_N * batch_size + idx_in_batch : idx_in_batch * N + idx_in_N;
        out_ref[idx_in_batch] = out_ref[idx_in_batch] + in_a[idx_a];
      }
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, vector_sum<scalar_t>, "vector sum",
      ITERS);
  }
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, vector_sum<scalar_t>, "vector sum", ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), batch_size * sizeof(scalar_t)));

  // product
  scalar_t::rand_host_many(in_a.get(), total_size);
  if (!IcicleTestBase::is_main_device_available()) {
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      out_ref[idx_in_batch] = scalar_t::from(1);
    }
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t idx_in_N = 0; idx_in_N < N; idx_in_N++) {
        uint64_t idx_a = columns_batch ? idx_in_N * batch_size + idx_in_batch : idx_in_batch * N + idx_in_N;
        out_ref[idx_in_batch] = out_ref[idx_in_batch] * in_a[idx_a];
      }
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, vector_product<scalar_t>,
      "vector product", ITERS);
  }
  run(
    IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, vector_product<scalar_t>, "vector product",
    ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), batch_size * sizeof(scalar_t)));
}

TEST_F(ModArithTestBase, scalarVectorOps)
{
  const uint64_t N = 1 << rand_uint_32b(3, 17);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);

  ICICLE_LOG_DEBUG << "N = " << N;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  const int total_size = N * batch_size;
  auto scalar_a = std::make_unique<scalar_t[]>(batch_size);
  auto in_b = std::make_unique<scalar_t[]>(total_size);
  auto out_main = std::make_unique<scalar_t[]>(total_size);
  auto out_ref = std::make_unique<scalar_t[]>(total_size);
  ICICLE_LOG_DEBUG << "N = " << N;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  auto vector_accumulate_wrapper =
    [](scalar_t* a, const scalar_t* b, uint64_t size, const VecOpsConfig& config, scalar_t* /*out*/) {
      return vector_accumulate(a, b, size, config);
    };

  auto run =
    [&](const std::string& dev_type, scalar_t* out, bool measure, auto vec_op_func, const char* msg, int iters) {
      Device dev = {dev_type, 0};
      icicle_set_device(dev);
      auto config = default_vec_ops_config();
      config.batch_size = batch_size;
      config.columns_batch = columns_batch;

      std::ostringstream oss;
      oss << dev_type << " " << msg;

      START_TIMER(VECADD_sync)
      for (int i = 0; i < iters; ++i) {
        ICICLE_CHECK(vec_op_func(scalar_a.get(), in_b.get(), N, config, out));
      }
      END_TIMER(VECADD_sync, oss.str().c_str(), measure);
    };

  // scalar add vec
  scalar_t::rand_host_many(scalar_a.get(), batch_size);
  scalar_t::rand_host_many(in_b.get(), total_size);

  // reference
  if (!IcicleTestBase::is_main_device_available()) {
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t idx_in_N = 0; idx_in_N < N; idx_in_N++) {
        uint64_t idx_b = columns_batch ? idx_in_N * batch_size + idx_in_batch : idx_in_batch * N + idx_in_N;
        out_ref[idx_b] = (scalar_a[idx_in_batch]) + in_b[idx_b];
      }
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, scalar_add_vec<scalar_t>,
      "scalar add vec", ITERS);
  }
  run(
    IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, scalar_add_vec<scalar_t>, "scalar add vec",
    ITERS);

  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(scalar_t)));

  // scalar sub vec
  scalar_t::rand_host_many(scalar_a.get(), batch_size);
  scalar_t::rand_host_many(in_b.get(), total_size);

  if (!IcicleTestBase::is_main_device_available()) {
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t idx_in_N = 0; idx_in_N < N; idx_in_N++) {
        uint64_t idx_b = columns_batch ? idx_in_N * batch_size + idx_in_batch : idx_in_batch * N + idx_in_N;
        out_ref[idx_b] = (scalar_a[idx_in_batch]) - in_b[idx_b];
      }
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, scalar_sub_vec<scalar_t>,
      "scalar sub vec", ITERS);
  }

  run(
    IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, scalar_sub_vec<scalar_t>, "scalar sub vec",
    ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(scalar_t)));

  // scalar mul vec
  scalar_t::rand_host_many(scalar_a.get(), batch_size);
  scalar_t::rand_host_many(in_b.get(), total_size);

  if (!IcicleTestBase::is_main_device_available()) {
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t idx_in_N = 0; idx_in_N < N; idx_in_N++) {
        uint64_t idx_b = columns_batch ? idx_in_N * batch_size + idx_in_batch : idx_in_batch * N + idx_in_N;
        out_ref[idx_b] = (scalar_a[idx_in_batch]) * in_b[idx_b];
      }
    }
  } else {
    run(
      IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, scalar_mul_vec<scalar_t>,
      "scalar mul vec", ITERS);
  }
  run(
    IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, scalar_mul_vec<scalar_t>, "scalar mul vec",
    ITERS);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(scalar_t)));
}

TYPED_TEST(ModArithTest, matrixAPIsAsync)
{
  const int R = 1 << rand_uint_32b(2, 9);
  const int C = 1 << rand_uint_32b(2, 9);
  const int batch_size = 1 << rand_uint_32b(0, 3);
  const bool columns_batch = rand_uint_32b(0, 1);
  const bool is_in_place = IcicleTestBase::is_main_device_available() ? 0 : rand_uint_32b(0, 1);

  ICICLE_LOG_DEBUG << "rows = " << R;
  ICICLE_LOG_DEBUG << "cols = " << C;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  const int total_size = R * C * batch_size;
  auto h_inout = std::make_unique<TypeParam[]>(total_size);
  auto h_out_main = std::make_unique<TypeParam[]>(total_size);
  auto h_out_ref = std::make_unique<TypeParam[]>(total_size);

  auto run = [&](const std::string& dev_type, TypeParam* h_out, bool measure, const char* msg, int iters) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);

    DeviceProperties device_props;
    icicle_get_device_properties(device_props);
    auto config = default_vec_ops_config();
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    // Note: if the device uses host memory, do not allocate device memory and copy

    TypeParam *d_in, *d_out;
    if (!device_props.using_host_memory) {
      icicle_create_stream(&config.stream);
      icicle_malloc_async((void**)&d_in, total_size * sizeof(TypeParam), config.stream);
      icicle_malloc_async((void**)&d_out, total_size * sizeof(TypeParam), config.stream);
      icicle_copy_to_device_async(d_in, h_inout.get(), total_size * sizeof(TypeParam), config.stream);

      config.is_a_on_device = true;
      config.is_result_on_device = true;
      config.is_async = false;
    }

    TypeParam* in = device_props.using_host_memory ? h_inout.get() : d_in;
    TypeParam* out = device_props.using_host_memory ? h_out : d_out;

    START_TIMER(TRANSPOSE)
    for (int i = 0; i < iters; ++i) {
      ICICLE_CHECK(matrix_transpose(in, R, C, config, out));
    }
    END_TIMER(TRANSPOSE, oss.str().c_str(), measure);

    if (!device_props.using_host_memory) {
      icicle_copy_to_host_async(h_out, d_out, total_size * sizeof(TypeParam), config.stream);
      icicle_stream_synchronize(config.stream);
      icicle_free_async(d_in, config.stream);
      icicle_free_async(d_out, config.stream);
    }
  };

  TypeParam::rand_host_many(h_inout.get(), total_size);

  // Reference implementation
  if (!IcicleTestBase::is_main_device_available()) {
    const TypeParam* cur_mat_in = h_inout.get();
    TypeParam* cur_mat_out = h_out_ref.get();
    uint32_t stride = columns_batch ? batch_size : 1;
    const uint64_t total_elements_one_mat = static_cast<uint64_t>(R) * C;
    for (uint32_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      // Perform the matrix transpose
      for (uint32_t i = 0; i < R; ++i) {
        for (uint32_t j = 0; j < C; ++j) {
          cur_mat_out[stride * (j * R + i)] = cur_mat_in[stride * (i * C + j)];
        }
      }
      cur_mat_in += (columns_batch ? 1 : total_elements_one_mat);
      cur_mat_out += (columns_batch ? 1 : total_elements_one_mat);
    }
  } else {
    run(
      IcicleTestBase::reference_device(), (is_in_place ? h_inout.get() : h_out_ref.get()), VERBOSE /*=measure*/,
      "transpose", ITERS);
  }

  run(
    IcicleTestBase::main_device(), (is_in_place ? h_inout.get() : h_out_main.get()), VERBOSE /*=measure*/, "transpose",
    ITERS);

  if (is_in_place) {
    ASSERT_EQ(0, memcmp(h_inout.get(), h_out_ref.get(), total_size * sizeof(TypeParam)));
  } else {
    ASSERT_EQ(0, memcmp(h_out_main.get(), h_out_ref.get(), total_size * sizeof(TypeParam)));
  }
}

TYPED_TEST(ModArithTest, bitReverse)
{
  const uint64_t N = 1 << rand_uint_32b(3, 17);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);
  const bool is_in_place = rand_uint_32b(0, 1);
  const int total_size = N * batch_size;

  ICICLE_LOG_DEBUG << "N = " << N;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;
  ICICLE_LOG_DEBUG << "is_in_place = " << is_in_place;

  auto in_a = std::make_unique<TypeParam[]>(total_size);
  auto out_main = std::make_unique<TypeParam[]>(total_size);
  auto out_ref = std::make_unique<TypeParam[]>(total_size);

  auto run = [&](const std::string& dev_type, TypeParam* out, bool measure, const char* msg, int iters) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);
    auto config = default_vec_ops_config();
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(BIT_REVERSE)
    for (int i = 0; i < iters; ++i) {
      ICICLE_CHECK(bit_reverse(in_a.get(), N, config, out));
    }
    END_TIMER(BIT_REVERSE, oss.str().c_str(), measure);
  };

  ModArithTest<TypeParam>::random_samples(in_a.get(), total_size);

  // Reference implementation
  if (!IcicleTestBase::is_main_device_available() || is_in_place) {
    uint64_t logn = 0;
    uint64_t temp = N;
    while (temp > 1) {
      temp >>= 1;
      logn++;
    }
    // BIT REVERSE FUNCTION
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t i = 0; i < N; i++) {
        int rev = 0;
        for (int j = 0; j < logn; ++j) {
          if (i & (1 << j)) { rev |= 1 << (logn - 1 - j); }
        }
        if (columns_batch) {
          out_ref[idx_in_batch + batch_size * i] = in_a[idx_in_batch + batch_size * rev];
        } else {
          out_ref[idx_in_batch * N + i] = in_a[idx_in_batch * N + rev];
        }
      }
    }
  } else {
    run(
      IcicleTestBase::reference_device(), (is_in_place ? in_a.get() : out_ref.get()), VERBOSE /*=measure*/,
      "bit-reverse", 1);
  }
  run(
    IcicleTestBase::main_device(), (is_in_place ? in_a.get() : out_main.get()), VERBOSE /*=measure*/, "bit-reverse", 1);

  if (is_in_place) {
    ASSERT_EQ(0, memcmp(in_a.get(), out_ref.get(), N * sizeof(TypeParam)));
  } else {
    ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));
  }
}

TYPED_TEST(ModArithTest, Slice)
{
  const uint64_t size_in = 1 << rand_uint_32b(4, 17);
  const uint64_t offset = rand_uint_32b(0, 14);
  const uint64_t stride = rand_uint_32b(1, 4);
  const uint64_t size_out = rand_uint_32b(1, std::max<uint64_t>((size_in - offset) / stride, 1));
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);

  ICICLE_LOG_DEBUG << "size_in = " << size_in;
  ICICLE_LOG_DEBUG << "size_out = " << size_out;
  ICICLE_LOG_DEBUG << "offset = " << offset;
  ICICLE_LOG_DEBUG << "stride = " << stride;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  const int total_size_in = size_in * batch_size;
  const int total_size_out = size_out * batch_size;

  auto in_a = std::make_unique<TypeParam[]>(total_size_in);
  auto out_main = std::make_unique<TypeParam[]>(total_size_out);
  auto out_ref = std::make_unique<TypeParam[]>(total_size_out);

  TypeParam::rand_host_many(in_a.get(), total_size_in);

  auto run = [&](const std::string& dev_type, TypeParam* out, bool measure, const char* msg, int iters) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);
    auto config = default_vec_ops_config();
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(SLICE)
    for (int i = 0; i < iters; ++i) {
      ICICLE_CHECK(slice(in_a.get(), offset, stride, size_in, size_out, config, out));
    }
    END_TIMER(SLICE, oss.str().c_str(), measure);
  };

  // Reference implementation
  if (!IcicleTestBase::is_main_device_available()) {
    for (uint64_t idx_in_batch = 0; idx_in_batch < batch_size; idx_in_batch++) {
      for (uint64_t i = 0; i < size_out; i++) {
        if (columns_batch) {
          out_ref[idx_in_batch + batch_size * i] = in_a[idx_in_batch + batch_size * (offset + i * stride)];
        } else {
          out_ref[idx_in_batch * size_out + i] = in_a[idx_in_batch * size_in + (offset + i * stride)];
        }
      }
    }
  } else {
    run(IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, "slice", 1);
  }
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, "slice", 1);

  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size_out * sizeof(TypeParam)));
}

TEST_F(ModArithTestBase, highestNonZeroIdx)
{
  const uint64_t N = 1 << rand_uint_32b(3, 17);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);
  const int total_size = N * batch_size;

  auto in_a = std::make_unique<scalar_t[]>(total_size);
  for (int i = 0; i < batch_size; ++i) {
    // randomize different rows with zeros in the end
    auto size = std::max(int64_t(N) / 4 - i, int64_t(1));
    scalar_t::rand_host_many(in_a.get() + i * N, size);
  }
  auto out_main = std::make_unique<int64_t[]>(batch_size);
  auto out_ref = std::make_unique<int64_t[]>(batch_size);

  auto run = [&](const std::string& dev_type, int64_t* out, bool measure, const char* msg, int iters) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);
    auto config = default_vec_ops_config();
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(highestNonZeroIdx)
    for (int i = 0; i < iters; ++i) {
      ICICLE_CHECK(highest_non_zero_idx(in_a.get(), N, config, out));
    }
    END_TIMER(highestNonZeroIdx, oss.str().c_str(), measure);
  };

  run(IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, "highest_non_zero_idx", 1);
  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, "highest_non_zero_idx", 1);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), batch_size * sizeof(int64_t)));
}

TEST_F(ModArithTestBase, polynomialEval)
{
  const uint64_t coeffs_size = 1 << rand_uint_32b(4, 13);
  const uint64_t domain_size = 1 << rand_uint_32b(2, 9);
  const int batch_size = 1 << rand_uint_32b(0, 4);
  const bool columns_batch = rand_uint_32b(0, 1);

  ICICLE_LOG_DEBUG << "coeffs_size = " << coeffs_size;
  ICICLE_LOG_DEBUG << "domain_size = " << domain_size;
  ICICLE_LOG_DEBUG << "batch_size = " << batch_size;
  ICICLE_LOG_DEBUG << "columns_batch = " << columns_batch;

  const int total_coeffs_size = coeffs_size * batch_size;
  const int total_result_size = domain_size * batch_size;

  auto in_coeffs = std::make_unique<scalar_t[]>(total_coeffs_size);
  auto in_domain = std::make_unique<scalar_t[]>(domain_size);
  auto out_main = std::make_unique<scalar_t[]>(total_result_size);
  auto out_ref = std::make_unique<scalar_t[]>(total_result_size);

  auto run = [&](const std::string& dev_type, scalar_t* out, bool measure, const char* msg, int iters) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);
    auto config = default_vec_ops_config();
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(polynomialEval)
    for (int i = 0; i < iters; ++i) {
      ICICLE_CHECK(polynomial_eval(in_coeffs.get(), coeffs_size, in_domain.get(), domain_size, config, out));
    }
    END_TIMER(polynomialEval, oss.str().c_str(), measure);
  };

  scalar_t::rand_host_many(in_coeffs.get(), total_coeffs_size);
  scalar_t::rand_host_many(in_domain.get(), domain_size);

  run(IcicleTestBase::main_device(), out_main.get(), VERBOSE /*=measure*/, "polynomial_eval", 1);
  run(IcicleTestBase::reference_device(), out_ref.get(), VERBOSE /*=measure*/, "polynomial_eval", 1);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_result_size * sizeof(scalar_t)));
}

// #ifdef NTT

TYPED_TEST(ModArithTest, ntt)
{
  #ifdef RING
  // For rings, twiddles are the ring type, direct or RNS (== TypeParam)
  using TwiddleType = TypeParam;
  #else
  // For fields and extensions fields, twiddles are the base fields (== scalar_t)
  using TwiddleType = scalar_t;
  #endif

  // Randomize configuration
  const int logn = rand_uint_32b(0, 17);
  const int log_ntt_domain_size = logn + 2;
  const bool inplace = rand_uint_32b(0, 1);

  const uint64_t N = 1 << logn;
  const int log_batch_size = rand_uint_32b(0, 2);
  bool columns_batch = (logn == 7 || logn < 4) ? false : rand_uint_32b(0, 1); // cases logn=4,7 not supported in CUDA
  const int batch_size = 1 << log_batch_size;
  const int total_size = N * batch_size;

  const NTTDir dir = static_cast<NTTDir>(rand_uint_32b(0, 1)); // 0: forward, 1: inverse
  const int ordering = rand_uint_32b(0, 3);
  const int log_coset_stride = rand_uint_32b(0, 2);

  TwiddleType coset_gen = log_coset_stride ? TwiddleType::omega(logn + log_coset_stride) : TwiddleType::one();

  ICICLE_LOG_DEBUG << "N = " << N << ", batch_size = " << batch_size << ", columns_batch = " << columns_batch
                   << ", inplace = " << inplace << ", ordering = " << ordering
                   << ", log_coset_stride = " << log_coset_stride;

  auto scalars = std::make_unique<TypeParam[]>(total_size);
  TypeParam::rand_host_many(scalars.get(), total_size);

  auto out_main = std::make_unique<TypeParam[]>(total_size);
  auto out_ref = std::make_unique<TypeParam[]>(total_size);
  auto run = [&](const std::string& dev_type, TypeParam* out, const char* msg, bool measure) {
    // set device
    ICICLE_CHECK(icicle_set_device(dev_type));
    std::ostringstream oss;
    oss << dev_type << " " << msg;

    // init domain
    auto init_domain_config = default_ntt_init_domain_config();
    ConfigExtension ext;
    ext.set(CudaBackendConfig::CUDA_NTT_FAST_TWIDDLES_MODE, true);
    init_domain_config.ext = &ext;
    ICICLE_CHECK(ntt_init_domain(TwiddleType::omega(log_ntt_domain_size), init_domain_config));

    // allocate and copy to device
    TypeParam *d_in, *d_out;
    ICICLE_CHECK(icicle_malloc((void**)&d_in, total_size * sizeof(TypeParam)));
    ICICLE_CHECK(icicle_malloc((void**)&d_out, total_size * sizeof(TypeParam)));
    ICICLE_CHECK(icicle_copy_to_device(d_in, scalars.get(), total_size * sizeof(TypeParam)));

    // ntt
    auto config = default_ntt_config<TwiddleType>();
    config.coset_gen = coset_gen;
    config.batch_size = batch_size;
    config.columns_batch = columns_batch;
    config.ordering = static_cast<Ordering>(ordering);
    config.are_inputs_on_device = true;
    config.are_outputs_on_device = true;

    START_TIMER(NTT_sync)
    ICICLE_CHECK(ntt(d_in, N, dir, config, inplace ? d_in : d_out));
    END_TIMER(NTT_sync, oss.str().c_str(), measure);

    // Copy back result and release device memory
    ICICLE_CHECK(icicle_copy_to_host(out, inplace ? d_in : d_out, total_size * sizeof(TypeParam)));
    ICICLE_CHECK(icicle_free(d_in));
    ICICLE_CHECK(icicle_free(d_out));

    // release domain
    ICICLE_CHECK(ntt_release_domain<TwiddleType>());
  };

  run(IcicleTestBase::main_device(), out_main.get(), "ntt", false /*=measure*/); // warmup
  run(IcicleTestBase::reference_device(), out_ref.get(), "ntt", VERBOSE /*=measure*/);
  run(IcicleTestBase::main_device(), out_main.get(), "ntt", VERBOSE /*=measure*/);
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));
}

TYPED_TEST(ModArithTest, ntt_decision_tree)
{
  #ifdef RING
  // For rings, twiddles are the ring type, direct or RNS (== TypeParam)
  using TwiddleType = TypeParam;
  #else
  // For fields and extensions fields, twiddles are the base fields (== scalar_t)
  using TwiddleType = scalar_t;
  #endif

  // Randomize configuration
  const int min_log_cores = 0;
  const int max_log_cores = std::log2(std::thread::hardware_concurrency());
  const int logn_min = 6;
  const int logn_max = 24;
  const int iters = 5;
  const int N_max = (1 << logn_max);
  
  
  
  const bool inplace = 0;
  const int log_batch_size = 0;
  bool columns_batch = false;
  const int batch_size = 1 << log_batch_size;
  
  const NTTDir dir = static_cast<NTTDir>(0); // 0: forward, 1: inverse
  const int ordering = 0;
  const int log_coset_stride = 0;
  
  TwiddleType coset_gen = TwiddleType::one();
  
  std::ofstream result_table("result_table.txt");
  std::ofstream result_detailed("result_detailed.txt");
  result_table << "x";

  for (int log_cores = min_log_cores; log_cores <= max_log_cores; log_cores++){
    int n_cores = (1 << log_cores);
    result_table << ", " << n_cores;
    result_table << std::endl;
  }
  for (int logn = logn_min; logn <= logn_max; logn++){
    result_table << logn;
    double best_n_core_time = 0;
    int best_n_cores = 0;
    for (int log_cores = min_log_cores; log_cores <= max_log_cores; log_cores++){
      int n_cores = (1 << log_cores);
      double best_time = 0;
      uint32_t best_devision = 0;
      uint32_t cur_n_best_layers_sub_logn[3];

      const uint64_t N = 1 << logn;
      const int total_size = N * batch_size;
      auto scalars = std::make_unique<TypeParam[]>(total_size);
      TypeParam::rand_host_many(scalars.get(), total_size);

      auto out_main = std::make_unique<TypeParam[]>(total_size);
      auto out_ref = std::make_unique<TypeParam[]>(total_size);

      ICICLE_LOG_DEBUG << "n_cores = "<< n_cores << "N = " << N << ", batch_size = " << batch_size << ", columns_batch = " << columns_batch
      << ", inplace = " << inplace << ", ordering = " << ordering
      << ", log_coset_stride = " << log_coset_stride;

      auto run = [&](const std::string& dev_type, TypeParam* out, const char* msg, bool measure) {
        // set device
        Device dev = {dev_type, 0};
        ICICLE_CHECK(icicle_set_device(dev));
        std::ostringstream oss;
        oss << dev_type << " " << msg;
        // init domain
        
        auto init_domain_config = default_ntt_init_domain_config();
        ICICLE_CHECK(ntt_init_domain(TwiddleType::omega(logn), init_domain_config));

        // allocate and copy to device
        TypeParam *d_in, *d_out;
        ICICLE_CHECK(icicle_malloc((void**)&d_in, total_size * sizeof(TypeParam)));
        ICICLE_CHECK(icicle_malloc((void**)&d_out, total_size * sizeof(TypeParam)));
        ICICLE_CHECK(icicle_copy_to_device(d_in, scalars.get(), total_size * sizeof(TypeParam)));

        // ntt
        auto config = default_ntt_config<TwiddleType>();
        config.coset_gen = coset_gen;
        config.batch_size = batch_size;
        config.columns_batch = columns_batch;
        config.ordering = static_cast<Ordering>(ordering);
        config.are_inputs_on_device = true;
        config.are_outputs_on_device = true;

        for (uint32_t division = 0; division < layers_sub_logn_nof_devisions[logn]; division++){
          // config.layers_sub_logn = layers_sub_logn[logn][division];
          config.layers_sub_logn[0] = layers_sub_logn[logn][division][0];
          config.layers_sub_logn[1] = layers_sub_logn[logn][division][1];
          config.layers_sub_logn[2] = layers_sub_logn[logn][division][2];

          result_detailed << "logN = " << logn << ", n_cores = " << n_cores << ", division = " << division;
          double accumulated_time = 0;
          for (int i = 0; i < iters; ++i) {
            std::ostringstream oss;
            oss << "logN = " << logn << ", n_cores = " << n_cores << ", division = " << division << ", Iter = " << i;
            START_TIMER(NTT_sync)
            ICICLE_CHECK(ntt(d_in, N, dir, config, inplace ? d_in : d_out));
            double elapsed = FpMiliseconds(std::chrono::high_resolution_clock::now() - NTT_sync_start).count();
            END_TIMER(NTT_sync, oss.str().c_str(), measure);
            result_detailed << ", " << elapsed;
            accumulated_time += elapsed;
          }
          auto cur_avg = accumulated_time/iters;
          result_detailed << " ==> avg = " << cur_avg;
          if (division == 0 || best_time > cur_avg) {
            best_devision = division;
            best_time = cur_avg;
            result_detailed << " - ";
          }
          result_detailed << std::endl;
        }
        result_detailed << "---------------------------" << std::endl;
        result_table << ", " << best_devision << "(" << best_devision<< ")";
        if (best_n_cores == 0 || best_n_core_time > best_time) {
          best_n_cores = n_cores;
          best_n_core_time = best_time;
        }
        else {
          result_table << "*";
        }
        if (best_devision == 2) {
          result_table << "!";
        }
        
        
        // Copy back result and release device memory
        ICICLE_CHECK(icicle_copy_to_host(out, inplace ? d_in : d_out, total_size * sizeof(TypeParam)));
        ICICLE_CHECK(icicle_free(d_in));
        ICICLE_CHECK(icicle_free(d_out));
        
        // release domain
        ICICLE_CHECK(ntt_release_domain<TwiddleType>());
      };
      
      // run(IcicleTestBase::main_device(), out_main.get(), "ntt", false /*=measure*/); // warmup
      run(IcicleTestBase::reference_device(), out_ref.get(), "ntt", VERBOSE /*=measure*/);
      
      // run(IcicleTestBase::main_device(), out_main.get(), "ntt", VERBOSE /*=measure*/);
      
      // ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(TypeParam)));
    }
    result_table << std::endl;
  }
}



// #endif // NTT

// define program
using MlePoly = Symbol<scalar_t>;
void lambda_multi_result(std::vector<MlePoly>& vars)
{
  const MlePoly& A = vars[0];
  const MlePoly& B = vars[1];
  const MlePoly& C = vars[2];
  const MlePoly& EQ = vars[3];
  vars[4] = EQ * (A * B - C) + scalar_t::from(9);
  vars[5] = A * B - C.inverse();
  vars[6] = vars[5];
}

TEST_F(ModArithTestBase, CpuProgramExecutorMultiRes)
{
  scalar_t a = scalar_t::rand_host();
  scalar_t b = scalar_t::rand_host();
  scalar_t c = scalar_t::rand_host();
  scalar_t eq = scalar_t::rand_host();
  scalar_t res_0;
  scalar_t res_1;
  scalar_t res_2;

  Program<scalar_t> program(lambda_multi_result, 7);
  CpuProgramExecutor<scalar_t> prog_exe(program);

  // init program
  prog_exe.m_variable_ptrs[0] = &a;
  prog_exe.m_variable_ptrs[1] = &b;
  prog_exe.m_variable_ptrs[2] = &c;
  prog_exe.m_variable_ptrs[3] = &eq;
  prog_exe.m_variable_ptrs[4] = &res_0;
  prog_exe.m_variable_ptrs[5] = &res_1;
  prog_exe.m_variable_ptrs[6] = &res_2;

  // execute
  prog_exe.execute();

  // check correctness
  scalar_t expected_res_0 = eq * (a * b - c) + scalar_t::from(9);
  ASSERT_EQ(res_0, expected_res_0);

  scalar_t expected_res_1 = a * b - scalar_t::inverse(c);
  ASSERT_EQ(res_1, expected_res_1);
  ASSERT_EQ(res_2, res_1);
}

MlePoly returning_value_func(const std::vector<MlePoly>& inputs)
{
  const MlePoly& A = inputs[0];
  const MlePoly& B = inputs[1];
  const MlePoly& C = inputs[2];
  const MlePoly& EQ = inputs[3];
  return (EQ * (A * B - C));
}

TEST_F(ModArithTestBase, CpuProgramExecutorReturningVal)
{
  // randomize input vectors
  const int total_size = 100000;
  auto in_a = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_a.get(), total_size);
  auto in_b = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_b.get(), total_size);
  auto in_c = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_c.get(), total_size);
  auto in_eq = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_eq.get(), total_size);

  //----- element wise operation ----------------------
  auto out_element_wise = std::make_unique<scalar_t[]>(total_size);
  START_TIMER(element_wise_op)
  for (int i = 0; i < 100000; ++i) {
    out_element_wise[i] = in_eq[i] * (in_a[i] * in_b[i] - in_c[i]);
  }
  END_TIMER(element_wise_op, "Straight forward function (Element wise) time: ", true);

  //----- explicit program ----------------------
  ReturningValueProgram<scalar_t> program_explicit(returning_value_func, 4);

  CpuProgramExecutor<scalar_t> prog_exe_explicit(program_explicit);
  auto out_explicit_program = std::make_unique<scalar_t[]>(total_size);

  // init program
  prog_exe_explicit.m_variable_ptrs[0] = in_a.get();
  prog_exe_explicit.m_variable_ptrs[1] = in_b.get();
  prog_exe_explicit.m_variable_ptrs[2] = in_c.get();
  prog_exe_explicit.m_variable_ptrs[3] = in_eq.get();
  prog_exe_explicit.m_variable_ptrs[4] = out_explicit_program.get();

  // run on all vectors
  START_TIMER(explicit_program)
  for (int i = 0; i < total_size; ++i) {
    prog_exe_explicit.execute();
    (prog_exe_explicit.m_variable_ptrs[0])++;
    (prog_exe_explicit.m_variable_ptrs[1])++;
    (prog_exe_explicit.m_variable_ptrs[2])++;
    (prog_exe_explicit.m_variable_ptrs[3])++;
    (prog_exe_explicit.m_variable_ptrs[4])++;
  }
  END_TIMER(explicit_program, "Explicit program executor time: ", true);

  // check correctness
  ASSERT_EQ(0, memcmp(out_element_wise.get(), out_explicit_program.get(), total_size * sizeof(scalar_t)));

  //----- predefined program ----------------------
  Program<scalar_t> predef_program(EQ_X_AB_MINUS_C);

  CpuProgramExecutor<scalar_t> prog_exe_predef(predef_program);
  auto out_predef_program = std::make_unique<scalar_t[]>(total_size);

  // init program
  prog_exe_predef.m_variable_ptrs[0] = in_a.get();
  prog_exe_predef.m_variable_ptrs[1] = in_b.get();
  prog_exe_predef.m_variable_ptrs[2] = in_c.get();
  prog_exe_predef.m_variable_ptrs[3] = in_eq.get();
  prog_exe_predef.m_variable_ptrs[4] = out_predef_program.get();

  // run on all vectors
  START_TIMER(predef_program)
  for (int i = 0; i < total_size; ++i) {
    prog_exe_predef.execute();
    (prog_exe_predef.m_variable_ptrs[0])++;
    (prog_exe_predef.m_variable_ptrs[1])++;
    (prog_exe_predef.m_variable_ptrs[2])++;
    (prog_exe_predef.m_variable_ptrs[3])++;
    (prog_exe_predef.m_variable_ptrs[4])++;
  }
  END_TIMER(predef_program, "Program predefined time: ", true);

  // check correctness
  ASSERT_EQ(0, memcmp(out_element_wise.get(), out_predef_program.get(), total_size * sizeof(scalar_t)));

  //----- Vecops operation ----------------------
  auto config = default_vec_ops_config();
  auto out_vec_ops = std::make_unique<scalar_t[]>(total_size);

  START_TIMER(vecop)
  vector_mul(in_a.get(), in_b.get(), total_size, config, out_vec_ops.get());         // A * B
  vector_sub(out_vec_ops.get(), in_c.get(), total_size, config, out_vec_ops.get());  // A * B - C
  vector_mul(out_vec_ops.get(), in_eq.get(), total_size, config, out_vec_ops.get()); // EQ * (A * B - C)
  END_TIMER(vecop, "Vec ops time: ", true);

  // check correctness
  ASSERT_EQ(0, memcmp(out_element_wise.get(), out_vec_ops.get(), total_size * sizeof(scalar_t)));
}

MlePoly ex_x_ab_minus_c_func(const std::vector<MlePoly>& inputs)
{
  const MlePoly& A = inputs[0];
  const MlePoly& B = inputs[1];
  const MlePoly& C = inputs[2];
  const MlePoly& EQ = inputs[3];
  return EQ * (A * B - C);
}

TEST_F(ModArithTestBase, ProgramExecutorVecOp)
{
  // randomize input vectors
  const int total_size = 100000;
  const ReturningValueProgram<scalar_t> prog(ex_x_ab_minus_c_func, 4);
  auto in_a = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_a.get(), total_size);
  auto in_b = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_b.get(), total_size);
  auto in_c = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_c.get(), total_size);
  auto in_eq = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_eq.get(), total_size);

  auto run = [&](
               const std::string& dev_type, std::vector<scalar_t*>& data, const Program<scalar_t>& program,
               uint64_t size, const char* msg) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);
    auto config = default_vec_ops_config();

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(executeProgram)
    ICICLE_CHECK(execute_program(data, program, size, config));
    END_TIMER(executeProgram, oss.str().c_str(), true);
  };

  // initialize data vector for main device
  auto out_main = std::make_unique<scalar_t[]>(total_size);
  std::vector<scalar_t*> data_main = std::vector<scalar_t*>(5);
  data_main[0] = in_a.get();
  data_main[1] = in_b.get();
  data_main[2] = in_c.get();
  data_main[3] = in_eq.get();
  data_main[4] = out_main.get();

  // initialize data vector for reference device
  auto out_ref = std::make_unique<scalar_t[]>(total_size);
  std::vector<scalar_t*> data_ref = std::vector<scalar_t*>(5);
  data_ref[0] = in_a.get();
  data_ref[1] = in_b.get();
  data_ref[2] = in_c.get();
  data_ref[3] = in_eq.get();
  data_ref[4] = out_ref.get();

  // run on both devices and compare
  run(IcicleTestBase::main_device(), data_main, prog, total_size, "execute_program");
  run(IcicleTestBase::reference_device(), data_ref, prog, total_size, "execute_program");
  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(scalar_t)));
}

TEST_F(ModArithTestBase, ProgramExecutorVecOpDataOnDevice)
{
  // randomize input vectors
  const int total_size = 100000;
  const int num_of_params = 5;
  const ReturningValueProgram<scalar_t> prog(ex_x_ab_minus_c_func, num_of_params - 1);
  auto in_a = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_a.get(), total_size);
  auto in_b = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_b.get(), total_size);
  auto in_c = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_c.get(), total_size);
  auto in_eq = std::make_unique<scalar_t[]>(total_size);
  scalar_t::rand_host_many(in_eq.get(), total_size);

  auto run = [&](
               const std::string& dev_type, std::vector<scalar_t*>& data, const Program<scalar_t>& program,
               uint64_t size, VecOpsConfig config, const char* msg) {
    Device dev = {dev_type, 0};
    icicle_set_device(dev);

    std::ostringstream oss;
    oss << dev_type << " " << msg;

    START_TIMER(executeProgram)
    ICICLE_CHECK(execute_program(data, program, size, config));
    END_TIMER(executeProgram, oss.str().c_str(), true);
  };

  // initialize data vector for main device
  auto out_main = std::make_unique<scalar_t[]>(total_size);
  std::vector<scalar_t*> data_main = std::vector<scalar_t*>(num_of_params);
  data_main[0] = in_a.get();
  data_main[1] = in_b.get();
  data_main[2] = in_c.get();
  data_main[3] = in_eq.get();
  data_main[4] = out_main.get();

  // initialize data vector for reference device
  auto out_ref = std::make_unique<scalar_t[]>(total_size);
  std::vector<scalar_t*> data_ref = std::vector<scalar_t*>(num_of_params);
  data_ref[0] = in_a.get();
  data_ref[1] = in_b.get();
  data_ref[2] = in_c.get();
  data_ref[3] = in_eq.get();
  data_ref[4] = out_ref.get();

  auto config = default_vec_ops_config();
  config.is_a_on_device = 1;

  // run on both devices and compare
  run(IcicleTestBase::reference_device(), data_ref, prog, total_size, config, "execute_program");

  icicle_set_device(IcicleTestBase::main_device());

  if (config.is_a_on_device) {
    for (int idx = 0; idx < num_of_params; ++idx) {
      scalar_t* tmp = nullptr;
      icicle_malloc((void**)&tmp, total_size * sizeof(scalar_t));
      icicle_copy_to_device(tmp, data_main[idx], total_size * sizeof(scalar_t));
      data_main[idx] = tmp;
    }
  }

  run(IcicleTestBase::main_device(), data_main, prog, total_size, config, "execute_program");

  if (config.is_a_on_device)
    icicle_copy_to_host(out_main.get(), data_main[num_of_params - 1], total_size * sizeof(scalar_t));

  ASSERT_EQ(0, memcmp(out_main.get(), out_ref.get(), total_size * sizeof(scalar_t)));
}

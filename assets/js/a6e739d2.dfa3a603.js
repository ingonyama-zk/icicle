"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[41004],{81150:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"start/integration-&-support/migrate_from_v3","title":"Migration from ICICLE v3 to v4","description":"ICICLE v4 introduces a more intuitive and object-oriented C++ API for field elements, making code more readable and maintainable. This guide will assist you in transitioning from ICICLE v3 to v4 by highlighting the key changes and providing examples for both C++ and Rust.","source":"@site/versioned_docs/version-4.0.0/start/integration-&-support/migrate_from_v3.md","sourceDirName":"start/integration-&-support","slug":"/start/integration-&-support/migrate_from_v3","permalink":"/start/integration-&-support/migrate_from_v3","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-4.0.0/start/integration-&-support/migrate_from_v3.md","tags":[],"version":"4.0.0","lastUpdatedAt":1752654507000,"frontMatter":{},"sidebar":"GettingStartedSidebar","previous":{"title":"Migration from ICICLE v2 to v3","permalink":"/start/integration-&-support/migrate_from_v2"},"next":{"title":"Benchmarks","permalink":"/start/integration-&-support/benchmarks"}}');var s=n(74848),d=n(28453);const t={},l="Migration from ICICLE v3 to v4",c={},a=[{value:"Key Conceptual Changes",id:"key-conceptual-changes",level:2},{value:"Migration Guide for C++",id:"migration-guide-for-c",level:2},{value:"Replacing Static Method Calls with Instance Methods",id:"replacing-static-method-calls-with-instance-methods",level:3},{value:"Field Arithmetic Operations",id:"field-arithmetic-operations",level:4},{value:"Montgomery Conversion",id:"montgomery-conversion",level:4},{value:"Example Migration",id:"example-migration",level:3},{value:"Migration Guide for Rust",id:"migration-guide-for-rust",level:2},{value:"Arithmetic API",id:"arithmetic-api",level:3},{value:"Field Arithmetic Operations",id:"field-arithmetic-operations-1",level:4},{value:"The Arithmetic Trait",id:"the-arithmetic-trait",level:4},{value:"Deprecation of the <code>FieldImpl</code> Trait",id:"deprecation-of-the-fieldimpl-trait",level:3},{value:"Refactor Program from Vecops to Program module",id:"refactor-program-from-vecops-to-program-module",level:3},{value:"Create program",id:"create-program",level:4},{value:"Execute program",id:"execute-program",level:4},{value:"Create returning value program",id:"create-returning-value-program",level:4},{value:"Create predefined program",id:"create-predefined-program",level:4},{value:"Imports",id:"imports",level:4},{value:"Example Migration",id:"example-migration-1",level:3},{value:"Program API Example",id:"program-api-example",level:3},{value:"Random Number Generation",id:"random-number-generation",level:3},{value:"Removal of the <code>FieldCfg</code> Trait",id:"removal-of-the-fieldcfg-trait",level:3}];function o(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"migration-from-icicle-v3-to-v4",children:"Migration from ICICLE v3 to v4"})}),"\n",(0,s.jsx)(r.p,{children:"ICICLE v4 introduces a more intuitive and object-oriented C++ API for field elements, making code more readable and maintainable. This guide will assist you in transitioning from ICICLE v3 to v4 by highlighting the key changes and providing examples for both C++ and Rust."}),"\n",(0,s.jsx)(r.h2,{id:"key-conceptual-changes",children:"Key Conceptual Changes"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Object-Oriented Field API"}),": In v3, field operations were performed using static methods on the field type (e.g., ",(0,s.jsx)(r.code,{children:"FF::sqr(a)"}),"). In v4, these operations are now instance methods on the field elements themselves (e.g., ",(0,s.jsx)(r.code,{children:"a.sqr()"}),"), making the code more natural and readable."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Method Chaining"}),": The new API supports method chaining, allowing you to write more concise and expressive code by chaining multiple operations together."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"migration-guide-for-c",children:"Migration Guide for C++"}),"\n",(0,s.jsx)(r.h3,{id:"replacing-static-method-calls-with-instance-methods",children:"Replacing Static Method Calls with Instance Methods"}),"\n",(0,s.jsx)(r.p,{children:"In ICICLE v4, static method calls on field types have been replaced with instance methods on field elements. This change makes the code more intuitive and follows object-oriented principles."}),"\n",(0,s.jsx)(r.h4,{id:"field-arithmetic-operations",children:"Field Arithmetic Operations"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"v3 (Static Methods)"}),(0,s.jsx)(r.th,{children:"v4 (Instance Methods)"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::add(a, b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a + b"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::sub(a, b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a - b"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::mul(a, b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a * b"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::sqr(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.sqr()"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::neg(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.neg()"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::inverse(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.inverse()"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::pow(a, exp)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.pow(exp)"})})]})]})]}),"\n",(0,s.jsx)(r.h4,{id:"montgomery-conversion",children:"Montgomery Conversion"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"v3 (Static Methods)"}),(0,s.jsx)(r.th,{children:"v4 (Instance Methods)"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::to_montgomery(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.to_montgomery()"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"FF::from_montgomery(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.from_montgomery()"})})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"example-migration",children:"Example Migration"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v3 (Static Methods):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"FF a = FF::from(5);\nFF b = FF::from(10);\nFF c = FF::add(a, b);\nFF d = FF::mul(c, FF::from(2));\nFF e = FF::sqr(d);\nFF f = FF::inverse(e);\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v4 (Instance Methods):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"FF a = FF::from(5);\nFF b = FF::from(10);\nFF c = a.add(b);  // or a + b\nFF d = c.mul(FF::from(2));  // or c * FF::from(2)\nFF e = d.sqr();\nFF f = e.inverse();\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v4 (Method Chaining):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:"FF result = FF::from(5)\n    .add(FF::from(10))\n    .mul(FF::from(2))\n    .sqr()\n    .inverse();\n"})}),"\n",(0,s.jsx)(r.h2,{id:"migration-guide-for-rust",children:"Migration Guide for Rust"}),"\n",(0,s.jsx)(r.h3,{id:"arithmetic-api",children:"Arithmetic API"}),"\n",(0,s.jsxs)(r.p,{children:["ICICLE v4 implements field arithmetic operations through the ",(0,s.jsx)(r.code,{children:"Arithmetic"})," trait and standard Rust operators. This makes the code more idiomatic and easier to read."]}),"\n",(0,s.jsx)(r.h4,{id:"field-arithmetic-operations-1",children:"Field Arithmetic Operations"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"(Static Methods)"}),(0,s.jsx)(r.th,{children:"(Instance Methods)"}),(0,s.jsx)(r.th,{children:"(Operators)"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::add(a, b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.add(b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a + b"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::sub(a, b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.sub(b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a - b"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::mul(a, b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.mul(b)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a * b"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::sqr(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.sqr()"})}),(0,s.jsx)(r.td,{children:"N/A"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::neg(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.neg()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"-a"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::inv(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.inv()"})}),(0,s.jsx)(r.td,{children:"N/A"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Fr::pow(a, exp)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"a.pow(exp)"})}),(0,s.jsx)(r.td,{children:"N/A"})]})]})]}),"\n",(0,s.jsx)(r.h4,{id:"the-arithmetic-trait",children:"The Arithmetic Trait"}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"Arithmetic"})," trait in ICICLE v4 is defined as follows:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"pub trait Arithmetic: Sized + Add<Output = Self> + Sub<Output = Self> + Mul<Output = Self> {\n    fn sqr(&self) -> Self;\n    fn inv(&self) -> Self;\n    fn pow(&self, exp: usize) -> Self;\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:["This trait extends the standard Rust operators (",(0,s.jsx)(r.code,{children:"Add"}),", ",(0,s.jsx)(r.code,{children:"Sub"}),", ",(0,s.jsx)(r.code,{children:"Mul"}),") and adds specialized field operations like square, inverse, and exponentiation."]}),"\n",(0,s.jsxs)(r.h3,{id:"deprecation-of-the-fieldimpl-trait",children:["Deprecation of the ",(0,s.jsx)(r.code,{children:"FieldImpl"})," Trait"]}),"\n",(0,s.jsxs)(r.p,{children:["In ICICLE v3, generic code typically bounded field types by the heavyweight ",(0,s.jsx)(r.code,{children:"FieldImpl"})," super-trait.  It lumped together arithmetic, random generation, Montgomery helpers, device handles, and more.  While convenient, that design made API signatures noisy and hid which capabilities a function truly needed."]}),"\n",(0,s.jsxs)(r.p,{children:["With ",(0,s.jsx)(r.strong,{children:"v4"}),", ",(0,s.jsx)(r.code,{children:"FieldImpl"})," is gone.  Its functionality has been split across smaller, focused traits inside ",(0,s.jsx)(r.code,{children:"icicle_core::traits"}),":"]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"New trait"}),(0,s.jsx)(r.th,{children:"What it covers"}),(0,s.jsx)(r.th,{children:"Typical import"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Arithmetic"})}),(0,s.jsxs)(r.td,{children:["Core math + operator overloads (",(0,s.jsx)(r.code,{children:"+"}),", ",(0,s.jsx)(r.code,{children:"-"}),", ",(0,s.jsx)(r.code,{children:"*"}),", ",(0,s.jsx)(r.code,{children:"sqr"}),", ",(0,s.jsx)(r.code,{children:"inv"}),", ",(0,s.jsx)(r.code,{children:"pow"}),")"]}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"use icicle_core::traits::Arithmetic;"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"GenerateRandom"})}),(0,s.jsxs)(r.td,{children:["Host-side sampling (",(0,s.jsx)(r.code,{children:"generate_random"}),")"]}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"use icicle_core::traits::GenerateRandom;"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"MontgomeryConvertible"})}),(0,s.jsx)(r.td,{children:"Batch Montgomery \u21c4 canonical conversion for host/device slices"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"use icicle_core::traits::MontgomeryConvertible;"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Handle"})}),(0,s.jsx)(r.td,{children:"Low-level FFI pointer access"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"use icicle_core::traits::Handle;"})})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:["Because these traits are orthogonal you can now declare ",(0,s.jsx)(r.strong,{children:"precise"})," bounds.  For example:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"// v3 \u2013 required the full FieldImpl bundle\nfn scale_in_place<T: FieldImpl>(v: &mut [T], k: &T) {\n    for x in v.iter_mut() {\n        *x = *x * *k;\n    }\n}\n\n// v4 \u2013 only Arithmetic is needed\nfn scale_in_place<T: Arithmetic>(v: &mut [T], k: &T) {\n    for x in v.iter_mut() {\n        *x = *x * *k;\n    }\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:["If you still see ",(0,s.jsx)(r.code,{children:"FieldImpl"})," in your codebase, replace it with the minimal set of new traits your algorithm actually requires (most commonly ",(0,s.jsx)(r.code,{children:"Arithmetic"})," and perhaps ",(0,s.jsx)(r.code,{children:"GenerateRandom"}),")."]}),"\n",(0,s.jsx)(r.h3,{id:"refactor-program-from-vecops-to-program-module",children:"Refactor Program from Vecops to Program module"}),"\n",(0,s.jsx)(r.p,{children:"In v4, the Program API has been moved from VecOps to a dedicated Program module for better organization and type safety."}),"\n",(0,s.jsx)(r.h4,{id:"create-program",children:"Create program"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,s.jsx)(r.code,{children:"Fr::create_program(|symbols| { ... }, nof_params)?"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,s.jsx)(r.code,{children:"FieldProgram::new(|symbols| { ... }, nof_params)?"})]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"execute-program",children:"Execute program"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,s.jsx)(r.code,{children:"Fr::execute_program(&program, &mut vec_data, &config)?"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,s.jsx)(r.code,{children:"program.execute_program(&mut vec_data, &config)?"})]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"create-returning-value-program",children:"Create returning value program"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v4:"})," ",(0,s.jsx)(r.code,{children:"ReturningValueProgram::new(|symbols| -> symbol { ... }, nof_params)?"})]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"create-predefined-program",children:"Create predefined program"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,s.jsx)(r.code,{children:"Fr::create_predefined_program(pre_def)?"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,s.jsx)(r.code,{children:"FieldProgram::new_predefined(pre_def)?"})]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"imports",children:"Imports"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,s.jsx)(r.code,{children:"use icicle_core::vec_ops::{VecOps, VecOpsConfig};"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,s.jsx)(r.code,{children:"use icicle_core::program::{Program, ReturningValueProgram};"})]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"example-migration-1",children:"Example Migration"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v3 (Old API):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::Fr;\nuse icicle_core::traits::FieldImpl;\nuse icicle_core::field::FieldArithmetic;\n\nlet a = Fr::from_u32(5);\nlet b = Fr::from_u32(10);\nlet c = Fr::add(a, b);\nlet d = Fr::mul(c, Fr::from_u32(2));\nlet e = Fr::sqr(d);\nlet f = Fr::inv(e);\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v4 (Current API):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::ScalarField;\nuse icicle_core::traits::Arithmetic;\n\nlet a = ScalarField::from(5);\nlet b = ScalarField::from(10);\nlet c = a + b;  // or a.add(b)\nlet d = c * ScalarField::from(2);  // or c.mul(ScalarField::from(2))\nlet e = d.sqr();\nlet f = e.inv();\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v4 (Method Chaining):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::ScalarField;\nuse icicle_core::traits::Arithmetic;\n\nlet result = ScalarField::from(5)\n    .add(ScalarField::from(10))\n    .mul(ScalarField::from(2))\n    .sqr()\n    .inv();\n"})}),"\n",(0,s.jsx)(r.h3,{id:"program-api-example",children:"Program API Example"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v3 (VecOps API):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::Fr;\nuse icicle_core::vec_ops::{VecOps, VecOpsConfig};\n\n// Create program\nlet program = Fr::create_program(|symbols| {\n    // Program logic here\n}, nof_params)?;\n\n// Execute program\nFr::execute_program(&program, &mut vec_data, &config)?;\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v4 (Program API):"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::ScalarField;\nuse icicle_core::program::{Program, ReturningValueProgram};\nuse icicle_bn254::program::stark252::{FieldProgram, FieldReturningValueProgram};\n\n// Create program\nlet program = FieldProgram::new(|symbols| {\n    // Program logic here\n}, nof_params)?;\n\n// Execute program\nprogram.execute_program(&mut vec_data, &config)?;\n\n// Create returning value program\nlet returning_program = FieldReturningValueProgram::new(|symbols| -> symbol {\n    // Program logic here\n    result_symbol\n}, nof_params)?;\n"})}),"\n",(0,s.jsx)(r.h3,{id:"random-number-generation",children:"Random Number Generation"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v3:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::Fr;\nuse icicle_core::traits::FieldCfg;\n\nlet random_values = Fr::generate_random(size);\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"v4:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"use icicle_fields::bn254::ScalarField;\nuse icicle_core::traits::GenerateRandom;\n\nlet random_values = ScalarField::generate_random(size);\n"})}),"\n",(0,s.jsxs)(r.h3,{id:"removal-of-the-fieldcfg-trait",children:["Removal of the ",(0,s.jsx)(r.code,{children:"FieldCfg"})," Trait"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"FieldCfg"})," previously exposed compile-time field parameters (modulus, root, etc.) ",(0,s.jsx)(r.strong,{children:"and"})," helper functions like ",(0,s.jsx)(r.code,{children:"generate_random"}),".  In v4 these responsibilities are split:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Concrete field types now publish constants directly (e.g., ",(0,s.jsx)(r.code,{children:"ScalarField::MODULUS"}),")."]}),"\n",(0,s.jsxs)(r.li,{children:["Random sampling moved to the standalone ",(0,s.jsx)(r.code,{children:"GenerateRandom"})," trait."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Migration steps:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Replace ",(0,s.jsx)(r.code,{children:"use icicle_core::traits::FieldCfg;"})," with ",(0,s.jsx)(r.code,{children:"use icicle_core::traits::GenerateRandom;"})," when you only need random values."]}),"\n",(0,s.jsx)(r.li,{children:"Access constants directly from the field type:"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:"// v3\nlet p = <Fr as FieldCfg>::MODULUS;\n\n// v4\nlet p = ScalarField::MODULUS;\n"})}),"\n",(0,s.jsx)(r.p,{children:"All constant names are unchanged, so the update is usually a simple search-and-replace."}),"\n",(0,s.jsxs)(r.p,{children:["For further details and examples, refer to the ",(0,s.jsx)(r.a,{href:"/start/programmers_guide/general",children:"Programmer's Guide"}),"."]})]})}function h(e={}){const{wrapper:r}={...(0,d.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>l});var i=n(96540);const s={},d=i.createContext(s);function t(e){const r=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(d.Provider,{value:r},e.children)}}}]);
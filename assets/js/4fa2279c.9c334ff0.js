"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[75469],{35660:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api/rust-bindings/program","title":"Rust FFI Bindings for Program","description":"Please refer to the Program overview page for additional detail. This section is a brief description of the Rust FFI bindings.","source":"@site/versioned_docs/version-4.0.0/api/rust-bindings/program.md","sourceDirName":"api/rust-bindings","slug":"/api/rust-bindings/program","permalink":"/api/rust-bindings/program","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-4.0.0/api/rust-bindings/program.md","tags":[],"version":"4.0.0","lastUpdatedAt":1753348295000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"Vector operations","permalink":"/api/rust-bindings/vec-ops"},"next":{"title":"Polynomials","permalink":"/api/rust-bindings/polynomials"}}');var t=r(74848),o=r(28453);const a={},s="Rust FFI Bindings for Program",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"<code>Symbol</code> Trait Definition",id:"symbol-trait-definition",level:2},{value:"<code>RingSymbol</code> Struct",id:"ringsymbol-struct",level:2},{value:"Traits implemented and key methods",id:"traits-implemented-and-key-methods",level:3},{value:"Arithmetic operations",id:"arithmetic-operations",level:4},{value:"<code>ProgramImpl</code> Trait Definition",id:"programimpl-trait-definition",level:2},{value:"<code>ReturningValueProgramImpl</code> Trait Definition",id:"returningvalueprogramimpl-trait-definition",level:2},{value:"<code>Program</code> Struct",id:"program-struct",level:2},{value:"Defining a Function for Program",id:"defining-a-function-for-program",level:2},{value:"Creating a Program",id:"creating-a-program",level:2},{value:"Executing the Program",id:"executing-the-program",level:2},{value:"Examples",id:"examples",level:3},{value:"Program functionality with a custom function",id:"program-functionality-with-a-custom-function",level:4},{value:"Program functionality with predefined programs",id:"program-functionality-with-predefined-programs",level:4}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rust-ffi-bindings-for-program",children:"Rust FFI Bindings for Program"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Please refer to the ",(0,t.jsx)(n.a,{href:"/api/cpp/program",children:"Program overview"})," page for additional detail. This section is a brief description of the Rust FFI bindings."]})}),"\n",(0,t.jsx)(n.p,{children:"This documentation is designed to bring developers up to speed about the Rust API wrapping the cpp implementation of program."}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Program is a class that lets users define expressions on vector elements, and have ICICLE compile it for the backends for a fused implementation. This solves memory bottlenecks and also lets users customize algorithms such as sumcheck. Program can create only element-wise lambda functions."}),"\n",(0,t.jsxs)(n.p,{children:["The following lists the implemented Rust functionality with some examples paralleling those given in the ",(0,t.jsx)(n.a,{href:"/api/cpp/program",children:"original program overview"}),"."]}),"\n",(0,t.jsx)(n.h1,{id:"symbol",children:"Symbol"}),"\n",(0,t.jsxs)(n.p,{children:["Symbol is the basic (template) class that allows users to define their own program, representing an arithmetic operation. The ",(0,t.jsx)(n.a,{href:"#defining-a-function-for-program",children:"function"})," the user defines will operate on symbols."]}),"\n",(0,t.jsxs)(n.h2,{id:"symbol-trait-definition",children:[(0,t.jsx)(n.code,{children:"Symbol"})," Trait Definition"]}),"\n",(0,t.jsx)(n.p,{children:"The trait defines the functionality required by the user. The expected use-case of symbol is solely to be operated on to create the final arithmetic operation, which is reflected in the implemented functions and traits."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub trait Symbol<T: IntegerRing>:\n    Add<Output = Self>\n    + Sub<Output = Self>\n    + Mul<Output = Self>\n    + Add<T, Output = Self>\n    + Sub<T, Output = Self>\n    + Mul<T, Output = Self>\n    + AddAssign\n    + SubAssign\n    + MulAssign\n    + AddAssign<T>\n    + SubAssign<T>\n    + MulAssign<T>\n    + for<'a> Add<&'a Self, Output = Self>\n    + for<'a> Sub<&'a Self, Output = Self>\n    + for<'a> Mul<&'a Self, Output = Self>\n    + for<'a> AddAssign<&'a Self>\n    + for<'a> SubAssign<&'a Self>\n    + for<'a> MulAssign<&'a Self>\n    + Clone\n    + Copy\n    + Sized\n    + Handle\n{\n    fn new_input(in_idx: u32) -> Result<Self, IcicleError>; // New input symbol for the execution function\n    fn from_constant(constant: T) -> Result<Self, IcicleError>; // New symbol from a ring element\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"ringsymbol-struct",children:[(0,t.jsx)(n.code,{children:"RingSymbol"})," Struct"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RingSymbol"})," struct is implemented for each of the supported Icicle fields, providing an implementation of the above trait for each specific field. The distinction between fields is relevant for input symbols and stored constants in the program. At its core, it is simply a handle to the C++ implementation."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Despite the name, ",(0,t.jsx)(n.code,{children:"RingSymbol"})," can be instantiated for both rings and fields."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct RingSymbol {\n    m_handle: SymbolHandle,\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"traits-implemented-and-key-methods",children:"Traits implemented and key methods"}),"\n",(0,t.jsxs)(n.p,{children:["Additional traits the struct implements to fulfill ",(0,t.jsx)(n.code,{children:"Symbol<T>"})," trait that should be noted."]}),"\n",(0,t.jsx)(n.h4,{id:"arithmetic-operations",children:"Arithmetic operations"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"RingSymbol"})," implements addition, subtraction, and multiplication (as well as the assign variants of them) with other symbols/references as well as field elements. Applying the operations will generate a new symbol (or overwrite the existing in the case of the assign operation) representing the arithmetic operations of the two operand symbols."]}),"\n",(0,t.jsx)(n.h1,{id:"program",children:"Program"}),"\n",(0,t.jsxs)(n.p,{children:["A program to be run on the various Icicle backends. It can be either a user-defined program, or one of the members of ",(0,t.jsx)(n.code,{children:"PreDefinedProgram"})," enum. The program adheres to one of the following traits:"]}),"\n",(0,t.jsxs)(n.h2,{id:"programimpl-trait-definition",children:[(0,t.jsx)(n.code,{children:"ProgramImpl"})," Trait Definition"]}),"\n",(0,t.jsx)(n.p,{children:"The trait defines the base functionality required for the user, which in this case is creation and execution. It is used as a program for running a function that takes a vector of field elements (both inputs and outputs) and has no return value (output is written to the given vector). It is executed through Vector Operations."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub trait ProgramImpl<T>: Sized + Handle\nwhere\n    T: IntegerRing,\n{\n    type ProgSymbol: Symbol<T>;\n\n    fn new(program_func: impl FnOnce(&mut Vec<Self::ProgSymbol>), nof_parameters: u32) -> Result<Self, IcicleError>;\n\n    fn new_predefined(pre_def: PreDefinedProgram) -> Result<Self, IcicleError>;\n\n    fn execute_program<Data>(&self, data: &mut Vec<&Data>, cfg: &VecOpsConfig) -> Result<(), IcicleError>\n    where\n        Data: HostOrDeviceSlice<T> + ?Sized;\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"returningvalueprogramimpl-trait-definition",children:[(0,t.jsx)(n.code,{children:"ReturningValueProgramImpl"})," Trait Definition"]}),"\n",(0,t.jsx)(n.p,{children:"This trait is for programs that return a value (symbol) as output."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub trait ReturningValueProgramImpl: Sized + Handle {\n    type Ring: IntegerRing;\n    type ProgSymbol: Symbol<Self::Ring>;\n\n    fn new(\n        program_func: impl FnOnce(&mut Vec<Self::ProgSymbol>) -> Self::ProgSymbol,\n        nof_parameters: u32,\n    ) -> Result<Self, IcicleError>;\n\n    fn new_predefined(pre_def: PreDefinedProgram) -> Result<Self, IcicleError>;\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"program-struct",children:[(0,t.jsx)(n.code,{children:"Program"})," Struct"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Program"})," struct is implemented for each of the supported icicle fields, implementing the above trait for the specific field (field distinction is relevant for the input symbols and stored constants in the program). At its core, it's just a handle to the cpp implementation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct Program {\n    m_handle: ProgramHandle,\n}\n"})}),"\n",(0,t.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["This section will outline how to use Program and Symbol, mirroring the examples from the ",(0,t.jsx)(n.a,{href:"/api/cpp/program",children:"cpp overview"}),". The program use-case splits to three steps:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Defining a function/lambda that describes the program to be run (or choosing one of the predefined list)."}),"\n",(0,t.jsx)(n.li,{children:"Creating a new program given the above function."}),"\n",(0,t.jsx)(n.li,{children:"Executing the program using the Vector Operations API."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"defining-a-function-for-program",children:"Defining a Function for Program"}),"\n",(0,t.jsx)(n.p,{children:"A function operating on a vector of symbols, with outputs being written to said input vector. The input symbols in the vector represent inputs and outputs of field elements, and will be replaced by vectors of field elements when executed."}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"The defined function defines arithmetic operations to be done in series, and could be represented as a set of equations (for each output). Practically, control flow (e.g., loops, conditions) is not parsed, instead the computation follows the exact execution path taken during tracing, which determines the final computation that will be performed."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn example_function<T, S>(vars: &mut Vec<S>)\nwhere\n    T: IntegerRing,\n    S: Symbol<T>,\n{\n    let a = vars[0];\n    let b = vars[1];\n    let c = vars[2];\n    let eq = vars[3];\n\n    vars[4] = eq * (a * b - c) + T::from_u32(9);\n    vars[5] = a * b - c; // For division, use an Invertible trait if implemented\n    vars[6] = vars[5];\n    vars[3] = (vars[0] + vars[1]) * T::from_u32(2); // all variables can be both inputs and outputs\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-program",children:"Creating a Program"}),"\n",(0,t.jsx)(n.p,{children:"Applying the constructor with the lambda:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let program = Program::new(example_function, 7 /* number of parameters for lambda = vars.len() */)?;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"executing-the-program",children:"Executing the Program"}),"\n",(0,t.jsx)(n.p,{children:"Execution is done through the appropriate vecops function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"program.execute_program(&mut parameters, &cfg)?;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Where ",(0,t.jsx)(n.code,{children:"parameters"})," is a ",(0,t.jsx)(n.code,{children:"Vec<&Parameter>"})," and ",(0,t.jsx)(n.code,{children:"cfg"})," is a ",(0,t.jsx)(n.code,{children:"VecOpsConfig"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.p,{children:"Example taken from check_program in vec_ops tests."}),"\n",(0,t.jsx)(n.h4,{id:"program-functionality-with-a-custom-function",children:"Program functionality with a custom function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub fn check_program<T, Prog>()\nwhere\n    T: IntegerRing,\n    Prog: ProgramImpl<T>,\n{\n    let example_lambda = |vars: &mut Vec<Prog::ProgSymbol>| {\n        let a = vars[0];\n        let b = vars[1];\n        let c = vars[2];\n        let d = vars[3];\n\n        vars[4] = d * (a * b - c) + T::from_u32(9);\n        vars[5] = a * b - c; // For division, use an Invertible trait if implemented\n        vars[6] = vars[5];\n        vars[3] = (vars[0] + vars[1]) * T::from_u32(2);\n    };\n\n    // Additional lines for initiating the slices of field elements for the parameters\n\n    let mut parameters = vec![a_slice, b_slice, c_slice, eq_slice, var4_slice, var5_slice, var6_slice];\n\n    let program = Prog::new(example_lambda, 7).unwrap();\n\n    let cfg = VecOpsConfig::default();\n    program.execute_program(&mut parameters, &cfg).expect("Program Failed");\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"program-functionality-with-predefined-programs",children:"Program functionality with predefined programs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub fn check_predefined_program<T, Prog>()\nwhere\n    T: IntegerRing,\n    Prog: ProgramImpl<T>,\n{\n    // Additional lines for initiating the slices of field elements for the parameters\n    let mut parameters = vec![a_slice, b_slice, c_slice, eq_slice, var4_slice];\n\n    let program = Prog::new_predefined(PreDefinedProgram::EQtimesABminusC).unwrap();\n\n    let cfg = VecOpsConfig::default();\n    program.execute_program(&mut parameters, &cfg).expect("Program Failed");\n}\n'})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var i=r(96540);const t={},o=i.createContext(t);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);
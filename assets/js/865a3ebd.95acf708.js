"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[53653],{37496:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>o,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api/cpp/lattice/pqc_ml_kem","title":"ML-KEM \u2013 Post-Quantum Key Encapsulation (Kyber)","description":"Overview","source":"@site/versioned_docs/version-3.9.0/api/cpp/lattice/pqc_ml_kem.md","sourceDirName":"api/cpp/lattice","slug":"/api/cpp/lattice/pqc_ml_kem","permalink":"/api/cpp/lattice/pqc_ml_kem","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-3.9.0/api/cpp/lattice/pqc_ml_kem.md","tags":[],"version":"3.9.0","lastUpdatedAt":1750864092000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"Pairings","permalink":"/icicle/primitives/pairings"},"next":{"title":"Serialization","permalink":"/api/cpp/serialization"}}');var i=n(74848),r=n(28453);const a={},c="ML-KEM \u2013 Post-Quantum Key Encapsulation (Kyber)",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Byte sizes",id:"byte-sizes",level:2},{value:"C++ API",id:"c-api",level:2},{value:"<code>MlKemConfig</code> struct",id:"mlkemconfig-struct",level:3},{value:"Key pair generation",id:"key-pair-generation",level:3},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Decapsulation",id:"decapsulation",level:3},{value:"Example: generate &amp; encapsulate (Kyber768)",id:"example-generate--encapsulate-kyber768",level:2},{value:"References",id:"references",level:2}];function h(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"ml-kem--post-quantum-key-encapsulation-kyber",children:"ML-KEM \u2013 Post-Quantum Key Encapsulation (Kyber)"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"ML-KEM"})," (Module-Lattice Key Encapsulation Mechanism) \u2013 is a lattice-based key-encapsulation protocol selected by NIST for post-quantum cryptography (",(0,i.jsx)(t.a,{href:"https://csrc.nist.gov/pubs/fips/203/final",children:"FIPS 203"}),").",(0,i.jsx)(t.br,{}),"\n","ML-KEM provides three security categories that correspond to the Kyber512 (Level 1), Kyber768 (Level 3) and Kyber1024 (Level 5) parameter sets."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"byte-sizes",children:"Byte sizes"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Parameter set"}),(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Public key"}),(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Secret key"}),(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Cipher-text"}),(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Shared secret"}),(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Entropy bytes"}),(0,i.jsx)(t.th,{style:{textAlign:"right"},children:"Message bytes"}),(0,i.jsx)(t.th,{children:"Security category"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"Kyber512"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"800 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"1632 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"768 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"32 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"64 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"32 B"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Level 1"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"Kyber768"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"1184 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"2400 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"1088 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"32 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"64 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"32 B"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Level 3"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"Kyber1024"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"1568 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"3168 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"1568 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"32 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"64 B"}),(0,i.jsx)(t.td,{style:{textAlign:"right"},children:"32 B"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Level 5"})})]})]})]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"c-api",children:"C++ API"}),"\n",(0,i.jsxs)(t.p,{children:["All three operations are ",(0,i.jsx)(t.strong,{children:"templated"})," by the Kyber parameter set (",(0,i.jsx)(t.code,{children:"Kyber512Params"}),", ",(0,i.jsx)(t.code,{children:"Kyber768Params"}),", ",(0,i.jsx)(t.code,{children:"Kyber1024Params"}),").  The templates are explicitly instantiated by Icicle, so you only have to include the header and link against ",(0,i.jsx)(t.code,{children:"icicle_pqc"}),"."]}),"\n",(0,i.jsxs)(t.h3,{id:"mlkemconfig-struct",children:[(0,i.jsx)(t.code,{children:"MlKemConfig"})," struct"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"struct MlKemConfig {\n  icicleStreamHandle stream = nullptr; // Optional async stream\n  bool is_async                   = false; // If true \u2013 return immediately and synchronize later\n\n  // Location hints \u2013 set to `true` if the corresponding buffer already resides on the device\n  bool messages_on_device         = false;\n  bool entropy_on_device          = false;\n  bool public_keys_on_device      = false;\n  bool secret_keys_on_device      = false;\n  bool ciphertexts_on_device      = false;\n  bool shared_secrets_on_device   = false;\n\n  int  batch_size = 1;                     // Number of independent KEMs processed in parallel\n\n  ConfigExtension* ext = nullptr;          // Backend-specific tuning knobs (optional)\n};\n"})}),"\n",(0,i.jsx)(t.h3,{id:"key-pair-generation",children:"Key pair generation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"template <typename Params /* Kyber512Params | Kyber768Params | Kyber1024Params */>\neIcicleError keygen(\n    const std::byte* entropy,      // [batch_size \xd7 ENTROPY_BYTES]\n    MlKemConfig        config,\n    std::byte*         public_keys, // [batch_size \xd7 Params::PUBLIC_KEY_BYTES]\n    std::byte*         secret_keys  // [batch_size \xd7 Params::SECRET_KEY_BYTES]\n);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"template <typename Params>\neIcicleError encapsulate(\n    const std::byte* message,       // [batch_size \xd7 MESSAGE_BYTES] arbitrary plaintext\n    const std::byte* public_keys,   // [batch_size \xd7 Params::PUBLIC_KEY_BYTES]\n    MlKemConfig        config,\n    std::byte*         ciphertexts, // [batch_size \xd7 Params::CIPHERTEXT_BYTES]\n    std::byte*         shared_secrets // [batch_size \xd7 Params::SHARED_SECRET_BYTES]\n);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"decapsulation",children:"Decapsulation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"template <typename Params>\neIcicleError decapsulate(\n    const std::byte* secret_keys,   // [batch_size \xd7 Params::SECRET_KEY_BYTES]\n    const std::byte* ciphertexts,   // [batch_size \xd7 Params::CIPHERTEXT_BYTES]\n    MlKemConfig        config,\n    std::byte*         shared_secrets // [batch_size \xd7 Params::SHARED_SECRET_BYTES]\n);\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"example-generate--encapsulate-kyber768",children:"Example: generate & encapsulate (Kyber768)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include "icicle/pqc/ml_kem.h"\nusing namespace icicle::pqc::ml_kem;\n\nint main() {\nconst int batch_size = 1 << 12;\n  // Config\n  MlKemConfig config;\n  config.batch_size = batch_size;\n\n  // Allocate buffers\n  auto entropy = this->random_entropy(batch_size * ENTROPY_BYTES);\n  std::vector<std::byte> public_key(batch_size * TypeParam::PUBLIC_KEY_BYTES);\n  std::vector<std::byte> secret_key(batch_size * TypeParam::SECRET_KEY_BYTES);\n  std::vector<std::byte> ciphertext(batch_size * TypeParam::CIPHERTEXT_BYTES);\n  std::vector<std::byte> shared_secret_enc(batch_size * TypeParam::SHARED_SECRET_BYTES);\n  std::vector<std::byte> shared_secret_dec(batch_size * TypeParam::SHARED_SECRET_BYTES);\n\n  auto message = this->random_entropy(batch_size * MESSAGE_BYTES);\n\n  // Key generation\n  auto err = keygen<TypeParam>(entropy.data(), config, public_key.data(), secret_key.data());\n\n  // Encapsulation\n  err = encapsulate<TypeParam>(message.data(), public_key.data(), config, ciphertext.data(), shared_secret_enc.data());\n\n  // Decapsulation\n  err = decapsulate<TypeParam>(secret_key.data(), ciphertext.data(), config, shared_secret_dec.data());\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.p,{children:["\u2022 ",(0,i.jsxs)(t.a,{href:"https://csrc.nist.gov/pubs/fips/203/final",children:["NIST FIPS 203 \u2013 ",(0,i.jsx)(t.em,{children:"Module-Lattice-Based Key-Encapsulation Mechanism Standard"})]}),"."]})]})}function o(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);
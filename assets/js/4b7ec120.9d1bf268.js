"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2531],{5680:(e,n,i)=>{i.d(n,{xA:()=>m,yg:()=>g});var a=i(6540);function t(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function r(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,a)}return i}function c(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(n){t(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function l(e,n){if(null==e)return{};var i,a,t=function(e,n){if(null==e)return{};var i,a,t={},r=Object.keys(e);for(a=0;a<r.length;a++)i=r[a],n.indexOf(i)>=0||(t[i]=e[i]);return t}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)i=r[a],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var o=a.createContext({}),s=function(e){var n=a.useContext(o),i=n;return e&&(i="function"==typeof e?e(n):c(c({},n),e)),i},m=function(e){var n=s(e.components);return a.createElement(o.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var i=e.components,t=e.mdxType,r=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(i),p=t,g=u["".concat(o,".").concat(p)]||u[p]||d[p]||r;return i?a.createElement(g,c(c({ref:n},m),{},{components:i})):a.createElement(g,c({ref:n},m))}));function g(e,n){var i=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var r=i.length,c=new Array(r);c[0]=p;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[u]="string"==typeof e?e:t,c[1]=l;for(var s=2;s<r;s++)c[s]=i[s];return a.createElement.apply(null,c)}return a.createElement.apply(null,i)}p.displayName="MDXCreateElement"},2495:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=i(8168),t=(i(6540),i(5680));i(1873);const r={},c="Icicle Rust Usage Guide",l={unversionedId:"icicle/programmers_guide/rust",id:"icicle/programmers_guide/rust",title:"Icicle Rust Usage Guide",description:"Overview",source:"@site/docs/icicle/programmers_guide/rust.md",sourceDirName:"icicle/programmers_guide",slug:"/icicle/programmers_guide/rust",permalink:"/icicle/programmers_guide/rust",editUrl:"https://github.com/ingonyama-zk/icicle/tree/main/docs/icicle/programmers_guide/rust.md",tags:[],version:"current",lastUpdatedBy:"Otsar",lastUpdatedAt:1730924803,formattedLastUpdatedAt:"11/6/2024",frontMatter:{},sidebar:"GettingStartedSidebar",previous:{title:"Icicle C++ Usage Guide",permalink:"/icicle/programmers_guide/cpp"},next:{title:"ICICLE Golang Usage Guide",permalink:"/icicle/programmers_guide/go"}},o={},s=[{value:"Overview",id:"overview",level:2},{value:"Build the Rust Application and Execute",id:"build-the-rust-application-and-execute",level:2},{value:"Device Management",id:"device-management",level:2},{value:"Loading a Backend",id:"loading-a-backend",level:3},{value:"Setting and Getting Active Device",id:"setting-and-getting-active-device",level:3},{value:"Querying Device Information",id:"querying-device-information",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"Allocating and Freeing Memory",id:"allocating-and-freeing-memory",level:3},{value:"Asynchronous Memory Operations",id:"asynchronous-memory-operations",level:3},{value:"Querying Available Memory",id:"querying-available-memory",level:3},{value:"Data Transfer",id:"data-transfer",level:2},{value:"Copying Data",id:"copying-data",level:3},{value:"Stream Management",id:"stream-management",level:2},{value:"Creating and Destroying Streams",id:"creating-and-destroying-streams",level:3},{value:"Synchronization",id:"synchronization",level:2},{value:"Synchronizing Streams and Devices",id:"synchronizing-streams-and-devices",level:3},{value:"Device Properties",id:"device-properties",level:2},{value:"Checking Device Availability",id:"checking-device-availability",level:3},{value:"Querying Device Properties",id:"querying-device-properties",level:3},{value:"Compute APIs",id:"compute-apis",level:2},{value:"Multi-Scalar Multiplication (MSM) Example",id:"multi-scalar-multiplication-msm-example",level:3}],m={toc:s},u="wrapper";function d(e){let{components:n,...i}=e;return(0,t.yg)(u,(0,a.A)({},m,i,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"icicle-rust-usage-guide"},"Icicle Rust Usage Guide"),(0,t.yg)("h2",{id:"overview"},"Overview"),(0,t.yg)("p",null,"This guide covers the usage of ICICLE\u2019s Rust API, including device management, memory operations, data transfer, synchronization, and compute APIs."),(0,t.yg)("h2",{id:"build-the-rust-application-and-execute"},"Build the Rust Application and Execute"),(0,t.yg)("p",null,"To successfully build and execute the Rust application using ICICLE, you need to define the ICICLE dependencies in your Cargo.toml file:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'[dependencies]\nicicle-runtime = { git = "https://github.com/ingonyama-zk/icicle.git", branch="main" }\nicicle-core = { git = "https://github.com/ingonyama-zk/icicle.git", branch="main" }\nicicle-babybear = { git = "https://github.com/ingonyama-zk/icicle.git", branch="main" }\n# add other ICICLE crates here as needed\n')),(0,t.yg)("p",null,"Once the dependencies are defined, you can build and run your application using the following command:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},"cargo run --release\n")),(0,t.yg)("p",null,"This will compile your Rust application with optimizations and execute it."),(0,t.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,t.yg)("div",{parentName:"div",className:"admonition-heading"},(0,t.yg)("h5",{parentName:"div"},(0,t.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,t.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,t.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,t.yg)("div",{parentName:"div",className:"admonition-content"},(0,t.yg)("p",{parentName:"div"},"The icicle-runtime crate is used to load backends, select a device, and interact with the device in an abstract way when managing memory, streams, and other resources, as explained in this guide."))),(0,t.yg)("h2",{id:"device-management"},"Device Management"),(0,t.yg)("h3",{id:"loading-a-backend"},"Loading a Backend"),(0,t.yg)("p",null,"The backend can be loaded from a specific path or from an environment variable. This is essential for setting up the computing environment."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},'use icicle_runtime::runtime;\n\nruntime::load_backend_from_env_or_default().unwrap();\n// or load from custom install dir\nruntime::load_backend("/path/to/backend/installdir").unwrap();\n')),(0,t.yg)("h3",{id:"setting-and-getting-active-device"},"Setting and Getting Active Device"),(0,t.yg)("p",null,"You can set the active device for the current thread and retrieve it when needed:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},'use icicle_runtime::Device;\n\nlet device = Device::new("CUDA", 0); // or other\nicicle_runtime::set_device(&device).unwrap();\n\nlet active_device = icicle_runtime::get_active_device().unwrap();\n')),(0,t.yg)("h3",{id:"querying-device-information"},"Querying Device Information"),(0,t.yg)("p",null,"Retrieve the number of available devices and check if a pointer is allocated on the host or on the active device:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},"let device_count = icicle_runtime::get_device_count().unwrap();\n")),(0,t.yg)("h2",{id:"memory-management"},"Memory Management"),(0,t.yg)("h3",{id:"allocating-and-freeing-memory"},"Allocating and Freeing Memory"),(0,t.yg)("p",null,"Memory can be allocated on the active device using the ",(0,t.yg)("inlineCode",{parentName:"p"},"DeviceVec")," API. This memory allocation is flexible, as it supports allocation on any device, including the CPU if the CPU backend is used."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_runtime::memory::DeviceVec;\n\n// Allocate 1024 elements on the device\nlet mut device_memory: DeviceVec<u8> = DeviceVec::<u8>::device_malloc(1024).unwrap();\n")),(0,t.yg)("p",null,"The memory is released when the ",(0,t.yg)("inlineCode",{parentName:"p"},"DeviceVec")," object is dropped."),(0,t.yg)("h3",{id:"asynchronous-memory-operations"},"Asynchronous Memory Operations"),(0,t.yg)("p",null,"Asynchronous memory operations can be performed using streams. This allows for non-blocking execution, with memory allocation and deallocation occurring asynchronously."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_runtime::stream::IcicleStream;\nuse icicle_runtime::memory::DeviceVec;\n\nlet mut stream = IcicleStream::create().unwrap(); // mutability is for the destroy() method\n\n// Allocate 1024 elements asynchronously on the device\nlet mut device_memory: DeviceVec<u8> = DeviceVec::<u8>::device_malloc_async(1024, &stream).unwrap();\n\n// dispatch additional copy, compute etc. ops to the stream\n\n// Synchronize the stream to ensure all operations are complete\nstream.synchronize().unwrap();\nstream.destroy().unwrap(); //\n")),(0,t.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,t.yg)("div",{parentName:"div",className:"admonition-heading"},(0,t.yg)("h5",{parentName:"div"},(0,t.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,t.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,t.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,t.yg)("div",{parentName:"div",className:"admonition-content"},(0,t.yg)("p",{parentName:"div"},"Streams need be explicitly destroyed before being dropped."))),(0,t.yg)("h3",{id:"querying-available-memory"},"Querying Available Memory"),(0,t.yg)("p",null,"You can retrieve the total and available memory on the active device using the ",(0,t.yg)("inlineCode",{parentName:"p"},"get_available_memory")," function."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},'use icicle_runtime::memory::get_available_memory;\n\n// Retrieve total and available memory on the active device\nlet (total_memory, available_memory) = get_available_memory().unwrap();\n\nprintln!("Total memory: {}", total_memory);\nprintln!("Available memory: {}", available_memory);\n')),(0,t.yg)("p",null,"This function returns a tuple containing the total memory and the currently available memory on the device. It is essential for managing and optimizing resource usage in your applications."),(0,t.yg)("h2",{id:"data-transfer"},"Data Transfer"),(0,t.yg)("h3",{id:"copying-data"},"Copying Data"),(0,t.yg)("p",null,"Data can be copied between the host and device, or between devices. The location of the memory is handled by the ",(0,t.yg)("inlineCode",{parentName:"p"},"HostOrDeviceSlice")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"DeviceSlice")," traits:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_runtime::memory::{DeviceVec, HostSlice};\n\n// Copy data from host to device\nlet input = vec![1, 2, 3, 4];\nlet mut d_mem = DeviceVec::<u32>::device_malloc(input.len()).unwrap();\nd_mem.copy_from_host(HostSlice::from_slice(&input)).unwrap();\n// OR\nd_mem.copy_from_host_async(HostSlice::from_slice(&input, &stream)).unwrap();\n\n// Copy data back from device to host\nlet mut output = vec![0; input.len()];\nd_mem.copy_to_host(HostSlice::from_mut_slice(&mut output)).unwrap();\n// OR\nd_mem.copy_to_host_async(HostSlice::from_mut_slice(&mut output, &stream)).unwrap();\n")),(0,t.yg)("h2",{id:"stream-management"},"Stream Management"),(0,t.yg)("h3",{id:"creating-and-destroying-streams"},"Creating and Destroying Streams"),(0,t.yg)("p",null,"Streams in Icicle are used to manage asynchronous operations, ensuring that computations can run in parallel without blocking the CPU thread:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_runtime::stream::IcicleStream;\n\n// Create a stream\nlet mut stream = IcicleStream::create().unwrap();\n\n// Destroy the stream\nstream.destroy().unwrap();\n")),(0,t.yg)("h2",{id:"synchronization"},"Synchronization"),(0,t.yg)("h3",{id:"synchronizing-streams-and-devices"},"Synchronizing Streams and Devices"),(0,t.yg)("p",null,"Synchronization ensures that all previous operations on a stream or device are completed before moving on to the next task. This is crucial when coordinating between multiple dependent operations:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_runtime::stream::IcicleStream;\n\n// Synchronize the stream\nstream.synchronize().unwrap();\n\n// Synchronize the device\nicicle_runtime::device_synchronize().unwrap();\n")),(0,t.yg)("p",null,"These functions ensure that your operations are properly ordered and completed before the program proceeds, which is critical in parallel computing environments."),(0,t.yg)("h2",{id:"device-properties"},"Device Properties"),(0,t.yg)("h3",{id:"checking-device-availability"},"Checking Device Availability"),(0,t.yg)("p",null,"Check if a specific device is available and retrieve a list of registered devices:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},'use icicle_runtime::Device;\n\nlet cuda_device = Device::new("CUDA", 0);\nif icicle_runtime::is_device_available(&cuda_device) {\n    println!("CUDA device is available.");\n} else {\n    println!("CUDA device is not available.");\n}\n\nlet registered_devices = icicle_runtime::get_registered_devices().unwrap();\nprintln!("Registered devices: {:?}", registered_devices);\n')),(0,t.yg)("h3",{id:"querying-device-properties"},"Querying Device Properties"),(0,t.yg)("p",null,"Retrieve properties of the active device to understand its capabilities and configurations:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},'use icicle_runtime::Device;\n\nlet cuda_device = Device::new("CUDA", 0);\nif icicle_runtime::is_device_available(&cuda_device) {\n    icicle_runtime::set_device(&cuda_device);\n    let device_props = icicle_runtime::get_device_properties().unwrap();\n    println!("Device using host memory: {}", device_props.using_host_memory);\n}\n')),(0,t.yg)("p",null,"These functions allow you to query device capabilities and ensure that your application is running on the appropriate hardware."),(0,t.yg)("h2",{id:"compute-apis"},"Compute APIs"),(0,t.yg)("h3",{id:"multi-scalar-multiplication-msm-example"},"Multi-Scalar Multiplication (MSM) Example"),(0,t.yg)("p",null,"Icicle provides high-performance compute APIs such as Multi-Scalar Multiplication (MSM) for cryptographic operations. Here's a simple example of how to use the MSM API in Rust."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-rust"},'// Using bls12-377 curve\nuse icicle_bls12_377::curve::{CurveCfg, G1Projective, ScalarCfg};\nuse icicle_core::{curve::Curve, msm, msm::MSMConfig, traits::GenerateRandom};\nuse icicle_runtime::{device::Device, memory::HostSlice};\n\nfn main() {\n    // Load backend and set device\n    let _ = icicle_runtime::runtime::load_backend_from_env_or_default();\n    let cuda_device = Device::new("CUDA", 0);\n    if icicle_runtime::is_device_available(&cuda_device) {\n        icicle_runtime::set_device(&cuda_device).unwrap();\n    }\n\n    let size = 1024;\n\n    // Randomize inputs\n    let points = CurveCfg::generate_random_affine_points(size);\n    let scalars = ScalarCfg::generate_random(size);\n\n    let mut msm_results = vec![G1Projective::zero(); 1];\n    msm::msm(\n        HostSlice::from_slice(&scalars),\n        HostSlice::from_slice(&points),\n        &MSMConfig::default(),\n        HostSlice::from_mut_slice(&mut msm_results[..]),\n    )\n    .unwrap();\n    println!("MSM result = {:?}", msm_results);\n}\n')))}d.isMDXComponent=!0},1873:(e,n,i)=>{i(6540)}}]);
"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[46192],{74688:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api/rust-bindings/vec-ops","title":"Vector Operations API","description":"Our vector operations API includes fundamental methods for addition, subtraction, multiplication, division, and more, with support for both host and device memory, as well as batched operations.","source":"@site/versioned_docs/version-4.0.0/api/rust-bindings/vec-ops.md","sourceDirName":"api/rust-bindings","slug":"/api/rust-bindings/vec-ops","permalink":"/api/rust-bindings/vec-ops","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-4.0.0/api/rust-bindings/vec-ops.md","tags":[],"version":"4.0.0","lastUpdatedAt":1754480071000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"ECNTT","permalink":"/api/rust-bindings/ecntt"},"next":{"title":"Program","permalink":"/api/rust-bindings/program"}}');var c=n(74848),r=n(28453);const t={},o="Vector Operations API",l={},d=[{value:"Vector Operations Configuration",id:"vector-operations-configuration",level:2},{value:"<code>VecOpsConfig</code>",id:"vecopsconfig",level:3},{value:"Fields",id:"fields",level:4},{value:"Default Configuration",id:"default-configuration",level:3},{value:"Vector Operations",id:"vector-operations",level:2},{value:"Methods",id:"methods",level:3}];function a(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(i.header,{children:(0,c.jsx)(i.h1,{id:"vector-operations-api",children:"Vector Operations API"})}),"\n",(0,c.jsx)(i.p,{children:"Our vector operations API includes fundamental methods for addition, subtraction, multiplication, division, and more, with support for both host and device memory, as well as batched operations."}),"\n",(0,c.jsx)(i.h2,{id:"vector-operations-configuration",children:"Vector Operations Configuration"}),"\n",(0,c.jsxs)(i.p,{children:["The ",(0,c.jsx)(i.code,{children:"VecOpsConfig"})," struct encapsulates the settings for vector operations, including device context, operation modes, and batching parameters."]}),"\n",(0,c.jsx)(i.h3,{id:"vecopsconfig",children:(0,c.jsx)(i.code,{children:"VecOpsConfig"})}),"\n",(0,c.jsx)(i.p,{children:"Defines configuration parameters for vector operations."}),"\n",(0,c.jsx)(i.pre,{children:(0,c.jsx)(i.code,{className:"language-rust",children:"pub struct VecOpsConfig {\n    pub stream_handle: IcicleStreamHandle,\n    pub is_a_on_device: bool,\n    pub is_b_on_device: bool,\n    pub is_result_on_device: bool,\n    pub is_async: bool,\n    pub batch_size: i32,\n    pub columns_batch: bool,\n    pub ext: ConfigExtension,\n}\n"})}),"\n",(0,c.jsx)(i.h4,{id:"fields",children:"Fields"}),"\n",(0,c.jsxs)(i.ul,{children:["\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"stream_handle: IcicleStreamHandle"})}),": Specifies the stream (queue) to use for async execution"]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"is_a_on_device: bool"})}),": Indicates whether the input data a has been preloaded on the device memory. If ",(0,c.jsx)(i.code,{children:"false"})," inputs will be copied from host to device."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"is_b_on_device: bool"})}),": Indicates whether the input b data has been preloaded on the device memory. If ",(0,c.jsx)(i.code,{children:"false"})," inputs will be copied from host to device."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"is_result_on_device: bool"})}),": Indicates whether the output data is preloaded in device memory. If ",(0,c.jsx)(i.code,{children:"false"})," outputs will be copied from host to device."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"is_async: bool"})}),": Specifies whether the operation should be performed asynchronously."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"batch_size: i32"})}),": Number of vector operations to process in a single batch. Each operation will be performed independently on each batch element. It is implicitly determined given the inputs and outputs to the vector operation."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"columns_batch: bool"})}),": true if the batched vectors are stored as columns in a 2D array (i.e., the vectors are strided in memory as columns of a matrix). If false, the batched vectors are stored contiguously in memory (e.g., as rows or in a flat array). Default is false."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"ext: ConfigExtension"})}),": Extended configuration for backend. Default is ",(0,c.jsx)(i.code,{children:"ConfigExtension::new()"}),"."]}),"\n"]}),"\n",(0,c.jsx)(i.h3,{id:"default-configuration",children:"Default Configuration"}),"\n",(0,c.jsxs)(i.p,{children:[(0,c.jsx)(i.code,{children:"VecOpsConfig"})," can be initialized with default settings tailored for a specific device:"]}),"\n",(0,c.jsx)(i.pre,{children:(0,c.jsx)(i.code,{className:"language-rust",children:"let cfg = VecOpsConfig::default();\n"})}),"\n",(0,c.jsx)(i.h2,{id:"vector-operations",children:"Vector Operations"}),"\n",(0,c.jsxs)(i.p,{children:["Vector operations are implemented through the ",(0,c.jsx)(i.code,{children:"VecOps"})," trait, providing methods for addition, subtraction, multiplication, division, inversion, reduction, and more. These methods support both single and batched operations based on the batch_size and columns_batch configurations."]}),"\n",(0,c.jsx)(i.h3,{id:"methods",children:"Methods"}),"\n",(0,c.jsxs)(i.p,{children:["All operations are element-wise operations, and the results placed into the ",(0,c.jsx)(i.code,{children:"result"})," param. These operations are not in place, except for accumulate and bit_reverse_inplace."]}),"\n",(0,c.jsxs)(i.ul,{children:["\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"add"})}),": Computes the element-wise sum of two vectors."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"accumulate"})}),": Sum input b to a inplace."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"sub"})}),": Computes the element-wise difference between two vectors."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"mul"})}),": Performs element-wise multiplication of two vectors."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"div"})}),": Performs element-wise division of two vectors."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"inv"})}),": Computes the element-wise inverse of a vector."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"sum"})}),": Reduces a vector to its sum (optionally batched)."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"product"})}),": Reduces a vector to its product (optionally batched)."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"scalar_add"})}),": Adds a scalar to each element of a vector (batched)."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"scalar_sub"})}),": Subtracts a scalar from each element of a vector (batched)."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"scalar_mul"})}),": Multiplies each element of a vector by a scalar (batched)."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"bit_reverse/bit_reverse_inplace"})}),": Reverse order of elements based on bit-reverse."]}),"\n",(0,c.jsxs)(i.li,{children:[(0,c.jsx)(i.strong,{children:(0,c.jsx)(i.code,{children:"slice"})}),": Extracts a strided slice from a vector."]}),"\n"]}),"\n",(0,c.jsx)(i.pre,{children:(0,c.jsx)(i.code,{className:"language-rust",children:"pub fn add_scalars<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn accumulate_scalars<F>(\n    a: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn sub_scalars<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn mul_scalars<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn div_scalars<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn inv_scalars<F>(\n    input: &(impl HostOrDeviceSlice<F> + ?Sized),\n    output: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn sum_scalars<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn product_scalars<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn scalar_add<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn scalar_sub<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn scalar_mul<F>(\n    a: &(impl HostOrDeviceSlice<F> + ?Sized),\n    b: &(impl HostOrDeviceSlice<F> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn bit_reverse<F>(\n    input: &(impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n    output: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n) -> Result<(), IcicleError>;\n\npub fn bit_reverse_inplace<F>(\n    input: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>;\n\npub fn slice<F>(\n    input: &(impl HostOrDeviceSlice<F> + ?Sized),\n    offset: u64,\n    stride: u64,\n    size_in: u64,\n    size_out: u64,\n    cfg: &VecOpsConfig,\n    output: &mut (impl HostOrDeviceSlice<F> + ?Sized),\n) -> Result<(), IcicleError>;\n"})})]})}function u(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,c.jsx)(i,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>o});var s=n(96540);const c={},r=s.createContext(c);function t(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);
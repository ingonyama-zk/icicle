"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[1572],{61555:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"api/rust-bindings/lattice/lattice-snarks","title":"Lattice-Based SNARKs \u2014 Rust API Overview","description":"Overview","source":"@site/versioned_docs/version-4.0.0/api/rust-bindings/lattice/lattice-snarks.md","sourceDirName":"api/rust-bindings/lattice","slug":"/api/rust-bindings/lattice/lattice-snarks","permalink":"/api/rust-bindings/lattice/lattice-snarks","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-4.0.0/api/rust-bindings/lattice/lattice-snarks.md","tags":[],"version":"4.0.0","lastUpdatedAt":1752654507000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"FRI","permalink":"/api/rust-bindings/fri"},"next":{"title":"PQC ML-KEM","permalink":"/api/rust-bindings/lattice/pqc-ml-kem"}}');var o=i(74848),s=i(28453);const r={},t="Lattice-Based SNARKs \u2014 Rust API Overview",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Capabilities",id:"key-capabilities",level:2},{value:"Core Types",id:"core-types",level:3},{value:"Supported Operations",id:"supported-operations",level:3},{value:"See a full Rust example here.",id:"see-a-full-rust-example-here",level:2},{value:"Core Types",id:"core-types-1",level:2},{value:"Integer Ring: Zq",id:"integer-ring-zq",level:3},{value:"Example",id:"example",level:4},{value:"Polynomial Ring: Rq",id:"polynomial-ring-rq",level:3},{value:"Example",id:"example-1",level:4},{value:"Reinterpreting Rq and Zq slices",id:"reinterpreting-rq-and-zq-slices",level:3},{value:"Example",id:"example-2",level:4},{value:"Negacyclic NTT",id:"negacyclic-ntt",level:2},{value:"Forward and Inverse NTT (Rq to/from Tq)",id:"forward-and-inverse-ntt-rq-tofrom-tq",level:3},{value:"Main Imports",id:"main-imports",level:3},{value:"NTT API",id:"ntt-api",level:3},{value:"Inplace NTT API",id:"inplace-ntt-api",level:3},{value:"Example",id:"example-3",level:3},{value:"Matrix Operations",id:"matrix-operations",level:2},{value:"Matrix Multiplication and Transpose over Ring Elements",id:"matrix-multiplication-and-transpose-over-ring-elements",level:3},{value:"Main Imports",id:"main-imports-1",level:3},{value:"Matrix multiplication API",id:"matrix-multiplication-api",level:3},{value:"Matrix transpose API",id:"matrix-transpose-api",level:3},{value:"Example",id:"example-4",level:3},{value:"Polynomial Ring Vector Operations",id:"polynomial-ring-vector-operations",level:2},{value:"Supported VecOps",id:"supported-vecops",level:3},{value:"API",id:"api",level:3},{value:"Example",id:"example-5",level:3},{value:"Balanced Base Decomposition",id:"balanced-base-decomposition",level:2},{value:"Decompose and Recompose Ring Elements",id:"decompose-and-recompose-ring-elements",level:3},{value:"Output Layout",id:"output-layout",level:3},{value:"Main Imports",id:"main-imports-2",level:3},{value:"API",id:"api-1",level:3},{value:"Examples",id:"examples",level:3},{value:"Norm Bound Checking",id:"norm-bound-checking",level:2},{value:"Main Imports",id:"main-imports-3",level:3},{value:"API",id:"api-2",level:3},{value:"Example",id:"example-6",level:3},{value:"Johnson\u2013Lindenstrauss (JL) Projection",id:"johnsonlindenstrauss-jl-projection",level:2},{value:"Supported Capabilities",id:"supported-capabilities",level:3},{value:"Main imports",id:"main-imports-4",level:3},{value:"API",id:"api-3",level:3},{value:"Example",id:"example-7",level:3},{value:"Seeded Random Sampling",id:"seeded-random-sampling",level:2},{value:"Main imports",id:"main-imports-5",level:3},{value:"API",id:"api-4",level:3},{value:"Example",id:"example-8",level:3},{value:"Challenge Sampling with Operator Norm Rejection",id:"challenge-sampling-with-operator-norm-rejection",level:2},{value:"Main imports",id:"main-imports-6",level:3},{value:"API",id:"api-5",level:3},{value:"Example",id:"example-9",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"lattice-based-snarks--rust-api-overview",children:"Lattice-Based SNARKs \u2014 Rust API Overview"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.p,{children:["ICICLE provides a modular, high-performance Rust API for lattice-based SNARK constructions. Implemented across the ",(0,o.jsx)(n.code,{children:"icicle-core"})," and ",(0,o.jsx)(n.code,{children:"icicle-babykoala"})," crates, the API supports efficient operations over integer and polynomial rings, with CPU and CUDA backends."]}),"\n",(0,o.jsxs)(n.p,{children:["The design is generic over ring constructions, enabling flexible use of different ",(0,o.jsx)(n.code,{children:"Zq"})," and ",(0,o.jsx)(n.code,{children:"Rq"})," instantiations for cryptographic protocols like ",(0,o.jsx)(n.strong,{children:"labrador"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"key-capabilities",children:"Key Capabilities"}),"\n",(0,o.jsx)(n.h3,{id:"core-types",children:"Core Types"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"Zq"})})," \u2014 Integer rings modulo ( q )"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"Rq"})," / ",(0,o.jsx)(n.code,{children:"Tq"})]})," \u2014 Polynomial rings ",(0,o.jsx)(n.code,{children:"Zq[X]/(X\u207f + 1)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Rq"})," refers to the coefficient (standard) representation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Tq"})," refers to the evaluation (NTT-transformed) representation."]}),"\n",(0,o.jsx)(n.li,{children:"In ICICLE, both share a single unified trait."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"supported-operations",children:"Supported Operations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Negacyclic Number-Theoretic Transforms (NTT)"}),(0,o.jsx)(n.br,{}),"\n","For fast polynomial multiplication in ",(0,o.jsx)(n.code,{children:"Tq"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Matrix Operations"}),(0,o.jsx)(n.br,{}),"\n","Matrix multiplication and transpose"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Vector Operations"}),(0,o.jsx)(n.br,{}),"\n","Elementwise arithmetic, sum-reduction, scalar ops"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Balanced Base Decomposition"}),(0,o.jsx)(n.br,{}),"\n","Represent elements in base-",(0,o.jsx)(n.code,{children:"b"})," with digits in ",(0,o.jsx)(n.code,{children:"(-b/2, b/2]"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Norm Computation"}),(0,o.jsx)(n.br,{}),"\n","\u2113\u2082 and \u2113\u221e norms with bound checking"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Johnson\u2013Lindenstrauss (JL) Projection"}),(0,o.jsx)(n.br,{}),"\n","Randomized projection with reproducible seeds"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Random Vector Sampling"}),(0,o.jsx)(n.br,{}),"\n","Efficient, seedable generation of vectors over ",(0,o.jsx)(n.code,{children:"Zq"})," or ",(0,o.jsx)(n.code,{children:"Rq"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Challenge Sampling"}),(0,o.jsx)(n.br,{}),"\n","Rejection sampling of polynomials satisfying operator norm bounds"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For example, the ",(0,o.jsx)(n.strong,{children:"labrador"})," protocol builds on this foundation to implement a lattice-based zk-SNARK with modular components and device acceleration."]}),"\n",(0,o.jsx)(n.h2,{id:"see-a-full-rust-example-here",children:(0,o.jsx)(n.a,{href:"https://github.com/ingonyama-zk/icicle/tree/main/examples/rust/lattice-snarks",children:"See a full Rust example here."})}),"\n",(0,o.jsx)(n.h2,{id:"core-types-1",children:"Core Types"}),"\n",(0,o.jsx)(n.h3,{id:"integer-ring-zq",children:"Integer Ring: Zq"}),"\n",(0,o.jsxs)(n.p,{children:["The integer ring ",(0,o.jsx)(n.code,{children:"Zq"})," represents integers modulo ",(0,o.jsx)(n.code,{children:"q"}),", where ",(0,o.jsx)(n.code,{children:"q"})," is typically a product of small prime fields for efficiency."]}),"\n",(0,o.jsx)(n.p,{children:"The modulus q used in this library is a special 64-bit prime constructed as the product of two 32-bit primes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"q = P_babybear \xd7 P_koalabear\n  = 0x78000001 \xd7 0x7f000001\n  = 0x3b880000f7000001\n  = 4289678649214369793\n"})}),"\n",(0,o.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::{bignum::BigNum, traits::GenerateRandom};\nuse icicle_babykoala::ring::ScalarRing as Zq;\n\n// Generate random Zq elements\nlet size = 100;\nlet zq_random: Vec<Zq> = Zq::generate_random(size);\n\n// Generate zeros Zq elements\nlet zq_zeros: Vec<Zq> = vec![Zq::default(); size];\n\n// Generate elements from arbitrary bytes\nlet element_size = std::mem::size_of::<Zq>();\nlet some_bytes: Vec<u8> = vec![0; element_size * size];\nlet zq_from_bytes: Vec<Zq> = some_bytes\n    .chunks(element_size)\n    .map(Zq::from_bytes_le)\n    .collect();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"polynomial-ring-rq",children:"Polynomial Ring: Rq"}),"\n",(0,o.jsxs)(n.p,{children:["The polynomial ring ",(0,o.jsx)(n.code,{children:"Rq = Zq[X]/(X^d + 1)"})," represents polynomials of degree less than ",(0,o.jsx)(n.code,{children:"d"})," with coefficients in ",(0,o.jsx)(n.code,{children:"Zq"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::{polynomial_ring::PolynomialRing, traits::GenerateRandom}; // traits\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq; // concrete type\nuse icicle_babykoala::ring::ScalarRing as Zq; // concrete type\nuse icicle_runtime::IcicleError;\n\n// Generate random polynomials\nlet size = 8;\nlet rq_random: Vec<Rq> = Rq::generate_random(size);\nlet rq_zeros: Vec<Rq> = vec![Rq::default(); size];\n\n// Convert Zq chunks to Rq polynomials\nlet zq_zeros: Vec<Zq> = vec![Zq::default(); size * Rq::DEGREE];\nlet unwrap = |result: Result<_, IcicleError>| result.unwrap();\nlet rq_from_slice: Vec<Rq> = zq_zeros\n    .chunks(Rq::DEGREE)\n    .map(Rq::from_slice)\n    .map(unwrap)\n    .collect();\n\n// Or from arbitrary bytes\n"})}),"\n",(0,o.jsx)(n.h3,{id:"reinterpreting-rq-and-zq-slices",children:"Reinterpreting Rq and Zq slices"}),"\n",(0,o.jsx)(n.p,{children:"Many ICICLE APIs are defined over scalar rings like Zq, but can be applied to polynomial ring vectors (Rq) by flattening the polynomials into a contiguous Zq slice. This is useful for operations like JL projection."}),"\n",(0,o.jsx)(n.p,{children:"To enable this, ICICLE provides utilities to reinterpret slices of polynomials as slices of their base field elements, using the HostOrDeviceSlice trait abstraction."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// # Source\n/// [`icicle_runtime::memory`]\n/// \n/// Reinterprets a slice of polynomials as a flat slice of their base field elements.\n///\n/// This enables treating `&[P]` (e.g. Rq) as `&[P::Base]` (e.g. Zq) for scalar operations.\n///\n/// # Safety\n/// - `P` must be `#[repr(C)]` and match the layout of `[P::Base; DEGREE]`.\n/// - Memory must be properly aligned and valid for reading.\n#[inline(always)]\npub fn flatten_polyring_slice<'a, P>(\n    input: &'a (impl HostOrDeviceSlice<P> + ?Sized),\n) -> impl HostOrDeviceSlice<P::Base> + 'a\nwhere\n    P: PolynomialRing,\n    P::Base: FieldImpl + 'a,\n{\n    unsafe { reinterpret_slice::<P, P::Base>(input).expect(\"Invalid slice cast\") }\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// # Source\n/// [`icicle_runtime::memory`]\n/// \n/// Reinterprets a mutable slice of polynomials as a flat mutable slice of their base field elements.\n///\n/// # Safety\n/// - Layout must match `[P::Base; DEGREE]` exactly.\n/// - Caller must ensure exclusive access and proper alignment.\n#[inline(always)]\npub fn flatten_polyring_slice_mut<'a, P>(\n    input: &'a mut (impl HostOrDeviceSlice<P> + ?Sized),\n) -> impl HostOrDeviceSlice<P::Base> + 'a\nwhere\n    P: PolynomialRing,\n    P::Base: 'a,\n{\n    unsafe { reinterpret_slice_mut::<P, P::Base>(input).expect(\"Invalid slice cast\") }\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["These helpers use the general ",(0,o.jsx)(n.strong,{children:"reinterpret_slice"})," utility, which reinterprets memory across types when their sizes and alignments match."]})}),"\n",(0,o.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::polynomial_ring::flatten_polyring_slice; // or flatten_polyring_slice_mut\nuse icicle_core::traits::GenerateRandom;\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq;\nuse icicle_runtime::memory::HostSlice; // concrete type\n\nlet polynomials = Rq::generate_random(5);\nlet poly_slice = HostSlice::from_slice(&polynomials);\n\n// Flatten into a Zq slice (5 \xd7 DEGREE elements)\nlet scalar_slice = flatten_polyring_slice(poly_slice);\n\n// This can now be passed into scalar-only APIs like `jl_projection`, `check_norm_bound`, etc.\n"})}),"\n",(0,o.jsx)(n.h2,{id:"negacyclic-ntt",children:"Negacyclic NTT"}),"\n",(0,o.jsx)(n.h3,{id:"forward-and-inverse-ntt-rq-tofrom-tq",children:"Forward and Inverse NTT (Rq to/from Tq)"}),"\n",(0,o.jsxs)(n.p,{children:["The negacyclic Number-Theoretic Transform (NTT) converts polynomials in ",(0,o.jsx)(n.code,{children:"Rq = Zq[X]/(X\u207f + 1)"})," to the evaluations domain ",(0,o.jsx)(n.code,{children:"Tq"}),", enabling efficient polynomial multiplication via element-wise operations."]}),"\n",(0,o.jsx)(n.h3,{id:"main-imports",children:"Main Imports"}),"\n",(0,o.jsx)(n.p,{children:"To use the NTT API, import the following symbols:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::negacyclic_ntt::{\n    NegacyclicNttConfig, // Configuration for backend/device/async\n    NegacyclicNtt,       // Trait implemented by polynomial types\n    ntt,                 // Out-of-place NTT wrapper\n    ntt_inplace,         // In-place NTT wrapper\n    NTTDir,              // Transform direction (Forward or Inverse)\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"ntt-api",children:"NTT API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Performs a negacyclic Number-Theoretic Transform (NTT) over a polynomial ring.\n///\n/// - `input`: Input slice containing polynomials\n/// - `output`: Output slice to store the transformed result\n/// - `dir`: Transform direction (`Forward` or `Inverse`)\n/// - `cfg`: Execution configuration (device flags, stream, async mode)\npub fn ntt<P: PolynomialRing + NegacyclicNtt<P>>(\n    input: &(impl HostOrDeviceSlice<P> + ?Sized),\n    dir: NTTDir,\n    cfg: &NegacyclicNttConfig,\n    output: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n) -> Result<(), IcicleError>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"inplace-ntt-api",children:"Inplace NTT API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"\n/// Performs an in-place negacyclic NTT over a polynomial ring.\n///\n/// Performs an in-place negacyclic Number-Theoretic Transform (NTT) over a polynomial ring\n///\n/// - `inout`: Buffer to transform in-place\n/// - `dir`: Transform direction (`Forward` or `Inverse`)\n/// - `cfg`: Execution configuration\npub fn ntt_inplace<P: PolynomialRing + NegacyclicNtt<P>>(\n    inout: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n    dir: NTTDir,\n    cfg: &NegacyclicNttConfig,\n) -> Result<(), IcicleError> {\n    P::ntt_inplace(inout, dir, cfg)\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::negacyclic_ntt::{\n    ntt_inplace,         // In-place NTT wrapper\n    NTTDir,              // Transform direction (Forward or Inverse)\n    NegacyclicNttConfig, // Configuration for backend/device/async\n};\nuse icicle_core::traits::GenerateRandom;\nuse icicle_babykoala::polynomial_ring::PolyRing;\nuse icicle_runtime::memory::{DeviceVec, HostSlice};\n\n// Generate random input on the host\nlet size = 16;\nlet input = PolyRing::generate_random(size);\n\n// Allocate and transfer to device memory\nlet mut device_input = DeviceVec::<PolyRing>::device_malloc(size).expect("malloc failed");\ndevice_input\n    .copy_from_host(HostSlice::from_slice(&input))\n    .expect("copy failed");\n\n// Compute in-place (or out of place)\nlet config = NegacyclicNttConfig::default();\nntt_inplace(&mut device_input, NTTDir::kForward, &config).expect("ntt failed"); \n'})}),"\n",(0,o.jsx)(n.h2,{id:"matrix-operations",children:"Matrix Operations"}),"\n",(0,o.jsx)(n.h3,{id:"matrix-multiplication-and-transpose-over-ring-elements",children:"Matrix Multiplication and Transpose over Ring Elements"}),"\n",(0,o.jsx)(n.p,{children:"ICICLE provides generic APIs for performing matrix operations over Polynomial rings."}),"\n",(0,o.jsx)(n.p,{children:"Supported operations include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Dense matrix multiplication (row-major layout)"}),"\n",(0,o.jsx)(n.li,{children:"Matrix transposition (row-major input)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These are useful for vector dot-products, Ajtai-style commitments, and other algebraic primitives in lattice-based SNARKs."}),"\n",(0,o.jsx)(n.h3,{id:"main-imports-1",children:"Main Imports"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::matrix_ops::{\n    matmul,                 // Matrix multiplication\n    matrix_transpose,       // Matrix transpose\n    MatMulConfig,           // Backend and execution configuration\n    MatrixOps,              // Trait for matmul    \n};\nuse icicle_core::vec_ops::VecOpsConfig;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"matrix-multiplication-api",children:"Matrix multiplication API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Computes C = A \xd7 B for two row-major matrices, with optional transposition of A and/or B.\n///\n/// - `a`: Input matrix A, shape (a_rows \xd7 a_cols). Treated as A\u1d57 if `cfg.a_transposed` is true.\n/// - `b`: Input matrix B, shape (b_rows \xd7 b_cols). Treated as B\u1d57 if `cfg.b_transposed` is true.\n/// - `cfg`: Execution configuration (e.g., transposition flags, memory location, async mode).\n/// - `result`: Output buffer for matrix C, with shape:\n///     - `(a_rows \xd7 b_cols)` if `cfg.result_transposed == false`\n///     - `(b_cols \xd7 a_rows)` if `cfg.result_transposed == true`\n///\n/// Returns an error if the matrix dimensions are incompatible or the configuration is invalid.\npub fn matmul<T>(\n    a: &(impl HostOrDeviceSlice<T> + ?Sized),\n    a_rows: u32,\n    a_cols: u32,\n    b: &(impl HostOrDeviceSlice<T> + ?Sized),\n    b_rows: u32,\n    b_cols: u32,\n    cfg: &MatMulConfig,\n    result: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    T: MatrixOps<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"matrix-transpose-api",children:"Matrix transpose API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Transposes a row-major matrix: result(i, j) = input(j, i)\n///\n/// - `input`: Source matrix of shape (rows \xd7 cols)\n/// - `result`: Output buffer of shape (cols \xd7 rows)\n/// - `cfg`: Execution configuration\npub fn matrix_transpose<T>(\n    input: &(impl HostOrDeviceSlice<T> + ?Sized),\n    nof_rows: u32,\n    nof_cols: u32,\n    cfg: &VecOpsConfig,\n    output: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    T: MatrixOps<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-4",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'    use icicle_core::traits::GenerateRandom;\n    use icicle_core::{\n        matrix_ops::{matmul, matrix_transpose, MatMulConfig},\n        vec_ops::VecOpsConfig,\n    };\n    use icicle_babykoala::polynomial_ring::PolyRing;\n    use icicle_runtime::memory::{DeviceVec, HostSlice};\n\n    let n = 8;\n    let m = 64;\n\n    // Generate a random matrix A \u2208 [n \xd7 m] on the host (row-major layout)\n    let host_a = PolyRing::generate_random((n * m) as usize);\n\n    // Allocate device buffer for A\u1d57 \u2208 [m \xd7 n]\n    let mut device_a_transposed =\n        DeviceVec::<PolyRing>::device_malloc((n * m) as usize).expect("Failed to allocate transpose output");\n\n    // Transpose A\u1d57 = transpose(A) (from host memory to device memory)\n    matrix_transpose(\n        HostSlice::from_slice(&host_a),\n        n,\n        m,\n        &VecOpsConfig::default(),\n        &mut device_a_transposed,\n    )\n    .expect("Transpose failed");\n\n    // Allocate output buffer for (A\u1d57)A \u2208 [m \xd7 m]\n    let mut device_a_transposed_a =\n        DeviceVec::<PolyRing>::device_malloc((m * m) as usize).expect("Failed to allocate output matrix");\n\n    // Compute (A\u1d57)A\n    // Note that one matrix is on host memory and the other on device memory\n    matmul(\n        &device_a_transposed,\n        m,\n        n,\n        HostSlice::from_slice(&host_a),\n        n,\n        m,\n        &MatMulConfig::default(),\n        &mut device_a_transposed_a,\n    )\n    .expect("Matmul failed");\n\n    // Compute (A\u1d57)A fused (transpose fused to matmul)\n    let mut cfg = MatMulConfig::default();\n    cfg.a_transposed = true;\n    matmul(\n        HostSlice::from_slice(&host_a),\n        n,\n        m,\n        HostSlice::from_slice(&host_a),\n        n,\n        m,\n        &cfg,\n        &mut device_a_transposed_a,\n    )\n    .expect("Matmul failed");\n'})}),"\n",(0,o.jsx)(n.h2,{id:"polynomial-ring-vector-operations",children:"Polynomial Ring Vector Operations"}),"\n",(0,o.jsx)(n.p,{children:"ICICLE provides efficient vector operations over polynomial ring slices (e.g., Rq, Tq).\nThese operations are defined generically for any type implementing the PolynomialRing trait and operate on buffers that implement the HostOrDeviceSlice trait abstraction."}),"\n",(0,o.jsx)(n.h3,{id:"supported-vecops",children:"Supported VecOps"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"polyvec_add"})," \u2013 Elementwise addition: out[i] = a[i] + b[i]"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"polyvec_sub"})," \u2013 Elementwise subtraction: out[i] = a[i] - b[i]"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"polyvec_mul"})," \u2013 Elementwise multiplication (supported only for NTT domain Tq)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"polyvec_mul_by_scalar"})," \u2013 Multiply each polynomial by a corresponding Zq scalar"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"polyvec_sum_reduce"})," \u2013 Sum all polynomials into a single output: out = \u03a3\u1d62 a[i]"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"api",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Multiply each polynomial by its corresponding scalar\npub fn polyvec_mul_by_scalar<P>(\n    input_polyvec: &(impl HostOrDeviceSlice<P> + ?Sized),\n    input_scalarvec: &(impl HostOrDeviceSlice<P::Base> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    P: PolynomialRing,\n    P::Base: VecOps<P::Base>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Elementwise multiply two vectors of polynomials (valid for NTT form `Tq`)\npub fn polyvec_mul<P>(\n    input_polyvec_a: &(impl HostOrDeviceSlice<P> + ?Sized),\n    input_polyvec_b: &(impl HostOrDeviceSlice<P> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    P: PolynomialRing,\n    P::Base: VecOps<P::Base>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Elementwise addition: result[i] = a[i] + b[i]\npub fn polyvec_add<P>(\n    input_polyvec_a: &(impl HostOrDeviceSlice<P> + ?Sized),\n    input_polyvec_b: &(impl HostOrDeviceSlice<P> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    P: PolynomialRing,\n    P::Base: VecOps<P::Base>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Elementwise subtraction: result[i] = a[i] - b[i]\npub fn polyvec_sub<P>(\n    input_polyvec_a: &(impl HostOrDeviceSlice<P> + ?Sized),\n    input_polyvec_b: &(impl HostOrDeviceSlice<P> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    P: PolynomialRing,\n    P::Base: VecOps<P::Base>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Reduce a vector to a single polynomial: result[0] = sum(a)\npub fn polyvec_sum_reduce<P>(\n    input_polyvec: &(impl HostOrDeviceSlice<P> + ?Sized),\n    result: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    P: PolynomialRing,\n    P::Base: VecOps<P::Base>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-5",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::polynomial_ring::PolynomialRing;\nuse icicle_core::traits::GenerateRandom;\nuse icicle_core::vec_ops::{\n    poly_vecops::{polyvec_mul_by_scalar, polyvec_sum_reduce},\n    VecOpsConfig,\n};\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq;\nuse icicle_babykoala::ring::ScalarRing as Zq;\nuse icicle_runtime::memory::{DeviceVec, HostSlice};\n\nlet size = 10;\n\n// Generate a random vector of Zq scalars and a vector of Rq polynomials\nlet scalars = Zq::generate_random(size);\nlet polynomials = Rq::generate_random(size);\n\n// Allocate device memory for the output of scalar \xd7 polynomial multiplication\nlet mut scaled_polynomials = DeviceVec::<Rq>::device_malloc(size).expect("Failed to allocate device memory");\n\n// Perform elementwise multiplication: result[i] = scalars[i] \xd7 polynomials[i]\npolyvec_mul_by_scalar(\n    HostSlice::from_slice(&polynomials),\n    HostSlice::from_slice(&scalars),\n    &mut scaled_polynomials,\n    &VecOpsConfig::default(),\n)\n.expect("polyvec_mul_by_scalar failed");\n\n// Allocate a single Rq element to hold the sum-reduced result\nlet mut reduced = vec![Rq::zero(); 1];\n\n// Reduce the vector of polynomials to a single polynomial by summation\npolyvec_sum_reduce(\n    &scaled_polynomials,\n    HostSlice::from_mut_slice(&mut reduced),\n    &VecOpsConfig::default(),\n)\n.expect("polyvec_sum_reduce failed");\n'})}),"\n",(0,o.jsx)(n.h2,{id:"balanced-base-decomposition",children:"Balanced Base Decomposition"}),"\n",(0,o.jsx)(n.h3,{id:"decompose-and-recompose-ring-elements",children:"Decompose and Recompose Ring Elements"}),"\n",(0,o.jsxs)(n.p,{children:["Balanced base decomposition expresses each ring element (e.g. ",(0,o.jsx)(n.code,{children:"Zq"}),", ",(0,o.jsx)(n.code,{children:"Rq"}),") as a sequence of digits in a given base ",(0,o.jsx)(n.code,{children:"b"}),", where each digit lies in the interval ",(0,o.jsx)(n.code,{children:"(-b/2, b/2]"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"output-layout",children:"Output Layout"}),"\n",(0,o.jsxs)(n.p,{children:["For an input slice of ",(0,o.jsx)(n.code,{children:"n"})," elements and a digit count ",(0,o.jsx)(n.code,{children:"d = count_digits(base)"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The output vector has length ",(0,o.jsx)(n.code,{children:"n \xd7 d"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The layout is ",(0,o.jsx)(n.strong,{children:"digit-major"})," (not element-major):","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The first ",(0,o.jsx)(n.code,{children:"n"})," entries are the ",(0,o.jsx)(n.strong,{children:"first digit"})," of all elements."]}),"\n",(0,o.jsxs)(n.li,{children:["The next ",(0,o.jsx)(n.code,{children:"n"})," entries are the ",(0,o.jsx)(n.strong,{children:"second digit"})," of all elements."]}),"\n",(0,o.jsxs)(n.li,{children:["And so on, until all ",(0,o.jsx)(n.code,{children:"d"})," digits are emitted."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Conceptually, this forms a matrix of shape ",(0,o.jsx)(n.code,{children:"[d \xd7 n]"}),", where each row corresponds to a digit index and each column to an element."]}),"\n",(0,o.jsxs)(n.li,{children:["If you allocate fewer than ",(0,o.jsx)(n.code,{children:"d"})," digit rows (i.e., a shorter output buffer), decomposition will truncate early.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Warning"}),": recomposition will only reconstruct the original values correctly if all omitted most significant digits were zero."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"main-imports-2",children:"Main Imports"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::balanced_decomposition::{\n    decompose,            // Decomposition function\n    recompose,            // Recomposition function\n    count_digits,         // Compute number of digits needed\n    BalancedDecomposition // Trait for custom rings\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"api-1",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Returns the number of digits required to represent a ring element in balanced base-`b` form.\n///\n/// Each digit lies in the interval (-b/2, b/2], and the number of digits depends on the modulus.\npub fn count_digits<T: BalancedDecomposition<T>>(base: u32) -> u32\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Decomposes a slice of elements into balanced base-`b` digits (digit-major layout).\n///\n/// - `input.len()` = number of elements to decompose\n/// - `output.len()` must be `input.len() \xd7 num_digits`, where `num_digits \u2208 [1, count_digits(base)]`\n///\n/// Digits are written in order of increasing significance, grouped by digit index.\npub fn decompose<T: BalancedDecomposition<T>>(\n    input: &(impl HostOrDeviceSlice<T> + ?Sized),\n    output: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n    base: u32,\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    T: BalancedDecomposition<T>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Recomposes original elements from digit-major base-`b` decomposition.\n///\n/// - `input.len()` must be `output.len() \xd7 num_digits`, where `num_digits \u2208 [1, count_digits(base)]`\n///\n/// Recomposition is exact only if all omitted higher-order digits were zero.\npub fn recompose<T: BalancedDecomposition<T>>(\n    input: &(impl HostOrDeviceSlice<T> + ?Sized),\n    output: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n    base: u32,\n    cfg: &VecOpsConfig,\n) -> Result<(), IcicleError>\nwhere\n    T: BalancedDecomposition<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::balanced_decomposition;\nuse icicle_core::traits::GenerateRandom;\nuse icicle_core::vec_ops::VecOpsConfig;\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq;\nuse icicle_runtime::memory::{DeviceVec, HostSlice};\n\nlet base = 4; // Typically set to q^(1/t) for small t (e.g., t = 2, 4, 6)\nlet size = 1024;\n// Compute number of digits per element for the given base\nlet digits = balanced_decomposition::count_digits::<Rq>(base);\nlet output_len = size * digits as usize;\n\n// Generate input vector\nlet input = Rq::generate_random(size);\n\n// Allocate device memory for digit-major output\nlet mut decomposed = DeviceVec::<Rq>::device_malloc(output_len).expect("Failed to allocate device memory");\n\n// Perform balanced base decomposition\nbalanced_decomposition::decompose::<Rq>(\n    HostSlice::from_slice(&input),\n    &mut decomposed,\n    base,\n    &VecOpsConfig::default(),\n)\n.expect("Decomposition failed");\n'})}),"\n",(0,o.jsx)(n.h2,{id:"norm-bound-checking",children:"Norm Bound Checking"}),"\n",(0,o.jsxs)(n.p,{children:["ICICLE provides an API to check whether the norm of a ",(0,o.jsx)(n.code,{children:"Zq"})," vector is within a specified bound."]}),"\n",(0,o.jsx)(n.p,{children:"The API supports:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"\u2113\u2082 norm checking (sum of squares)"}),"\n",(0,o.jsx)(n.li,{children:"\u2113\u221e norm checking (maximum absolute value)"}),"\n",(0,o.jsx)(n.li,{children:"Batch support"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"main-imports-3",children:"Main Imports"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::norm::{\n    check_norm_bound, // Public wrapper function\n    NormType,          // Enum to select \u2113\u2082 or \u2113\u221e norm\n    Norm,              // Trait implemented per field type\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"api-2",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"pub enum NormType {\n    /// \u2113\u2082 norm: sqrt(sum of squares)\n    L2,\n    /// \u2113\u221e norm: max absolute value\n    LInfinity,\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Checks whether the norm of a vector (or batch of vectors) is within a given bound.\n///\n/// - `input`: Input slice of field elements (`Zq`)\n/// - `norm_type`: `L2` or `LInfinity`\n/// - `norm_bound`: The norm upper bound\n/// - `cfg`: execution configuration\n/// - `output`: Boolean results per batch\n///\n/// Interpretation:\n/// - If `output.len() == 1`, checks the full input vector\n/// - If `output.len() == B`, input is treated as `B` contiguous vectors (input.len() must be divisible by B)\npub fn check_norm_bound<T: IntegerRing>(\n    input: &(impl HostOrDeviceSlice<T> + ?Sized),\n    norm_type: NormType,\n    norm_bound: u64,\n    cfg: &VecOpsConfig,\n    output: &mut (impl HostOrDeviceSlice<bool> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    T: Norm<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-6",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::{bignum::BigNum, norm, vec_ops::VecOpsConfig};\nuse icicle_babykoala::ring::ScalarRing as Zq;\nuse icicle_runtime::memory::HostSlice;\n\nlet size = 1024;\nlet batch = 4;\nlet bound = 1000;\n\nlet input: Vec<Zq> = (0..size)\n    .map(Zq::from_u32)\n    .collect();\nlet mut output = vec![false; batch];\n\nlet cfg = VecOpsConfig::default();\n\n// Interpretation:\n// If output has 4 elements, the input is split into 4 sub-vectors (256 each).\n// Norm is computed per sub-vector.\nnorm::check_norm_bound(\n    HostSlice::from_slice(&input),\n    norm::NormType::L2, // or NormType::LInfinity\n    bound,\n    &cfg,\n    HostSlice::from_mut_slice(&mut output),\n)\n.expect("Norm check failed");\n\n// Output[i] == true indicates that sub-vector i passed the norm bound.\n'})}),"\n",(0,o.jsx)(n.h2,{id:"johnsonlindenstrauss-jl-projection",children:"Johnson\u2013Lindenstrauss (JL) Projection"}),"\n",(0,o.jsx)(n.p,{children:"ICICLE provides APIs for performing Johnson\u2013Lindenstrauss (JL) projections, which reduce high-dimensional vectors into lower-dimensional spaces using pseudo-random sparse matrices."}),"\n",(0,o.jsx)(n.h3,{id:"supported-capabilities",children:"Supported Capabilities"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Seed-based projection of a vector of ",(0,o.jsx)(n.code,{children:"Zq"})," elements using a sparse matrix with values in ",(0,o.jsx)(n.code,{children:"{\u22121, 0, 1}"})]}),"\n",(0,o.jsxs)(n.li,{children:["Seed-based projection of a vector of ",(0,o.jsx)(n.code,{children:"Rq"})," elements by reinterpreting them as ",(0,o.jsx)(n.code,{children:"Zq"})," coefficients"]}),"\n",(0,o.jsxs)(n.li,{children:["Querying JL projection matrix rows deterministically:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["As raw ",(0,o.jsx)(n.code,{children:"Zq"})," values (for verification)"]}),"\n",(0,o.jsxs)(n.li,{children:["As grouped ",(0,o.jsx)(n.code,{children:"Rq"})," polynomials, with optional conjugation (",(0,o.jsx)(n.code,{children:"a(X) \u2192 a(X\u207b\xb9) mod X\u207f + 1"}),") \u2014 useful for proof systems that prove the projection is computed correctly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"main-imports-4",children:"Main imports"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::jl_projection::{\n    jl_projection, \n    get_jl_matrix_rows,\n    get_jl_matrix_rows_as_polyring,\n    JLProjection,\n    JLProjectionPolyRing\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"api-3",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Projects a scalar vector into a lower-dimensional space using a pseudo-random JL matrix.\n///\n/// - `input.len()` = original dimensionality\n/// - `output_projection.len()` = target dimensionality\n/// - Projection matrix is seeded deterministically from `seed`\npub fn jl_projection<T>(\n    input: &(impl HostOrDeviceSlice<T> + ?Sized),\n    seed: &[u8],\n    cfg: &VecOpsConfig,\n    output_projection: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    T: IntegerRing,\n    T: JLProjection<T>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Retrieves raw JL matrix rows over the scalar ring `T` in row-major order.\n///\n/// - Output layout: row 0 | row 1 | ... | row `num_rows - 1`\n/// - Each row contains `row_size` scalar elements\npub fn get_jl_matrix_rows<T>(\n    seed: &[u8],\n    row_size: usize,\n    start_row: usize,\n    num_rows: usize,\n    cfg: &VecOpsConfig,\n    output_rows: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    T: IntegerRing,\n    T: JLProjection<T>;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Retrieves JL matrix rows as `Rq` polynomials, optionally conjugated.\n///\n/// - Each row contains `row_size` polynomials of degree `P::DEGREE`\n/// - If `conjugate = true`, applies a(X) \u21a6 a(X\u207b\xb9) mod X\u207f + 1 to each polynomial\n/// - Output is laid out row-major: row 0 | row 1 | ...\npub fn get_jl_matrix_rows_as_polyring<P>(\n    seed: &[u8],\n    row_size: usize,\n    start_row: usize,\n    num_rows: usize,\n    conjugate: bool,\n    cfg: &VecOpsConfig,\n    output_rows: &mut (impl HostOrDeviceSlice<P> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    P: PolynomialRing + JLProjectionPolyRing<P>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-7",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::vec_ops::VecOpsConfig;\nuse icicle_core::{\n    bignum::BigNum,\n    jl_projection,\n    polynomial_ring::{flatten_polyring_slice, PolynomialRing},\n    traits::GenerateRandom,\n};\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq;\nuse icicle_babykoala::ring::ScalarRing as Zq;\nuse icicle_runtime::memory::{HostOrDeviceSlice, HostSlice};\nuse rand::Rng;\n\n// Project a vector of Rq polyonmials\n// Projecting 128 Rq polynomials (each of degree 64) to a 256-element Zq vector\nlet polynomials = Rq::generate_random(128);\nlet mut projection = vec![Zq::zero(); 256];\n\n// Flatten the polynomials into a contiguous Zq slice (128 \xd7 64 elements)\nlet flat_polynomials_as_zq = flatten_polyring_slice(HostSlice::from_slice(&polynomials));\n\n// Use a random seed (e.g., hash of transcript or Fiat\u2013Shamir challenge)\nlet mut seed = [0u8; 32];\nrand::thread_rng().fill(&mut seed);\n\n// Perform JL projection\njl_projection::jl_projection(\n    &flat_polynomials_as_zq,\n    &seed,\n    &VecOpsConfig::default(),\n    HostSlice::from_mut_slice(&mut projection),\n)\n.expect("JL projection failed");\n\n// -----------------------------------------------------------------------------\n// \ud83d\udd0d Matrix Inspection (Zq form)\n// -----------------------------------------------------------------------------\n\n// Retrieve the first row of the JL matrix as Zq elements\nlet row_size = flat_polynomials_as_zq.len(); // same as input dimension\nlet mut output_rows = vec![Zq::zero(); row_size]; // 1 row \xd7 row_size elements\n\njl_projection::get_jl_matrix_rows(\n    &seed,\n    row_size, // row size (input dimension)\n    0,        // start_row\n    1,        // number of rows\n    &VecOpsConfig::default(),\n    HostSlice::from_mut_slice(&mut output_rows),\n)\n.expect("Failed to generate JL matrix rows as Zq");\n\n// -----------------------------------------------------------------------------\n// \ud83d\udd01 Matrix Inspection (Rq form, with conjugation)\n// -----------------------------------------------------------------------------\n\nlet mut output_rows_as_poly = vec![Rq::zero(); polynomials.len()]; // 1 row of polynomials\n\njl_projection::get_jl_matrix_rows_as_polyring(\n    &seed,\n    polynomials.len(), // row size (number of polynomials per row)\n    0,                 // start_row\n    1,                 // number of rows\n    true,              // apply polynomial conjugation\n    &VecOpsConfig::default(),\n    HostSlice::from_mut_slice(&mut output_rows_as_poly),\n)\n.expect("Failed to generate JL matrix rows as Rq (conjugated)");\n'})}),"\n",(0,o.jsx)(n.h2,{id:"seeded-random-sampling",children:"Seeded Random Sampling"}),"\n",(0,o.jsx)(n.p,{children:"ICICLE provides an API for pseudorandom sampling of Zq and Rq elements on the device. This is useful for generating secret vectors, noise, or challenge polynomials in zero-knowledge protocols."}),"\n",(0,o.jsx)(n.h3,{id:"main-imports-5",children:"Main imports"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::random_sampling;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"api-4",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Randomly samples elements of type `T` from a seeded uniform distribution.\n///\n/// This function fills the `output` buffer with pseudorandom elements of type `T`,\n/// using the given `seed`.\n/// \n/// # Parameters\n/// - `fast_mode`:  Whether to use fast (non-cryptographic) sampling or secure sampling.\n/// - `seed`:  byte slice used to deterministically seed the pseudorandom generator.\n/// - `cfg`: execution configuration\n/// - `output`:  Output buffer to store sampled elements\npub fn random_sampling<T>(\n    fast_mode: bool,\n    seed: &[u8],\n    cfg: &VecOpsConfig,\n    output: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n) -> Result<(), IcicleError>\nwhere    \n    T: RandomSampling<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-8",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::{polynomial_ring::flatten_polyring_slice_mut, random_sampling, vec_ops::VecOpsConfig};\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq;\nuse icicle_babykoala::ring::ScalarRing as Zq;\nuse icicle_runtime::memory::DeviceVec;\nuse rand::RngCore;\n\nlet size = 4096;\nlet fast_mode = true;\nlet cfg = VecOpsConfig::default();\n\n// Generate a non-zero 32-byte seed for deterministic sampling\nlet mut seed = [0u8; 32];\nrand::thread_rng().fill_bytes(&mut seed);\n\n// --- Sample Zq elements ---\nlet mut zq_output = DeviceVec::<Zq>::device_malloc(size).expect("Zq alloc failed");\nrandom_sampling::random_sampling(fast_mode, &seed, &cfg, &mut zq_output).expect("Zq sampling failed");\n\n// --- Sample Rq polynomials ---\nlet mut rq_output = DeviceVec::<Rq>::device_malloc(size).expect("Rq alloc failed");\n{\n    // This scope is not necessary but we prefer to explicitly end the lifetime of the rq_as_zq reference\n    let mut rq_as_zq = flatten_polyring_slice_mut(&mut rq_output);\n    random_sampling::random_sampling(fast_mode, &seed, &cfg, &mut rq_as_zq).expect("Rq sampling failed");\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"challenge-sampling-with-operator-norm-rejection",children:"Challenge Sampling with Operator Norm Rejection"}),"\n",(0,o.jsxs)(n.p,{children:["ICICLE provides a specialized API to sample challenge polynomials from a constrained subset of ",(0,o.jsx)(n.code,{children:"Rq"})," that meet strict norm bounds. This is particularly relevant for lattice-based SNARK protocols like ",(0,o.jsx)(n.strong,{children:"labrador"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The challenge space consists of Rq polynomials with:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A fixed number of coefficients equal to \xb11 (tau1)"}),"\n",(0,o.jsx)(n.li,{children:"A fixed number of coefficients equal to \xb12 (tau2)"}),"\n",(0,o.jsx)(n.li,{children:"All remaining coefficients set to 0"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The resulting polynomial is accepted only if it satisfies:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"An L-opnorm (operator norm) bound"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Sampling is ",(0,o.jsx)(n.strong,{children:"deterministic"})," and based on a seed and output index. Polynomials exceeding the bound are rejected, and retries are performed deterministically to ensure reproducibility across devices and backends."]}),"\n",(0,o.jsx)(n.h3,{id:"main-imports-6",children:"Main imports"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use icicle_core::random_sampling::{\n    challenge_space_polynomials_sampling,  // Sampling function    \n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"api-5",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"/// Samples `Rq` challenge polynomials with coefficients in {0, \xb11, \xb12}.\n///\n/// This function generates polynomials from a constrained challenge space:\n/// 1. Initializes each polynomial with `ones` coefficients set to \xb11\n///    and `twos` coefficients set to \xb12 (randomly signed).\n/// 2. Applies a random permutation to the coefficients.\n/// 3. If `norm > 0`, applies operator norm rejection: only polynomials\n///    with operator norm \u2264 `norm` are accepted.\n///\n/// Sampling is deterministic based on the seed and internal indexing.\n/// The output is a flat slice of polynomials (e.g., `&mut [T]` where `T: PolynomialRing`).\npub fn challenge_space_polynomials_sampling<T>(\n    seed: &[u8],\n    cfg: &VecOpsConfig,\n    ones: usize,\n    twos: usize,\n    norm: usize,\n    output: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n) -> Result<(), IcicleError>\nwhere\n    T: PolynomialRing,\n    T: ChallengeSpacePolynomialsSampling<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-9",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use icicle_core::random_sampling::challenge_space_polynomials_sampling;\nuse icicle_core::vec_ops::VecOpsConfig;\nuse icicle_babykoala::polynomial_ring::PolyRing as Rq;\nuse icicle_runtime::memory::DeviceVec;\nuse rand::RngCore;\n\n// Parameters from the labrador protocol\nlet tau1 = 31;           // Number of \xb11 coefficients\nlet tau2 = 10;           // Number of \xb12 coefficients\nlet opnorm_bound = 15;   // Operator norm bound for rejection sampling\nlet num_polynomials = 16;\n\n// Generate a non-zero 60-byte deterministic seed (any seed size is valid)\nlet mut seed = [0u8; 60];\nrand::thread_rng().fill_bytes(&mut seed);\n\n// Allocate device memory for the output polynomials\nlet mut output = DeviceVec::<Rq>::device_malloc(num_polynomials)\n    .expect("Failed to allocate device memory");\n\n// Sample challenge polynomials with norm-based rejection\nchallenge_space_polynomials_sampling(\n    &seed,\n    &VecOpsConfig::default(),\n    tau1,\n    tau2,\n    opnorm_bound, // Set to 0 to skip norm filtering\n    &mut output,\n)\n.expect("Challenge space sampling failed");\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>t});var l=i(96540);const o={},s=l.createContext(o);function r(e){const n=l.useContext(s);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),l.createElement(s.Provider,{value:n},e.children)}}}]);
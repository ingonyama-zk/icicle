"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[5783],{95896:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"icicle/primitives/fri","title":"FRI API Documentation","description":"Overview","source":"@site/versioned_docs/version-3.7.0/icicle/primitives/fri.md","sourceDirName":"icicle/primitives","slug":"/icicle/primitives/fri","permalink":"/icicle/primitives/fri","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-3.7.0/icicle/primitives/fri.md","tags":[],"version":"3.7.0","lastUpdatedBy":"ShaniBabayoff","lastUpdatedAt":1744629504000,"frontMatter":{},"sidebar":"GettingStartedSidebar","previous":{"title":"Sumcheck","permalink":"/icicle/primitives/sumcheck"},"next":{"title":"Pairings","permalink":"/icicle/primitives/pairings"}}');var i=n(74848),a=n(28453);const l={},t="FRI API Documentation",c={},o=[{value:"Overview",id:"overview",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"Prover",id:"prover",level:3},{value:"Commit and Fold Phase",id:"commit-and-fold-phase",level:4},{value:"Proof of Work Phase (Optional)",id:"proof-of-work-phase-optional",level:4},{value:"Query Phase",id:"query-phase",level:4},{value:"Verifier",id:"verifier",level:3},{value:"C++ API",id:"c-api",level:2},{value:"Configuration structs",id:"configuration-structs",level:3},{value:"FriConfig",id:"friconfig",level:4},{value:"FriTranscriptConfig",id:"fritranscriptconfig",level:4},{value:"Generating FRI Proofs",id:"generating-fri-proofs",level:3},{value:"Example: Generating a Proof",id:"example-generating-a-proof",level:4},{value:"Verifying Fri Proofs",id:"verifying-fri-proofs",level:3},{value:"Example: Verifying a Proof",id:"example-verifying-a-proof",level:4}];function h(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"fri-api-documentation",children:"FRI API Documentation"})}),"\n",(0,i.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(s.p,{children:"The Fast Reed-Solomon Interactive Oracle Proof of Proximity (FRI) protocol is used to efficiently verify that a given polynomial has a bounded degree."}),"\n",(0,i.jsx)(s.p,{children:"The Prover asserts that they know a low-degree polynomial F(x) of degree d, and they provide oracle access to a Reed-Solomon (RS) codeword representing evaluations of this polynomial over a domain L:"}),"\n",(0,i.jsx)(s.span,{className:"katex-display",children:(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"R"}),(0,i.jsx)(s.mi,{children:"S"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"F"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"x"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mo,{separator:"true",children:","}),(0,i.jsx)(s.mi,{children:"L"}),(0,i.jsx)(s.mo,{separator:"true",children:","}),(0,i.jsx)(s.mi,{children:"n"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mo,{children:"="}),(0,i.jsx)(s.mo,{stretchy:"false",children:"{"}),(0,i.jsx)(s.mi,{children:"F"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mn,{children:"1"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mo,{separator:"true",children:","}),(0,i.jsx)(s.mi,{children:"F"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsx)(s.mi,{children:"\u03b1"}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mo,{separator:"true",children:","}),(0,i.jsx)(s.mi,{children:"F"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsxs)(s.msup,{children:[(0,i.jsx)(s.mi,{children:"\u03b1"}),(0,i.jsx)(s.mn,{children:"2"})]}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mo,{separator:"true",children:","}),(0,i.jsx)(s.mi,{mathvariant:"normal",children:"."}),(0,i.jsx)(s.mi,{mathvariant:"normal",children:"."}),(0,i.jsx)(s.mi,{mathvariant:"normal",children:"."}),(0,i.jsx)(s.mo,{separator:"true",children:","}),(0,i.jsx)(s.mi,{children:"F"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"("}),(0,i.jsxs)(s.msup,{children:[(0,i.jsx)(s.mi,{children:"\u03b1"}),(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"n"}),(0,i.jsx)(s.mo,{children:"\u2212"}),(0,i.jsx)(s.mn,{children:"1"})]})]}),(0,i.jsx)(s.mo,{stretchy:"false",children:")"}),(0,i.jsx)(s.mo,{stretchy:"false",children:"}"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"RS(F(x), L, n) = \\{F(1), F(\\alpha), F(\\alpha^2), ..., F(\\alpha^{n-1})\\}"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"RS"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"x"}),(0,i.jsx)(s.span,{className:"mclose",children:")"}),(0,i.jsx)(s.span,{className:"mpunct",children:","}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"L"}),(0,i.jsx)(s.span,{className:"mpunct",children:","}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(s.span,{className:"mclose",children:")"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(s.span,{className:"mrel",children:"="}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"1.1141em",verticalAlign:"-0.25em"}}),(0,i.jsx)(s.span,{className:"mopen",children:"{"}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord",children:"1"}),(0,i.jsx)(s.span,{className:"mclose",children:")"}),(0,i.jsx)(s.span,{className:"mpunct",children:","}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"}),(0,i.jsx)(s.span,{className:"mclose",children:")"}),(0,i.jsx)(s.span,{className:"mpunct",children:","}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsx)(s.span,{className:"vlist-t",children:(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.8641em"},children:(0,i.jsxs)(s.span,{style:{top:"-3.113em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(s.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,i.jsx)(s.span,{className:"mclose",children:")"}),(0,i.jsx)(s.span,{className:"mpunct",children:","}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(s.span,{className:"mord",children:"..."}),(0,i.jsx)(s.span,{className:"mpunct",children:","}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,i.jsx)(s.span,{className:"mopen",children:"("}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"\u03b1"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsx)(s.span,{className:"vlist-t",children:(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.8641em"},children:(0,i.jsxs)(s.span,{style:{top:"-3.113em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(s.span,{className:"mord mtight",children:[(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"n"}),(0,i.jsx)(s.span,{className:"mbin mtight",children:"\u2212"}),(0,i.jsx)(s.span,{className:"mord mtight",children:"1"})]})})]})})})})})]}),(0,i.jsx)(s.span,{className:"mclose",children:")}"})]})]})]})}),"\n",(0,i.jsxs)(s.p,{children:["where \u03b1 is a primitive root of unity, and ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"n"}),(0,i.jsx)(s.mo,{children:"="}),(0,i.jsxs)(s.msup,{children:[(0,i.jsx)(s.mn,{children:"2"}),(0,i.jsx)(s.mi,{children:"l"})]})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"n = 2^l"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(s.span,{className:"mrel",children:"="}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8491em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord",children:"2"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsx)(s.span,{className:"vlist-t",children:(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.8491em"},children:(0,i.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.01968em"},children:"l"})})]})})})})})]})]})]})]})," (for ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"l"}),(0,i.jsx)(s.mo,{children:"\u2208"}),(0,i.jsx)(s.mi,{children:"Z"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"l \u2208 Z"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.7335em",verticalAlign:"-0.0391em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(s.span,{className:"mrel",children:"\u2208"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"})]})]})]}),") is the domain size."]}),"\n",(0,i.jsx)(s.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsx)(s.p,{children:"The proof construction consists of three phases: the Commit and Fold Phase, the Proof of Work Phase (optional), and the Query Phase.\nUsing a Fiat-Shamir (FS) scheme, the proof is generated in a non-interactive manner, enabling the Prover to generate the entire proof and send it to the Verifier for validation.\nThe polynomial size must be a power of 2 and is passed to the protocol in evaluation form."}),"\n",(0,i.jsx)(s.h3,{id:"prover",children:"Prover"}),"\n",(0,i.jsx)(s.h4,{id:"commit-and-fold-phase",children:"Commit and Fold Phase"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"The prover commits to the polynomial evaluations by constructing a Merkle tree."}),"\n",(0,i.jsx)(s.li,{children:"A folding step is performed iteratively to reduce the polynomial degree."}),"\n",(0,i.jsx)(s.li,{children:"In each step, the polynomial is rewritten using random coefficients derived from Fiat-Shamir hashing, and a new Merkle tree is built for the reduced polynomial."}),"\n",(0,i.jsx)(s.li,{children:"This process continues recursively until the polynomial reaches a minimal length."}),"\n",(0,i.jsx)(s.li,{children:"Currently, only a folding factor of 2 is supported."}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"proof-of-work-phase-optional",children:"Proof of Work Phase (Optional)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"If enabled, the prover is required to find a nonce such that, when hashed with the final Merkle tree root, the result meets a certain number of leading zero bits."}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"query-phase",children:"Query Phase"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Using the Fiat-Shamir transform, the prover determines the random query indices based on the previously committed Merkle roots."}),"\n",(0,i.jsx)(s.li,{children:"For each sampled index, the prover provides the corresponding Merkle proof, showing that the value is part of the committed Merkle tree."}),"\n",(0,i.jsx)(s.li,{children:"The prover returns all required data as the FriProof, which is then verified by the verifier."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"verifier",children:"Verifier"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"The verifier checks the Merkle proofs to ensure the sampled values were indeed committed to in the commit phase."}),"\n",(0,i.jsx)(s.li,{children:"The verifier reconstructs the Fiat-Shamir challenges from the prover's commitments and verifies that the prover followed the protocol honestly."}),"\n",(0,i.jsx)(s.li,{children:"The folding relation is checked for each sampled query."}),"\n",(0,i.jsx)(s.li,{children:"If all checks pass, the proof is accepted as valid."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"c-api",children:"C++ API"}),"\n",(0,i.jsx)(s.h3,{id:"configuration-structs",children:"Configuration structs"}),"\n",(0,i.jsx)(s.p,{children:"There are two key configuration structs related to the Fri protocol."}),"\n",(0,i.jsx)(s.h4,{id:"friconfig",children:"FriConfig"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"FriConfig"})," struct is used to specify parameters for the FRI protocol. It contains the following fields:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"stream: icicleStreamHandle"})}),": The CUDA stream for asynchronous execution. If ",(0,i.jsx)(s.code,{children:"nullptr"}),", the default stream is used."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"folding_factor: size_t"})}),": The factor by which the codeword is folded in each round."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"stopping_degree: size_t"})}),": The minimal polynomial degree at which folding stops."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"pow_bits: size_t"})}),": Number of leading zeros required for proof-of-work. If set, the optional proof-of-work phase is executed."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"nof_queries: size_t"})}),": Number of queries computed for each folded layer of FRI."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"are_inputs_on_device: bool"})}),": If true, the input polynomials are stored on the device (e.g., GPU); otherwise, they remain on the host (e.g., CPU)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"is_async: bool"})}),": If true, it runs the hash asynchronously."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"ext: ConfigExtension*"})}),": Backend-specific extensions."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The default values are:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// icicle/fri/fri_config.h\nstruct FriConfig {\n  icicleStreamHandle stream = nullptr;\n  size_t folding_factor = 2;\n  size_t stopping_degree = 0;\n  size_t pow_bits = 16;\n  size_t nof_queries = 100;\n  bool are_inputs_on_device = false;\n  bool is_async = false;\n  ConfigExtension* ext = nullptr;\n};\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsx)(s.p,{children:"Currently, only a folding factor of 2 is supported."})}),"\n",(0,i.jsx)(s.h4,{id:"fritranscriptconfig",children:"FriTranscriptConfig"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"FriTranscriptConfig<TypeParam>"})," class is used to specify parameters for the Fiat-Shamir scheme used by the FRI protocol. It contains the following fields:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"hasher: Hash"})}),": The hash function used to generate randomness for Fiat-Shamir."]}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"domain_separator_label: std::vector<std::byte>"})})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"round_challenge_label: std::vector<std::byte>"})})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"commit_phase_label: std::vector<std::byte>"})})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"nonce_label: std::vector<std::byte>"})})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"public_state: std::vector<std::byte>"})})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"seed_rng: TypeParam"})}),": The seed for initializing the RNG."]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsx)(s.p,{children:"The encoding is little endian."})}),"\n",(0,i.jsxs)(s.p,{children:["There are three constructors for ",(0,i.jsx)(s.code,{children:"FriTranscriptConfig<TypeParam>"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Default constructor"}),":"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// icicle/fri/fri_transcript_config.h\nFriTranscriptConfig()\n  : m_hasher(create_keccak_256_hash()), m_domain_separator_label({}), m_commit_phase_label({}), m_nonce_label({}),\n    m_public({}), m_seed_rng(F::zero())\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Constructor with byte vector for labels"}),":"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"FriTranscriptConfig(\n  Hash hasher,\n  std::vector<std::byte>&& domain_separator_label,\n  std::vector<std::byte>&& round_challenge_label,\n  std::vector<std::byte>&& commit_phase_label,\n  std::vector<std::byte>&& nonce_label,\n  std::vector<std::byte>&& public_state,\n  F seed_rng)\n    : m_hasher(std::move(hasher)), m_domain_separator_label(std::move(domain_separator_label)),\n      m_round_challenge_label(std::move(round_challenge_label)),\n      m_commit_phase_label(std::move(commit_phase_label)), m_nonce_label(std::move(nonce_label)),\n      m_public(std::move(public_state)), m_seed_rng(seed_rng)\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:["Constructor with ",(0,i.jsx)(s.code,{children:"const char*"})," arguments for labels"]}),":"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"    FriTranscriptConfig(\n      Hash hasher,\n      const char* domain_separator_label,\n      const char* round_challenge_label,\n      const char* commit_phase_label,\n      const char* nonce_label,\n      std::vector<std::byte>&& public_state,\n      F seed_rng)\n        : m_hasher(std::move(hasher)), m_domain_separator_label(cstr_to_bytes(domain_separator_label)),\n          m_round_challenge_label(cstr_to_bytes(round_challenge_label)),\n          m_commit_phase_label(cstr_to_bytes(commit_phase_label)), m_nonce_label(cstr_to_bytes(nonce_label)),\n          m_public(std::move(public_state)), m_seed_rng(seed_rng)\n"})}),"\n",(0,i.jsx)(s.h3,{id:"generating-fri-proofs",children:"Generating FRI Proofs"}),"\n",(0,i.jsxs)(s.p,{children:["To generate a proof, first, an empty proof needs to be created. The FRI proof is represented by the ",(0,i.jsx)(s.code,{children:"FriProof<TypeParam>"})," class:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// icicle/fri/fri_proof.h\ntemplate <typename F>\nclass FriProof\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The class has a default constructor ",(0,i.jsx)(s.code,{children:"FriProof()"})," that takes no arguments."]}),"\n",(0,i.jsx)(s.p,{children:"To generate a FRI proof using the Merkle Tree commit scheme, use one of the following functions:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:["Directly call ",(0,i.jsx)(s.code,{children:"prove_fri_merkle_tree"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"template <typename F>\neIcicleError prove_fri_merkle_tree(\n    const FriConfig& fri_config,\n    const FriTranscriptConfig<F>& fri_transcript_config,\n    const F* input_data,\n    const size_t input_size,\n    Hash merkle_tree_leaves_hash,\n    Hash merkle_tree_compress_hash,\n    const uint64_t output_store_min_layer,\n    FriProof<F>& fri_proof /* OUT */);\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:["Use the ",(0,i.jsx)(s.code,{children:"fri_merkle_tree"})," namespace, which internally calls ",(0,i.jsx)(s.code,{children:"prove_fri_merkle_tree"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"fri_merkle_tree::prove<TypeParam>( ... );\n"})}),"\n","This approach calls ",(0,i.jsx)(s.code,{children:"prove_fri_merkle_tree"})," internally but provides a more structured way to access it."]}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"input_data: const F*"})}),": Evaluations of The input polynomial."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"fri_proof: FriProof<F>&"})}),": The output ",(0,i.jsx)(s.code,{children:"FriProof"})," object containing the generated proof."]}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"merkle_tree_leaves_hash"}),", ",(0,i.jsx)(s.code,{children:"merkle_tree_compress_hash"})," and ",(0,i.jsx)(s.code,{children:"output_store_min_layer"})," refer to the hashes used in the Merkle Trees built in each round of the folding. For further information about ICICLE's Merkle Trees, see ",(0,i.jsx)(s.a,{href:"/icicle/primitives/merkle",children:"Merkle-Tree documentation"})," and ",(0,i.jsx)(s.a,{href:"/icicle/primitives/merkle",children:"Hash documentation"}),"."]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"folding_factor"})," must be divisible by ",(0,i.jsx)(s.code,{children:"merkle_tree_compress_hash"}),"."]})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["An NTT domain is used for proof generation, so before generating a proof, an NTT domain of at least the input_data size must be initialized. For more information see ",(0,i.jsx)(s.a,{href:"/icicle/primitives/ntt",children:"NTT documentation"}),"."]})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"NTTInitDomainConfig init_domain_config = default_ntt_init_domain_config();\nntt_init_domain(scalar_t::omega(log_input_size), init_domain_config)\n"})}),"\n",(0,i.jsx)(s.p,{children:":::"}),"\n",(0,i.jsx)(s.h4,{id:"example-generating-a-proof",children:"Example: Generating a Proof"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:'// Initialize ntt domain\nNTTInitDomainConfig init_domain_config = default_ntt_init_domain_config();\nntt_init_domain(scalar_t::omega(log_input_size), init_domain_config);\n\n// Define hashers for merkle tree\nuint64_t merkle_tree_arity = 2;\nHash hash = Keccak256::create(sizeof(TypeParam));                          // hash element -> 32B\nHash compress = Keccak256::create(merkle_tree_arity * hash.output_size()); // hash every 64B to 32B\n\n// set transcript config\nconst char* domain_separator_label = "domain_separator_label";\nconst char* round_challenge_label = "round_challenge_label";\nconst char* commit_phase_label = "commit_phase_label";\nconst char* nonce_label = "nonce_label";\nstd::vector<std::byte>&& public_state = {};\nTypeParam seed_rng = TypeParam::one();\n\nFriTranscriptConfig<TypeParam> transcript_config(\n  hash, domain_separator_label, round_challenge_label, commit_phase_label, nonce_label, std::move(public_state),\n  seed_rng);\n\n// set fri config\nFriConfig fri_config;\nfri_config.nof_queries = 100;\nfri_config.pow_bits = 16;\nfri_config.folding_factor = 2;\nfri_config.stopping_degree = 0;\n\nFriProof<TypeParam> fri_proof;\n\n// get fri proof\neIcicleError err = fri_merkle_tree::prove<TypeParam>(\n  fri_config, transcript_config, scalars.get(), input_size, hash, compress, output_store_min_layer, fri_proof);\nICICLE_CHECK(err);\n\n// Release ntt domain\nntt_release_domain<scalar_t>();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"verifying-fri-proofs",children:"Verifying Fri Proofs"}),"\n",(0,i.jsx)(s.p,{children:"To verify the FRI proof using the Merkle Tree commit scheme, use one of the following functions:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:["Directly call ",(0,i.jsx)(s.code,{children:"verify_fri_merkle_tree"})]}),":"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// icicle/fri/fri.h\ntemplate <typename F>\neIcicleError verify_fri_merkle_tree(\n    const FriConfig& fri_config,\n    const FriTranscriptConfig<F>& fri_transcript_config,\n    FriProof<F>& fri_proof,\n    Hash merkle_tree_leaves_hash,\n    Hash merkle_tree_compress_hash,\n    bool& valid /* OUT */);\n"})}),"\n",(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsxs)(s.strong,{children:["Use the ",(0,i.jsx)(s.code,{children:"fri_merkle_tree"})," namespac, which internally calls ",(0,i.jsx)(s.code,{children:"verify_fri_merkle_tree"}),":"]})}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"fri_merkle_tree::verify<TypeParam>( ... );\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"FriConfig"})," and ",(0,i.jsx)(s.code,{children:"FriTranscriptConfig"})," used for generating the proof must be identical to the one used for verification."]})}),"\n",(0,i.jsx)(s.h4,{id:"example-verifying-a-proof",children:"Example: Verifying a Proof"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"bool valid = false;\neIcicleError err = fri_merkle_tree::verify<TypeParam>(\n  fri_config, transcript_config, fri_proof, hash, compress, valid);\nICICLE_CHECK(err);\nASSERT_EQ(true, valid); // Ensure proof verification succeeds\n"})}),"\n",(0,i.jsxs)(s.p,{children:["After calling ",(0,i.jsx)(s.code,{children:"fri_merkle_tree::verify"}),", the variable ",(0,i.jsx)(s.code,{children:"valid"})," will be set to ",(0,i.jsx)(s.code,{children:"true"})," if the proof is valid, and ",(0,i.jsx)(s.code,{children:"false"})," otherwise."]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>t});var r=n(96540);const i={},a=r.createContext(i);function l(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);
"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[80595],{17482:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"api/rust-bindings/fri","title":"FRI","description":"FRI API Overview","source":"@site/versioned_docs/version-3.9.0/api/rust-bindings/fri.md","sourceDirName":"api/rust-bindings","slug":"/api/rust-bindings/fri","permalink":"/api/rust-bindings/fri","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-3.9.0/api/rust-bindings/fri.md","tags":[],"version":"3.9.0","lastUpdatedAt":1750864092000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"Sumcheck","permalink":"/api/rust-bindings/sumcheck"},"next":{"title":"PQC ML-KEM","permalink":"/api/rust-bindings/lattice/pqc-ml-kem"}}');var s=r(74848),l=r(28453);const o={},c="FRI",t={},d=[{value:"FRI API Overview",id:"fri-api-overview",level:2},{value:"<strong>Structs</strong>",id:"structs",level:3},{value:"<code>FriTranscriptConfig</code>",id:"fritranscriptconfig",level:4},{value:"<strong>Fields:</strong>",id:"fields",level:5},{value:"<strong>Methods:</strong>",id:"methods",level:5},{value:"<code>FFIFriTranscriptConfig</code>",id:"ffifritranscriptconfig",level:4},{value:"<code>FriProof</code>",id:"friproof",level:4},{value:"<strong>Methods:</strong>",id:"methods-1",level:5},{value:"<code>FriConfig</code>",id:"friconfig",level:4},{value:"<strong>Fields:</strong>",id:"fields-1",level:5},{value:"<strong>Methods:</strong>",id:"methods-2",level:5},{value:"<strong>Example Usage</strong>",id:"example-usage",level:2},{value:"<strong>Links</strong>",id:"links",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"fri",children:"FRI"})}),"\n",(0,s.jsx)(n.h2,{id:"fri-api-overview",children:"FRI API Overview"}),"\n",(0,s.jsx)(n.h3,{id:"structs",children:(0,s.jsx)(n.strong,{children:"Structs"})}),"\n",(0,s.jsx)(n.h4,{id:"fritranscriptconfig",children:(0,s.jsx)(n.code,{children:"FriTranscriptConfig"})}),"\n",(0,s.jsx)(n.p,{children:"Configuration structure for the FRI protocol's transcript."}),"\n",(0,s.jsx)(n.h5,{id:"fields",children:(0,s.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hash: &Hasher"})," - Reference to the hashing function used."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"domain_separator_label: String"})," - Domain separator label for transcript uniqueness."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"round_challenge_label: String"})," - Label for the challenge at each round."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"commit_phase_label: String"})," - Label for the commit phase."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nonce_label: String"})," - Label for the nonce."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"public_state: Vec<u8>"})," - Public state data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"seed_rng: F"})," - The seed for initializing the RNG."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"methods",children:(0,s.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"new(hash, domain_separator_label, round_challenge_label, commit_phase_label, nonce_label, public_state, seed_rng) -> Self"})}),":\nConstructs a new ",(0,s.jsx)(n.code,{children:"FriTranscriptConfig"})," with explicit parameters."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"new_default_labels(hash, seed_rng) -> Self"})}),":\nConstructs a ",(0,s.jsx)(n.code,{children:"FriTranscriptConfig"})," with default labels."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"ffifritranscriptconfig",children:(0,s.jsx)(n.code,{children:"FFIFriTranscriptConfig"})}),"\n",(0,s.jsx)(n.p,{children:"FFI configuration structure for the FRI protocol's transcript."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Conversion from ",(0,s.jsx)(n.code,{children:"FriTranscriptConfig"})," using ",(0,s.jsx)(n.code,{children:"From"})," trait."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"friproof",children:(0,s.jsx)(n.code,{children:"FriProof"})}),"\n",(0,s.jsx)(n.p,{children:"A structure representing the FRI proof, which includes methods for handling proof data."}),"\n",(0,s.jsx)(n.h5,{id:"methods-1",children:(0,s.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"new() -> Result<Self, eIcicleError>"})}),":\nConstructs a new instance of the ",(0,s.jsx)(n.code,{children:"FriProof"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"create_with_arguments(query_proofs_data, final_poly, pow_nonce) -> Result<Self, eIcicleError>"})}),":\nCreates a new instance of ",(0,s.jsx)(n.code,{children:"FriProof"})," with the given proof data."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"get_query_proofs(&self) -> Result<Vec<Vec<MerkleProofData<F>>>, eIcicleError>"})}),":\nReturns the matrix of Merkle proofs, where each row corresponds to a query and each column corresponds to a round."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"get_final_poly(&self) -> Result<Vec<F>, eIcicleError>"})}),":\nReturns the final polynomial values."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"get_pow_nonce(&self) -> Result<u64, eIcicleError>"})}),":\nReturns the proof-of-work nonce."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"friconfig",children:(0,s.jsx)(n.code,{children:"FriConfig"})}),"\n",(0,s.jsx)(n.p,{children:"Configuration structure for the FRI protocol."}),"\n",(0,s.jsx)(n.h5,{id:"fields-1",children:(0,s.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stream_handle: IcicleStreamHandle"})," - Stream for asynchronous execution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"folding_factor: u64"})," - The factor by which the codeword is folded in each round."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stopping_degree: u64"})," - The minimal polynomial degree at which folding stops."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pow_bits: u64"})," - Number of leading zeros required for proof-of-work."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nof_queries: u64"})," - Number of queries, computed for each folded layer of FRI."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"are_inputs_on_device: bool"})," - True if inputs reside on the device (e.g., GPU)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"is_async: bool"})," - True to run operations asynchronously."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ext: ConfigExtension"})," - Pointer to backend-specific configuration extensions."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"methods-2",children:(0,s.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"default() -> Self"})}),":\nReturns a default ",(0,s.jsx)(n.code,{children:"FriConfig"})," instance with standard settings."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-usage",children:(0,s.jsx)(n.strong,{children:"Example Usage"})}),"\n",(0,s.jsxs)(n.p,{children:["Below is an example demonstrating how to use the ",(0,s.jsx)(n.code,{children:"fri"})," module:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let merkle_tree_leaves_hash = Keccak256::new(std::mem::size_of::<ScalarField>() as u64).unwrap();\nlet merkle_tree_compress_hash = Keccak256::new(2 * merkle_tree_leaves_hash.output_size()).unwrap();\nlet transcript_hash = Keccak256::new(0).unwrap();\n\nconst SIZE: u64 = 1 << 10;\n\ninit_domain::<ScalarField>(SIZE, false);\n\nlet fri_config = FriConfig::default();\nlet scalars = ScalarCfg::generate_random(SIZE as usize);\nlet transcript_config = FriTranscriptConfig::new_default_labels(&transcript_hash, ScalarField::one());\nlet merkle_tree_min_layer_to_store = 0;\n\nlet fri_proof = fri_merkle_tree_prove::<ScalarField>(\n    &fri_config,\n    &transcript_config,\n    HostSlice::from_slice(&scalars),\n    &merkle_tree_leaves_hash,\n    &merkle_tree_compress_hash,\n    merkle_tree_min_layer_to_store,\n)\n.unwrap();\n\nlet valid = fri_merkle_tree_verify::<ScalarField>(\n    &fri_config,\n    &transcript_config,\n    &fri_proof,\n    &merkle_tree_leaves_hash,\n    &merkle_tree_compress_hash,\n)\n.unwrap();\n\nassert!(valid);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"links",children:(0,s.jsx)(n.strong,{children:"Links"})}),"\n",(0,s.jsxs)(n.p,{children:["For more information on FRI concepts, see ",(0,s.jsx)(n.a,{href:"../cpp/fri",children:"FRI Primitives"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var i=r(96540);const s={},l=i.createContext(s);function o(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[6318],{49790:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"icicle/rust-bindings/sumcheck","title":"Sumcheck","description":"Sumcheck API Overview","source":"@site/versioned_docs/version-3.7.0/icicle/rust-bindings/sumcheck.md","sourceDirName":"icicle/rust-bindings","slug":"/icicle/rust-bindings/sumcheck","permalink":"/icicle/rust-bindings/sumcheck","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-3.7.0/icicle/rust-bindings/sumcheck.md","tags":[],"version":"3.7.0","lastUpdatedBy":"ShaniBabayoff","lastUpdatedAt":1744629504000,"frontMatter":{},"sidebar":"GettingStartedSidebar","previous":{"title":"Merkle-Tree","permalink":"/icicle/rust-bindings/merkle"},"next":{"title":"Migrate from ICICLE v2","permalink":"/icicle/migrate_from_v2"}}');var l=r(74848),s=r(28453);const c={},o="Sumcheck",t={},d=[{value:"Sumcheck API Overview",id:"sumcheck-api-overview",level:2},{value:"<strong>Structs</strong>",id:"structs",level:3},{value:"<code>SumcheckTranscriptConfig</code>",id:"sumchecktranscriptconfig",level:4},{value:"<strong>Fields:</strong>",id:"fields",level:5},{value:"<strong>Methods:</strong>",id:"methods",level:5},{value:"<code>SumcheckConfig</code>",id:"sumcheckconfig",level:4},{value:"<strong>Fields:</strong>",id:"fields-1",level:5},{value:"<strong>Methods:</strong>",id:"methods-1",level:5},{value:"<strong>Traits</strong>",id:"traits",level:3},{value:"<code>Sumcheck</code>",id:"sumcheck-1",level:4},{value:"<strong>Associated Types:</strong>",id:"associated-types",level:5},{value:"<strong>Methods:</strong>",id:"methods-2",level:5},{value:"<code>SumcheckProofOps</code>",id:"sumcheckproofops",level:4},{value:"<strong>Methods:</strong>",id:"methods-3",level:5},{value:"<strong>Example with Predefined program (R1CS)</strong>",id:"example-with-predefined-program-r1cs",level:2},{value:"ReturningValueProgram",id:"returningvalueprogram",level:2},{value:"<strong>Example with userdefined program (relaxed R1CS)</strong>",id:"example-with-userdefined-program-relaxed-r1cs",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"sumcheck",children:"Sumcheck"})}),"\n",(0,l.jsx)(n.h2,{id:"sumcheck-api-overview",children:"Sumcheck API Overview"}),"\n",(0,l.jsx)(n.h3,{id:"structs",children:(0,l.jsx)(n.strong,{children:"Structs"})}),"\n",(0,l.jsx)(n.h4,{id:"sumchecktranscriptconfig",children:(0,l.jsx)(n.code,{children:"SumcheckTranscriptConfig"})}),"\n",(0,l.jsx)(n.p,{children:"Configuration structure for the SumCheck protocol\u2019s transcript."}),"\n",(0,l.jsx)(n.h5,{id:"fields",children:(0,l.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"hash: &Hasher"})," - Reference to the hashing function used."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"domain_separator_label: Vec<u8>"})," - Domain separator label for transcript uniqueness."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"round_poly_label: Vec<u8>"})," - Label for the polynomial at each round."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"round_challenge_label: Vec<u8>"})," - Label for the challenge at each round."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"little_endian: bool"})," - Whether to use little-endian encoding."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"seed_rng: F"})," - Random number generator seed."]}),"\n"]}),"\n",(0,l.jsx)(n.h5,{id:"methods",children:(0,l.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"new(hash, domain_separator_label, round_poly_label, round_challenge_label, little_endian, seed_rng) -> Self"})}),":\nConstructs a new ",(0,l.jsx)(n.code,{children:"SumcheckTranscriptConfig"})," with explicit parameters."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"from_string_labels(hash, domain_separator_label, round_poly_label, round_challenge_label, little_endian, seed_rng) -> Self"})}),":\nConvenience constructor using string labels."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"sumcheckconfig",children:(0,l.jsx)(n.code,{children:"SumcheckConfig"})}),"\n",(0,l.jsx)(n.p,{children:"General configuration for the SumCheck execution."}),"\n",(0,l.jsx)(n.h5,{id:"fields-1",children:(0,l.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"stream: IcicleStreamHandle"})," - Stream for asynchronous execution (default: ",(0,l.jsx)(n.code,{children:"nullptr"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"use_extension_field: bool"})," - Whether to use an extension field for Fiat-Shamir transformation. Sumcheck currently does not support extension fields, always set to ",(0,l.jsx)(n.code,{children:"false"})," otherwise return an error."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"batch: u64"})," - Number of input chunks to hash in batch (default: 1)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"are_inputs_on_device: bool"})," - Whether inputs reside on the device (e.g., GPU)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"is_async: bool"})," - Whether hashing is run asynchronously."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ext: ConfigExtension"})," - Pointer to backend-specific configuration extensions."]}),"\n"]}),"\n",(0,l.jsx)(n.h5,{id:"methods-1",children:(0,l.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"default() -> Self"})}),":\nReturns a default ",(0,l.jsx)(n.code,{children:"SumcheckConfig"})," instance."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"traits",children:(0,l.jsx)(n.strong,{children:"Traits"})}),"\n",(0,l.jsx)(n.h4,{id:"sumcheck-1",children:(0,l.jsx)(n.code,{children:"Sumcheck"})}),"\n",(0,l.jsx)(n.p,{children:"Defines the main API for SumCheck operations."}),"\n",(0,l.jsx)(n.h5,{id:"associated-types",children:(0,l.jsx)(n.strong,{children:"Associated Types:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Field: FieldImpl + Arithmetic"})," - The field implementation used."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"FieldConfig: FieldConfig + GenerateRandom<Self::Field> + FieldArithmetic<Self::Field>"})," - Field configuration."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Proof: SumcheckProofOps<Self::Field>"})," - Type representing the proof."]}),"\n"]}),"\n",(0,l.jsx)(n.h5,{id:"methods-2",children:(0,l.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"new() -> Result<Self, eIcicleError>"})}),":\nInitializes a new instance."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"prove(mle_polys, mle_poly_size, claimed_sum, combine_function, transcript_config, sumcheck_config) -> Self::Proof"})}),":\nGenerates a proof for the polynomial sum over the Boolean hypercube."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"verify(proof, claimed_sum, transcript_config) -> Result<bool, eIcicleError>"})}),":\nVerifies the provided proof."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"sumcheckproofops",children:(0,l.jsx)(n.code,{children:"SumcheckProofOps"})}),"\n",(0,l.jsx)(n.p,{children:"Operations for handling SumCheck proofs."}),"\n",(0,l.jsx)(n.h5,{id:"methods-3",children:(0,l.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"get_round_polys(&self) -> Result<Vec<Vec<F>>, eIcicleError>"})}),":\nRetrieves the polynomials for each round."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"print(&self) -> eIcicleError"})}),"::\nPrints the proof."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"example-with-predefined-program-r1cs",children:(0,l.jsx)(n.strong,{children:"Example with Predefined program (R1CS)"})}),"\n",(0,l.jsxs)(n.p,{children:["Below is an example demonstrating how to use the ",(0,l.jsx)(n.code,{children:"sumcheck"})," module, adapted from the ",(0,l.jsx)(n.code,{children:"check_sumcheck_simple"})," test."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use icicle_bn254::sumcheck::SumcheckWrapper as SW;\nuse icicle_bn254::program::bn254::FieldReturningValueProgram as P;\nuse icicle_core::program::ReturningValueProgram;\nuse icicle_core::sumcheck::{Sumcheck, SumcheckConfig, SumcheckProofOps, SumcheckTranscriptConfig};\nuse icicle_core::traits::{FieldImpl, GenerateRandom};\nuse icicle_hash::keccak::Keccak256;\nuse icicle_runtime::memory::HostSlice;\n\n//setup\nlet log_mle_poly_size = 10u64;\nlet mle_poly_size = 1 << log_mle_poly_size;\n//number of MLE polys\nlet nof_mle_poly = 4;\nlet mut mle_polys = Vec::with_capacity(nof_mle_poly);\n//create polys\nfor _ in 0..nof_mle_poly {\n  let mle_poly_random = <<SW as Sumcheck>::FieldConfig>::generate_random(mle_poly_size);\n  mle_polys.push(mle_poly_random);\n}\n//compute claimed sum\nlet mut claimed_sum = <<SW as Sumcheck>::Field as FieldImpl>::zero();\nfor i in 0..mle_poly_size {\n  let a = mle_polys[0][i];\n  let b = mle_polys[1][i];\n  let c = mle_polys[2][i];\n  let eq = mle_polys[3][i];\n  claimed_sum = claimed_sum + (a * b - c) * eq;\n}\n//create polynomial host slices\nlet mle_poly_hosts = mle_polys\n    .iter()\n    .map(|poly| HostSlice::from_slice(poly))\n    .collect::<Vec<&HostSlice<<SW as Sumcheck>::Field>>>();\n//define transcript config\nlet hasher = Keccak256::new(0).unwrap();\nlet seed_rng = <<SW as Sumcheck>::FieldConfig>::generate_random(1)[0];\nlet transcript_config = SumcheckTranscriptConfig::from_string_labels(\n        &hasher,\n        "DomainLabel",\n        "PolyLabel",\n        "ChallengeLabel",\n        true, // little endian\n        seed_rng,\n    );\n//define sumcheck config\nlet sumcheck_config = SumcheckConfig::default();\nlet sumcheck = <SW as Sumcheck>::new().unwrap();\n//define combine function\nlet combine_function = <icicle_bn254::program::bn254::FieldReturningValueProgram as ReturningValueProgram>::new_predefined(PreDefinedProgram::EQtimesABminusC).unwrap();\nlet proof = sumcheck.prove(\n        &mle_poly_hosts,\n        mle_poly_size.try_into().unwrap(),\n        claimed_sum,\n        combine_function,\n        &transcript_config,\n        &sumcheck_config,);\n//serialize round polynomials from proof\nlet proof_round_polys = <<SW as Sumcheck>::Proof as SumcheckProofOps<\n        <SW as Sumcheck>::Field,>>::get_round_polys(&proof).unwrap();\n//verifier reconstruct proof from round polynomials\nlet proof_as_sumcheck_proof: <SW as Sumcheck>::Proof =\n        <SW as Sumcheck>::Proof::from(proof_round_polys);\n//verify proof\nlet proof_validty = sumcheck.verify(&proof_as_sumcheck_proof, claimed_sum, &transcript_config);\nprintln!("Sumcheck proof verified, is valid: {}", proof_validty.unwrap());\n'})}),"\n",(0,l.jsx)(n.h1,{id:"misc",children:"Misc"}),"\n",(0,l.jsx)(n.h2,{id:"returningvalueprogram",children:"ReturningValueProgram"}),"\n",(0,l.jsxs)(n.p,{children:["A variant of ",(0,l.jsx)(n.a,{href:"/icicle/rust-bindings/program",children:"Program"})," tailored for Sumcheck's combine function. It differs from ",(0,l.jsx)(n.code,{children:"Program"})," by the function it receives in its constructor - instead of returning no value and using the given parameter vector as both inputs and outputs, it returns a single value which is the one and only return value of the function. This way it fulfils the utility of the combine function, allowing custom combine functions for the icicle backend."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"pub trait ReturningValueProgram:\n  Sized + Handle\n{\n  type Field: FieldImpl;\n  type ProgSymbol: Symbol<Self::Field>;\n\n  fn new(program_func: impl FnOnce(&mut Vec<Self::ProgSymbol>) -> Self::ProgSymbol, nof_parameters: u32) -> Result<Self, eIcicleError>;\n\n  fn new_predefined(pre_def: PreDefinedProgram) -> Result<Self, eIcicleError>;\n}\n\n"})}),"\n",(0,l.jsx)(n.h2,{id:"example-with-userdefined-program-relaxed-r1cs",children:(0,l.jsx)(n.strong,{children:"Example with userdefined program (relaxed R1CS)"})}),"\n",(0,l.jsxs)(n.p,{children:["In this example, we define a relaxed R1CS sumcheck (zerocheck) (See eq 2 of ",(0,l.jsx)(n.a,{href:"https://eprint.iacr.org/2021/370.pdf",children:"Nova"}),") using the program functionality. We will change the relevant parts in the above code:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"//The Relaxed r1cs sumcheck (zerocheck) is given bv \\sum_{X\\in{0,1}^n} F(X) eq(X,Y) = 0 \n//where F(X) = A(X). B(X) - C(X) + E(X). We denote A(X) as the MLE representation of A.Z where Z is the witness vector. E(X) is called the slack vector.\nlet nof_mle_poly = 5;\nlet mut mle_polys = Vec::with_capacity(nof_mle_poly);\n//initialize slack vector\nlet mut slack_poly = vec![<<SW as Sumcheck>::Field as FieldImpl>::zero(); mle_poly_size];\n//create polys except slack poly\nfor _ in 0..nof_mle_poly-1 {\n  let mle_poly_random = <<SW as Sumcheck>::FieldConfig>::generate_random(mle_poly_size);\n  mle_polys.push(mle_poly_random);\n}\n//compute claimed sum\nlet mut claimed_sum = <<SW as Sumcheck>::Field as FieldImpl>::zero();\nfor i in 0..mle_poly_size {\n  let a = mle_polys[0][i];\n  let b = mle_polys[1][i];\n  let c = mle_polys[2][i];\n  let eq = mle_polys[3][i];\n  let slack =  c - a * b;\n  slack_poly[i]=slack; // we want to create a system for zero check\n  claimed_sum = claimed_sum + (a * b - c +slack) * eq;\n};\nmle_polys.push(slack_poly); // add slack poly to mle_polys\n//check that claimed sum is zero\nassert_eq!(claimed_sum, <<SW as Sumcheck>::Field as FieldImpl>::zero());\n//setup end\n//define relaxed r1cs using the program\nlet relaxed_r1cs = |vars: &mut Vec<<P as ReturningValueProgram>::ProgSymbol>|-> <P as ReturningValueProgram>::ProgSymbol {\n  let a = vars[0]; \n  let b = vars[1];\n  let c = vars[2];\n  let eq = vars[3];\n  let slack =vars[4];\n  return eq* (a * b - c + slack);\n};\n//define the combine function with the program for relaxed r1cs instead of the predefined R1CS\nlet combine_function = P::new(relaxed_r1cs, 5).unwrap();\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>o});var i=r(96540);const l={},s=i.createContext(l);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);
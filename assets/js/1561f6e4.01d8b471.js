"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[8605],{72612:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api/rust-bindings/matrix_ops","title":"Matrix Operations (Rust bindings)","description":"icicle-core exposes a set of matrix primitives that operate on data located either in host memory or on the GPU. These are implemented on top of \u2013 and share the same configuration structure as \u2013 the generic vector-operations backend (VecOps).","source":"@site/versioned_docs/version-4.0.0/api/rust-bindings/matrix_ops.md","sourceDirName":"api/rust-bindings","slug":"/api/rust-bindings/matrix_ops","permalink":"/api/rust-bindings/matrix_ops","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-4.0.0/api/rust-bindings/matrix_ops.md","tags":[],"version":"4.0.0","lastUpdatedAt":1752211496000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"Pairings","permalink":"/api/rust-bindings/pairing"}}');var s=i(74848),t=i(28453);const o={},c="Matrix Operations (Rust bindings)",a={},l=[{value:"Configuration: <code>MatMulConfig</code>",id:"configuration-matmulconfig",level:2},{value:"Trait: <code>MatrixOps</code>",id:"trait-matrixops",level:2},{value:"Convenience free functions",id:"convenience-free-functions",level:2},{value:"Example",id:"example",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Memory placement",id:"memory-placement",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"matrix-operations-rust-bindings",children:"Matrix Operations (Rust bindings)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"icicle-core"})," exposes a set of ",(0,s.jsx)(n.strong,{children:"matrix primitives"})," that operate on data located either in host memory or on the GPU. These are implemented on top of \u2013 and share the same configuration structure as \u2013 the generic vector-operations backend (",(0,s.jsx)(n.code,{children:"VecOps"}),")."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"configuration-matmulconfig",children:["Configuration: ",(0,s.jsx)(n.code,{children:"MatMulConfig"})]}),"\n",(0,s.jsxs)(n.p,{children:["Matrix multiplication uses a dedicated configuration struct, ",(0,s.jsx)(n.code,{children:"MatMulConfig"}),", which controls device placement, batching, transposition, and more:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use icicle_runtime::stream::IcicleStreamHandle;\nuse icicle_runtime::config::ConfigExtension;\n\n#[repr(C)]\n#[derive(Debug, Clone)]\npub struct MatMulConfig {\n    pub stream_handle: IcicleStreamHandle, // Execution stream (e.g., CUDA stream)\n    pub is_a_on_device: bool,              // True if `a` is on device memory\n    pub is_b_on_device: bool,              // True if `b` is on device memory\n    pub is_result_on_device: bool,         // True if result stays on device\n    pub a_transposed: bool,                // Transpose input `a`\n    pub b_transposed: bool,                // Transpose input `b`\n    pub result_transposed: bool,           // Transpose the output\n    pub is_async: bool,                    // Non-blocking execution if true\n    pub ext: ConfigExtension,              // Backend-specific config\n}\n\nimpl MatMulConfig {\n    pub fn default() -> Self { /* ... */ }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"MatMulConfig::default()"})," for standard single-matrix multiplication on the main device."]}),"\n",(0,s.jsxs)(n.li,{children:["For matrix transpose, use ",(0,s.jsx)(n.code,{children:"VecOpsConfig"})," as before."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"trait-matrixops",children:["Trait: ",(0,s.jsx)(n.code,{children:"MatrixOps"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use icicle_runtime::memory::HostOrDeviceSlice;\nuse icicle_core::matrix_ops::MatMulConfig;\nuse icicle_core::vec_ops::VecOpsConfig;\nuse icicle_runtime::errors::IcicleError;\n\npub trait MatrixOps<T> {\n    /// Performs matrix multiplication: `result = a \xd7 b`\n    ///\n    /// - `a`: shape `(a_rows \xd7 a_cols)` (row-major)\n    /// - `b`: shape `(b_rows \xd7 b_cols)` (row-major)\n    /// - `result`: shape `(a_rows \xd7 b_cols)` (row-major, must be preallocated)\n    ///\n    /// Requirements:\n    /// - `a_cols == b_rows`\n    /// - All buffers may reside in host or device memory\n    fn matmul(\n        a: &(impl HostOrDeviceSlice<T> + ?Sized),\n        a_rows: u32,\n        a_cols: u32,\n        b: &(impl HostOrDeviceSlice<T> + ?Sized),\n        b_rows: u32,\n        b_cols: u32,\n        cfg: &MatMulConfig,\n        result: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n    ) -> Result<(), IcicleError>;\n\n    /// Computes the transpose of a matrix in row-major order.\n    ///\n    /// - `input`: shape `(nof_rows \xd7 nof_cols)`\n    /// - `output`: shape `(nof_cols \xd7 nof_rows)` (must be preallocated)\n    ///\n    /// Both input and output can reside on host or device memory.\n    fn matrix_transpose(\n        input: &(impl HostOrDeviceSlice<T> + ?Sized),\n        nof_rows: u32,\n        nof_cols: u32,\n        cfg: &VecOpsConfig,\n        output: &mut (impl HostOrDeviceSlice<T> + ?Sized),\n    ) -> Result<(), IcicleError>;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All concrete field / ring crates (for example ",(0,s.jsx)(n.code,{children:"icicle_bn254"}),", ",(0,s.jsx)(n.code,{children:"icicle_babybear"}),", \u2026) re-export blanket implementations for their native scalar type via an internal macro.  Thus ",(0,s.jsx)(n.strong,{children:"you only need to import the scalar type"})," \u2013 the trait implementation is already in scope."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"convenience-free-functions",children:"Convenience free functions"}),"\n",(0,s.jsxs)(n.p,{children:["Instead of calling the trait manually, you can use the thin wrappers defined in ",(0,s.jsx)(n.code,{children:"icicle_core::matrix_ops"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use icicle_core::matrix_ops::{matmul, matrix_transpose};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matmul"})," uses ",(0,s.jsx)(n.code,{children:"MatMulConfig"})," for configuration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matrix_transpose"})," uses ",(0,s.jsx)(n.code,{children:"VecOpsConfig"})," for configuration."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Multiply two random BN254 matrices entirely on the GPU and read the result back to the host. (All buffers can be on host or device; you can mix and match as needed.)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use icicle_bn254::field::ScalarField;\nuse icicle_core::matrix_ops::{matmul, MatMulConfig};\nuse icicle_core::vec_ops::VecOpsConfig;\nuse icicle_runtime::memory::{DeviceVec, HostSlice};\nuse icicle_core::traits::GenerateRandom;\n\nconst N: usize = 512; // We will compute C = A \xd7 B where A,B are N\xd7N\n\n// 1. Generate random data on the host\nlet a_host = ScalarField::generate_random(N * N);\nlet b_host = ScalarField::generate_random(N * N);\n// 2. Move the data to device memory\n// 3. Allocate the result buffer on the device\n// 4. Perform matmul\nlet cfg = MatMulConfig::default();\nmatmul(&a_dev[..], N as u32, N as u32,\n       &b_dev[..], N as u32, N as u32,\n       &cfg, &mut c_dev[..]).unwrap();\n// Result is stored in c_dev for this example\n// 5. Copy the result back if needed\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error handling"}),"\n",(0,s.jsxs)(n.p,{children:["All functions return ",(0,s.jsx)(n.code,{children:"IcicleError"}),". The helpers perform validity checks (dimension mismatches, device/host placement, etc.) before dispatching to the backend, guaranteeing early and descriptive error messages. Checks include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Input and output buffer sizes must match the specified matrix dimensions."}),"\n",(0,s.jsx)(n.li,{children:"All buffers must be allocated on the correct device (if using device memory)."}),"\n",(0,s.jsxs)(n.li,{children:["For ",(0,s.jsx)(n.code,{children:"matmul"}),", the inner dimensions must match (",(0,s.jsx)(n.code,{children:"a_cols == b_rows"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"Output buffer must be preallocated to the correct size."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"memory-placement",children:"Memory placement"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All buffers (",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"b"}),", ",(0,s.jsx)(n.code,{children:"result"}),", ",(0,s.jsx)(n.code,{children:"input"}),", ",(0,s.jsx)(n.code,{children:"output"}),") can be on host or device memory."]}),"\n",(0,s.jsx)(n.li,{children:"You can mix host and device buffers as needed; the API will handle transfers as required."}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"DeviceVec"})," for device memory and ",(0,s.jsx)(n.code,{children:"HostSlice"})," for host memory."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"MatMulConfig"})," and ",(0,s.jsx)(n.code,{children:"VecOpsConfig"})," structs control backend selection and options."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["As of the current branch, there are ",(0,s.jsx)(n.strong,{children:"no batched matrix operations"})," exposed in the Rust bindings. Only ",(0,s.jsx)(n.code,{children:"matmul"})," and ",(0,s.jsx)(n.code,{children:"matrix_transpose"})," are available."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var r=i(96540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);
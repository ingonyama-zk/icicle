"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[39366],{20406:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"api/rust-bindings/lattice/pqc-ml-kem","title":"ML-KEM (Kyber) \u2013 Rust bindings","description":"For an in-depth explanation of the primitive, performance advice and backend-specific tuning knobs see the C++ ML-KEM guide.","source":"@site/versioned_docs/version-3.9.0/api/rust-bindings/lattice/pqc-ml-kem.md","sourceDirName":"api/rust-bindings/lattice","slug":"/api/rust-bindings/lattice/pqc-ml-kem","permalink":"/3.9.0/api/rust-bindings/lattice/pqc-ml-kem","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-3.9.0/api/rust-bindings/lattice/pqc-ml-kem.md","tags":[],"version":"3.9.0","lastUpdatedAt":1754480071000,"frontMatter":{},"sidebar":"apisidebar","previous":{"title":"FRI","permalink":"/3.9.0/api/rust-bindings/fri"},"next":{"title":"Serialization","permalink":"/3.9.0/api/rust-bindings/serialization"}}');var c=i(74848),t=i(28453);const r={},l="ML-KEM (Kyber) \u2013 Rust bindings",a={},o=[{value:"Overview",id:"overview",level:2},{value:"Public API",id:"public-api",level:2},{value:"Key pair generation",id:"key-pair-generation",level:3},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Decapsulation",id:"decapsulation",level:3},{value:"<code>MlKemConfig</code>",id:"mlkemconfig",level:3},{value:"Quick-start example (Kyber768, host buffers)",id:"quick-start-example-kyber768-host-buffers",level:2},{value:"Device &amp; async execution",id:"device--async-execution",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"ml-kem-kyber--rust-bindings",children:"ML-KEM (Kyber) \u2013 Rust bindings"})}),"\n",(0,c.jsx)(n.admonition,{type:"note",children:(0,c.jsxs)(n.p,{children:["For an in-depth explanation of the primitive, performance advice and backend-specific tuning knobs see the ",(0,c.jsx)(n.a,{href:"/3.9.0/api/cpp/lattice/pqc_ml_kem",children:"C++ ML-KEM guide"}),"."]})}),"\n",(0,c.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"icicle-ml-kem"})," is a Rust wrapper around Icicle's batched ",(0,c.jsx)(n.strong,{children:"ML-KEM"})," implementation (Kyber).  It exposes three functions \u2013 ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"keygen"})}),", ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"encapsulate"})})," and ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"decapsulate"})})," \u2013 that work on host or device memory."]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"public-api",children:"Public API"}),"\n",(0,c.jsx)(n.h3,{id:"key-pair-generation",children:"Key pair generation"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-rust",children:"pub fn keygen<P: KyberParams>(\n    entropy: &(impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 64 bytes\n    config: &MlKemConfig,\n    public_keys: &mut (impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 PUBLIC_KEY_BYTES\n    secret_keys: &mut (impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 SECRET_KEY_BYTES\n) -> Result<(), eIcicleError>;\n"})}),"\n",(0,c.jsx)(n.h3,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-rust",children:"pub fn encapsulate<P: KyberParams>(\n    message: &(impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 32 bytes\n    public_keys: &(impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 PUBLIC_KEY_BYTES\n    config: &MlKemConfig,\n    ciphertexts: &mut (impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 CIPHERTEXT_BYTES\n    shared_secrets: &mut (impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 SHARED_SECRET_BYTES\n) -> Result<(), eIcicleError>;\n"})}),"\n",(0,c.jsx)(n.h3,{id:"decapsulation",children:"Decapsulation"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-rust",children:"pub fn decapsulate<P: KyberParams>(\n    secret_keys: &(impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 SECRET_KEY_BYTES\n    ciphertexts: &(impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 CIPHERTEXT_BYTES\n    config: &MlKemConfig,\n    shared_secrets: &mut (impl HostOrDeviceSlice<u8> + ?Sized), // batch_size \xd7 SHARED_SECRET_BYTES\n) -> Result<(), eIcicleError>;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["All buffers may live either on the ",(0,c.jsx)(n.strong,{children:"host"})," or on the currently-active ",(0,c.jsx)(n.strong,{children:"device"}),"."]}),"\n",(0,c.jsx)(n.h3,{id:"mlkemconfig",children:(0,c.jsx)(n.code,{children:"MlKemConfig"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-rust",children:"pub struct MlKemConfig {\n    pub stream:                    IcicleStreamHandle,\n    pub is_async:                  bool,\n\n    // Location hints\n    pub messages_on_device:        bool,\n    pub entropy_on_device:         bool,\n    pub public_keys_on_device:     bool,\n    pub secret_keys_on_device:     bool,\n    pub ciphertexts_on_device:     bool,\n    pub shared_secrets_on_device:  bool,\n\n    pub batch_size:                i32,\n    pub ext:                       ConfigExtension,\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["use ",(0,c.jsx)(n.code,{children:"Default::default()"})," to get the default configuration. Setting ",(0,c.jsx)(n.code,{children:"is_async = true"})," lets the call return immediately; remember to synchronize the stream before reading results."]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"quick-start-example-kyber768-host-buffers",children:"Quick-start example (Kyber768, host buffers)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-rust",children:'use icicle_ml_kem as mlkem;\nuse icicle_ml_kem::{keygen, encapsulate, decapsulate};\nuse icicle_ml_kem::kyber_params::{Kyber768Params, ENTROPY_BYTES, MESSAGE_BYTES};\nuse icicle_runtime::memory::HostSlice;\nuse rand::{RngCore, rngs::OsRng};\n\nconst BATCH: usize = 1 << 12;\n\nfn main() {\n    // Allocate buffers on the host\n    let mut entropy         = vec![0u8; BATCH * ENTROPY_BYTES];\n    let mut msg             = vec![0u8; BATCH * MESSAGE_BYTES];\n    OsRng.fill_bytes(&mut entropy);\n    OsRng.fill_bytes(&mut msg);\n\n    let mut pk = vec![0u8; BATCH * Kyber768Params::PUBLIC_KEY_BYTES];\n    let mut sk = vec![0u8; BATCH * Kyber768Params::SECRET_KEY_BYTES];\n    let mut ct = vec![0u8; BATCH * Kyber768Params::CIPHERTEXT_BYTES];\n    let mut ss_enc = vec![0u8; BATCH * Kyber768Params::SHARED_SECRET_BYTES];\n    let mut ss_dec = vec![0u8; BATCH * Kyber768Params::SHARED_SECRET_BYTES];\n\n    // Configuration \u2013 everything stays on host\n    let mut cfg = mlkem::config::MlKemConfig::default();\n    cfg.batch_size = BATCH as i32;\n\n    // Key generation\n    keygen::<Kyber768Params>(\n        HostSlice::from_slice(&entropy),\n        &cfg,\n        HostSlice::from_mut_slice(&mut pk),\n        HostSlice::from_mut_slice(&mut sk),\n    ).unwrap();\n\n    // Encapsulation\n    encapsulate::<Kyber768Params>(\n        HostSlice::from_slice(&msg),\n        HostSlice::from_slice(&pk),\n        &cfg,\n        HostSlice::from_mut_slice(&mut ct),\n        HostSlice::from_mut_slice(&mut ss_enc),\n    ).unwrap();\n\n    // Decapsulation\n    decapsulate::<Kyber768Params>(\n        HostSlice::from_slice(&sk),\n        HostSlice::from_slice(&ct),\n        &cfg,\n        HostSlice::from_mut_slice(&mut ss_dec),\n    ).unwrap();\n\n    assert_eq!(ss_enc, ss_dec);\n    println!("{} successful KEM operations!", BATCH);\n}\n'})}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"device--async-execution",children:"Device & async execution"}),"\n",(0,c.jsxs)(n.p,{children:["The API works identically for Device buffers \u2013 allocate input/output ",(0,c.jsx)(n.code,{children:"DeviceVec"}),"s, and provide an ",(0,c.jsx)(n.code,{children:"IcicleStream"})," for non-blocking execution. See ",(0,c.jsx)(n.a,{href:"https://github.com/ingonyama-zk/icicle/blob/main/wrappers/rust/icicle-pqc/icicle-ml-kem/src/tests.rs",children:(0,c.jsx)(n.code,{children:"tests.rs"})})," in the crate for an end-to-end example."]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"error-handling",children:"Error handling"}),"\n",(0,c.jsxs)(n.p,{children:["All functions return ",(0,c.jsx)(n.code,{children:"Result<(), eIcicleError>"}),".  An error is raised for invalid buffer sizes, mismatched device selection, or when the selected backend is not available."]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"/3.9.0/api/cpp/lattice/pqc_ml_kem",children:"C++ ML-KEM guide"})}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/3.9.0/start/programmers_guide/general",children:"Icicle programmer guide"})," \u2013 streams, device management, buffer helpers, and memory management"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(96540);const c={},t=s.createContext(c);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);
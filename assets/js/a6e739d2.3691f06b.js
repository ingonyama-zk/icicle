"use strict";(self.webpackChunkicicle_docs=self.webpackChunkicicle_docs||[]).push([[41004],{81150:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"start/integration-&-support/migrate_from_v3","title":"Migration from ICICLE v3 to v4","description":"ICICLE v4 introduces a more intuitive and object-oriented C++ API for field elements, making code more readable and maintainable. This guide will assist you in transitioning from ICICLE v3 to v4 by highlighting the key changes and providing examples for both C++ and Rust.","source":"@site/versioned_docs/version-4.0.0/start/integration-&-support/migrate_from_v3.md","sourceDirName":"start/integration-&-support","slug":"/start/integration-&-support/migrate_from_v3","permalink":"/start/integration-&-support/migrate_from_v3","draft":false,"unlisted":false,"editUrl":"https://github.com/ingonyama-zk/icicle/tree/main/docs/versioned_docs/version-4.0.0/start/integration-&-support/migrate_from_v3.md","tags":[],"version":"4.0.0","lastUpdatedAt":1752745101000,"frontMatter":{},"sidebar":"GettingStartedSidebar","previous":{"title":"Migration from ICICLE v2 to v3","permalink":"/start/integration-&-support/migrate_from_v2"},"next":{"title":"Benchmarks","permalink":"/start/integration-&-support/benchmarks"}}');var d=n(74848),t=n(28453);const s={},l="Migration from ICICLE v3 to v4",a={},c=[{value:"Key Conceptual Changes",id:"key-conceptual-changes",level:2},{value:"Migration Guide for C++",id:"migration-guide-for-c",level:2},{value:"Replacing Static Method Calls with Instance Methods",id:"replacing-static-method-calls-with-instance-methods",level:3},{value:"Field Arithmetic Operations",id:"field-arithmetic-operations",level:4},{value:"Montgomery Conversion",id:"montgomery-conversion",level:4},{value:"Example Migration",id:"example-migration",level:3},{value:"Migration Guide for Rust",id:"migration-guide-for-rust",level:2},{value:"New Trait design and Hierarchy",id:"new-trait-design-and-hierarchy",level:3},{value:"Arithmetic API",id:"arithmetic-api",level:3},{value:"Field Arithmetic Operations",id:"field-arithmetic-operations-1",level:4},{value:"The Arithmetic Trait",id:"the-arithmetic-trait",level:4},{value:"The Invertible Trait",id:"the-invertible-trait",level:4},{value:"Renaming of the <code>FieldImpl</code> Trait",id:"renaming-of-the-fieldimpl-trait",level:3},{value:"Refactor Program from Vecops to Program module",id:"refactor-program-from-vecops-to-program-module",level:3},{value:"Create program",id:"create-program",level:4},{value:"Execute program",id:"execute-program",level:4},{value:"Create returning value program",id:"create-returning-value-program",level:4},{value:"Create predefined program",id:"create-predefined-program",level:4},{value:"Imports",id:"imports",level:4},{value:"Example Migration",id:"example-migration-1",level:3},{value:"Program API Example",id:"program-api-example",level:3},{value:"Random Number Generation",id:"random-number-generation",level:3},{value:"Removal of the <code>FieldCfg</code> Trait",id:"removal-of-the-fieldcfg-trait",level:3}];function o(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(r.header,{children:(0,d.jsx)(r.h1,{id:"migration-from-icicle-v3-to-v4",children:"Migration from ICICLE v3 to v4"})}),"\n",(0,d.jsx)(r.p,{children:"ICICLE v4 introduces a more intuitive and object-oriented C++ API for field elements, making code more readable and maintainable. This guide will assist you in transitioning from ICICLE v3 to v4 by highlighting the key changes and providing examples for both C++ and Rust."}),"\n",(0,d.jsx)(r.h2,{id:"key-conceptual-changes",children:"Key Conceptual Changes"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"Object-Oriented Field API"}),": In v3, field operations were performed using static methods on the field type (e.g., ",(0,d.jsx)(r.code,{children:"FF::sqr(a)"}),"). In v4, these operations are now instance methods on the field elements themselves (e.g., ",(0,d.jsx)(r.code,{children:"a.sqr()"}),"), making the code more natural and readable."]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"Method Chaining"}),": The new API supports method chaining, allowing you to write more concise and expressive code by chaining multiple operations together."]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(r.h2,{id:"migration-guide-for-c",children:"Migration Guide for C++"}),"\n",(0,d.jsx)(r.h3,{id:"replacing-static-method-calls-with-instance-methods",children:"Replacing Static Method Calls with Instance Methods"}),"\n",(0,d.jsx)(r.p,{children:"In ICICLE v4, static method calls on field types have been replaced with instance methods on field elements. This change makes the code more intuitive and follows object-oriented principles."}),"\n",(0,d.jsx)(r.h4,{id:"field-arithmetic-operations",children:"Field Arithmetic Operations"}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"v3 (Static Methods)"}),(0,d.jsx)(r.th,{children:"v4 (Instance Methods)"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::add(a, b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a + b"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::sub(a, b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a - b"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::mul(a, b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a * b"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::sqr(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.sqr()"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::neg(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.neg()"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::inverse(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.inverse()"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::pow(a, exp)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.pow(exp)"})})]})]})]}),"\n",(0,d.jsx)(r.h4,{id:"montgomery-conversion",children:"Montgomery Conversion"}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"v3 (Static Methods)"}),(0,d.jsx)(r.th,{children:"v4 (Instance Methods)"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::to_montgomery(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.to_montgomery()"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"FF::from_montgomery(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.from_montgomery()"})})]})]})]}),"\n",(0,d.jsx)(r.h3,{id:"example-migration",children:"Example Migration"}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v3 (Static Methods):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-cpp",children:"FF a = FF::from(5);\nFF b = FF::from(10);\nFF c = FF::add(a, b);\nFF d = FF::mul(c, FF::from(2));\nFF e = FF::sqr(d);\nFF f = FF::inverse(e);\n"})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v4 (Instance Methods):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-cpp",children:"FF a = FF::from(5);\nFF b = FF::from(10);\nFF c = a.add(b);  // or a + b\nFF d = c.mul(FF::from(2));  // or c * FF::from(2)\nFF e = d.sqr();\nFF f = e.inverse();\n"})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v4 (Method Chaining):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-cpp",children:"FF result = FF::from(5)\n    .add(FF::from(10))\n    .mul(FF::from(2))\n    .sqr()\n    .inverse();\n"})}),"\n",(0,d.jsx)(r.h2,{id:"migration-guide-for-rust",children:"Migration Guide for Rust"}),"\n",(0,d.jsx)(r.h3,{id:"new-trait-design-and-hierarchy",children:"New Trait design and Hierarchy"}),"\n",(0,d.jsx)(r.p,{children:"The v4 Rust wrappers introduce a three-layer abstraction; each layer builds on the one below and is wired up through a dedicated macro."}),"\n",(0,d.jsx)(r.mermaid,{value:'---\nconfig:\n  themeVariables:\n    lineColor: \'#54A5FF\'\n---\ngraph TD;\n    BigNum["BigNum<N>"];\n    GenerateRandom["GenerateRandom"];\n    Arithmetic["Arithmetic"];\n    TryInverse["TryInverse"];\n    Invertible["Invertible"];\n    IntegerRing["IntegerRing"];\n    Field["Field"];\n\n    IntegerRing --\x3e|extends| BigNum;\n    IntegerRing --\x3e|requires| GenerateRandom;\n    IntegerRing --\x3e|requires| Arithmetic;\n    IntegerRing --\x3e|requires| TryInverse;\n\n    Field --\x3e|extends| IntegerRing;\n    Field --\x3e|requires| Invertible;'}),"\n",(0,d.jsx)(r.p,{children:"Layer breakdown"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"BigNum<N>"})," \u2013 fixed-width big integer with N 32-bit limbs. Generated by ",(0,d.jsx)(r.code,{children:"impl_bignum!"}),"; provides endian conversions, formatting helpers and FFI glue."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"IntegerRing"})," = ",(0,d.jsx)(r.code,{children:"BigNum + GenerateRandom + Arithmetic + TryInverse"}),". Adds ring arithmetic, random sampling and modular inverse. Generated by ",(0,d.jsx)(r.code,{children:"impl_integer_ring!"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"Field"})," = ",(0,d.jsx)(r.code,{children:"IntegerRing + Invertible"}),". Guarantees multiplicative inverses. Generated by ",(0,d.jsx)(r.code,{children:"impl_field!"}),"."]}),"\n"]}),"\n",(0,d.jsx)(r.p,{children:"Creating a new field is usually a one-liner:"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:'impl_field!(BLS12_381_Fr, "bls12_381_fr", 8);\n'})}),"\n",(0,d.jsxs)(r.p,{children:["This design replaces the older ",(0,d.jsx)(r.code,{children:"FieldCfg"}),"/",(0,d.jsx)(r.code,{children:"FieldImpl"})," pairing from v3 and offers finer-grained composability."]}),"\n",(0,d.jsx)(r.h3,{id:"arithmetic-api",children:"Arithmetic API"}),"\n",(0,d.jsxs)(r.p,{children:["ICICLE v4 implements field arithmetic operations through the ",(0,d.jsx)(r.code,{children:"Arithmetic"})," trait and standard Rust operators. This makes the code more idiomatic and easier to read."]}),"\n",(0,d.jsx)(r.h4,{id:"field-arithmetic-operations-1",children:"Field Arithmetic Operations"}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"(Static Methods)"}),(0,d.jsx)(r.th,{children:"(Instance Methods)"}),(0,d.jsx)(r.th,{children:"(Operators)"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::add(a, b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.add(b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a + b"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::sub(a, b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.sub(b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a - b"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::mul(a, b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.mul(b)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a * b"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::sqr(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.sqr()"})}),(0,d.jsx)(r.td,{children:"N/A"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::neg(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.neg()"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"-a"})})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::inv(a)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.inv()"})}),(0,d.jsx)(r.td,{children:"N/A"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Fr::pow(a, exp)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"a.pow(exp)"})}),(0,d.jsx)(r.td,{children:"N/A"})]})]})]}),"\n",(0,d.jsx)(r.h4,{id:"the-arithmetic-trait",children:"The Arithmetic Trait"}),"\n",(0,d.jsxs)(r.p,{children:["The ",(0,d.jsx)(r.code,{children:"Arithmetic"})," trait in ICICLE v4 is defined as follows:"]}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"pub trait Arithmetic: Sized + Add<Output = Self> + Sub<Output = Self> + Mul<Output = Self> {\n    fn sqr(&self) -> Self;\n    fn pow(&self, exp: usize) -> Self;\n}\n"})}),"\n",(0,d.jsxs)(r.p,{children:["This trait extends the standard Rust operators (",(0,d.jsx)(r.code,{children:"Add"}),", ",(0,d.jsx)(r.code,{children:"Sub"}),", ",(0,d.jsx)(r.code,{children:"Mul"}),") and adds specialized field operations like square, inverse, and exponentiation."]}),"\n",(0,d.jsx)(r.h4,{id:"the-invertible-trait",children:"The Invertible Trait"}),"\n",(0,d.jsxs)(r.p,{children:["Field inversion is now provided by the ",(0,d.jsx)(r.code,{children:"Invertible"})," trait. This trait defines a single method, ",(0,d.jsx)(r.code,{children:"inv"}),", which returns the multiplicative inverse of a field element."]}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"pub trait Invertible: Sized {\n    fn inv(&self) -> Self;\n}\n"})}),"\n",(0,d.jsx)(r.p,{children:"If the field element is zero, the function will return zero."}),"\n",(0,d.jsxs)(r.h3,{id:"renaming-of-the-fieldimpl-trait",children:["Renaming of the ",(0,d.jsx)(r.code,{children:"FieldImpl"})," Trait"]}),"\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.code,{children:"FieldImpl"})," was renamed into ",(0,d.jsx)(r.code,{children:"BigNum"})]}),"\n",(0,d.jsx)(r.h3,{id:"refactor-program-from-vecops-to-program-module",children:"Refactor Program from Vecops to Program module"}),"\n",(0,d.jsx)(r.p,{children:"In v4, the Program API has been moved from VecOps to a dedicated Program module for better organization and type safety."}),"\n",(0,d.jsx)(r.h4,{id:"create-program",children:"Create program"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,d.jsx)(r.code,{children:"Fr::create_program(|symbols| { ... }, nof_params)?"})]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,d.jsx)(r.code,{children:"FieldProgram::new(|symbols| { ... }, nof_params)?"})]}),"\n"]}),"\n",(0,d.jsx)(r.h4,{id:"execute-program",children:"Execute program"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,d.jsx)(r.code,{children:"Fr::execute_program(&program, &mut vec_data, &config)?"})]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,d.jsx)(r.code,{children:"program.execute_program(&mut vec_data, &config)?"})]}),"\n"]}),"\n",(0,d.jsx)(r.h4,{id:"create-returning-value-program",children:"Create returning value program"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v4:"})," ",(0,d.jsx)(r.code,{children:"ReturningValueProgram::new(|symbols| -> symbol { ... }, nof_params)?"})]}),"\n"]}),"\n",(0,d.jsx)(r.h4,{id:"create-predefined-program",children:"Create predefined program"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,d.jsx)(r.code,{children:"Fr::create_predefined_program(pre_def)?"})]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,d.jsx)(r.code,{children:"FieldProgram::new_predefined(pre_def)?"})]}),"\n"]}),"\n",(0,d.jsx)(r.h4,{id:"imports",children:"Imports"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v3 (VecOps):"})," ",(0,d.jsx)(r.code,{children:"use icicle_core::vec_ops::{VecOps, VecOpsConfig};"})]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"v4 (Program):"})," ",(0,d.jsx)(r.code,{children:"use icicle_core::program::{Program, ReturningValueProgram};"})]}),"\n"]}),"\n",(0,d.jsx)(r.h3,{id:"example-migration-1",children:"Example Migration"}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v3 (Old API):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::ScalarField;\nuse icicle_core::traits::FieldImpl;\nuse icicle_core::field::FieldArithmetic;\n\nlet a = ScalarField::from_u32(5);\nlet b = ScalarField::from_u32(10);\n"})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v4 (Current API):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::ScalarField;\nuse icicle_core::traits::Arithmetic;\n\nlet a = ScalarField::from(5);\nlet b = ScalarField::from(10);\nlet c = a + b;  // or a.add(b)\nlet d = c * ScalarField::from(2);  // or c.mul(ScalarField::from(2))\n"})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v4 (Method Chaining):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::ScalarField;\nuse icicle_core::traits::Arithmetic;\n\nlet result = ScalarField::from(5)\n    .add(ScalarField::from(10))\n    .mul(ScalarField::from(2))\n    .sqr()\n    .inv();\n"})}),"\n",(0,d.jsx)(r.h3,{id:"program-api-example",children:"Program API Example"}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v3 (VecOps API):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::ScalarField;\nuse icicle_core::vec_ops::{VecOps, VecOpsConfig};\n\n// Create program\nlet program = ScalarField::create_program(|symbols| {\n    // Program logic here\n}, nof_params)?;\n\n// Execute program\nScalarField::execute_program(&program, &mut vec_data, &config)?;\n"})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v4 (Program API):"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::ScalarField;\nuse icicle_core::program::{Program, ReturningValueProgram};\nuse icicle_bn254::program::stark252::{FieldProgram, FieldReturningValueProgram};\n\n// Create program\nlet program = FieldProgram::new(|symbols| {\n    // Program logic here\n}, nof_params)?;\n\n// Execute program\nprogram.execute_program(&mut vec_data, &config)?;\n\n// Create returning value program\nlet returning_program = FieldReturningValueProgram::new(|symbols| -> symbol {\n    // Program logic here\n    result_symbol\n}, nof_params)?;\n"})}),"\n",(0,d.jsx)(r.h3,{id:"random-number-generation",children:"Random Number Generation"}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v3:"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::{ScalarCfg, ScalarField};\nuse icicle_core::traits::FieldCfg;\n\nlet random_values = ScalarCfg::generate_random(size);\n"})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsx)(r.strong,{children:"v4:"})}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-rust",children:"use icicle_bn254::curve::ScalarField;\nuse icicle_core::traits::GenerateRandom;\n\nlet random_values = ScalarField::generate_random(size);\n"})}),"\n",(0,d.jsxs)(r.h3,{id:"removal-of-the-fieldcfg-trait",children:["Removal of the ",(0,d.jsx)(r.code,{children:"FieldCfg"})," Trait"]}),"\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.code,{children:"FieldCfg"})," previously exposed compile-time field parameters (generator, root, etc.) ",(0,d.jsx)(r.strong,{children:"and"})," helper functions like ",(0,d.jsx)(r.code,{children:"generate_random"}),". ",(0,d.jsx)(r.code,{children:"FieldCfg"})," was implemented for a separate struct in each field. In v4 there is now a ",(0,d.jsx)(r.code,{children:"Field: IntegerRing + Invertible"})," trait that is implemented for the concrete field types. ",(0,d.jsx)(r.code,{children:"IntegerRing: BigNum + GenerateRandom + Arithmetic + TryInverse"})]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["Random sampling moved to the standalone ",(0,d.jsx)(r.code,{children:"GenerateRandom"})," trait."]}),"\n"]}),"\n",(0,d.jsx)(r.p,{children:"Migration steps:"}),"\n",(0,d.jsxs)(r.ol,{children:["\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:["Replace ",(0,d.jsx)(r.code,{children:"use icicle_core::traits::FieldCfg;"})," with ",(0,d.jsx)(r.code,{children:"use icicle_core::traits::GenerateRandom;"})," when you only need random values."]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:["If you used ",(0,d.jsx)(r.code,{children:"FieldCfg"})," for helper methods (other than random generation), check the new trait bounds for ",(0,d.jsx)(r.code,{children:"Field"})," and ",(0,d.jsx)(r.code,{children:"IntegerRing"}),". Most arithmetic and inversion helpers are now part of these traits and are implemented directly on the field type."]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:["Remove any references to the old config struct (e.g., ",(0,d.jsx)(r.code,{children:"ScalarCfg"}),", ",(0,d.jsx)(r.code,{children:"CurveCfg"})," etc) in your codebase, as it is no longer needed in v4. All field operations should be accessed via the field type (e.g., ",(0,d.jsx)(r.code,{children:"ScalarField"}),")."]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:["Review your imports and update them to only include the traits and types you actually use. For most use cases, you will only need to import the field type (e.g., ",(0,d.jsx)(r.code,{children:"ScalarField"}),") and the relevant traits (e.g., ",(0,d.jsx)(r.code,{children:"GenerateRandom"}),", ",(0,d.jsx)(r.code,{children:"IntegerRing"}),", ",(0,d.jsx)(r.code,{children:"Invertible"}),")."]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(r.p,{children:["By following these steps, you can migrate your code from the old ",(0,d.jsx)(r.code,{children:"FieldCfg"}),"-based API to the new, more streamlined v4 API. This will ensure compatibility with the latest version of the library and take advantage of the improved trait-based design."]}),"\n",(0,d.jsx)(r.p,{children:"All constant names are unchanged, so the update is usually a simple search-and-replace."}),"\n",(0,d.jsxs)(r.p,{children:["For further details and examples, refer to the ",(0,d.jsx)(r.a,{href:"/start/programmers_guide/general",children:"Programmer's Guide"}),"."]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,d.jsx)(r,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>l});var i=n(96540);const d={},t=i.createContext(d);function s(e){const r=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:s(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);
package ecntt

import (
	"os"
	"testing"

	"github.com/ingonyama-zk/icicle/wrappers/golang/core"
	{{.CurveData.Curve}}Fields "github.com/ingonyama-zk/icicle/wrappers/golang/temp_golang_structure/fields/{{.CurveData.Curve}}"
	{{.CurveData.Curve}} "github.com/ingonyama-zk/icicle/wrappers/golang/temp_golang_structure/curves/{{.CurveData.Curve}}"
	"github.com/consensys/gnark-crypto/ecc/{{.GnarkImport}}/fr/fft"
	"github.com/stretchr/testify/assert"
)

const (
	largestTestSize = 17
)

func TestECNtt(t *testing.T) {
	cfg := {{.CurveData.Curve}}Fields.GetDefaultNttConfig()
	points := {{.CurveData.Curve}}.GenerateProjectivePoints(1 << largestTestSize)

	for _, size := range []int{4, 5, 6, 7, 8} {
		for _, v := range [4]core.Ordering{core.KNN, core.KNR, core.KRN, core.KRR} {
			testSize := 1 << size

			pointsCopy := core.HostSliceFromElements[{{.CurveData.Curve}}.Projective](points[:testSize])
			cfg.Ordering = v
			cfg.NttAlgorithm = core.Radix2

			output := make(core.HostSlice[{{.CurveData.Curve}}.Projective], testSize)
			e := ECNtt[{{.CurveData.Curve}}.Projective](pointsCopy, core.KForward, &cfg, output)
			assert.Equal(t, core.IcicleErrorCode(0), e.IcicleErrorCode, "ECNtt failed")
		}
	}
}

func TestMain(m *testing.M) {
	// setup domain
	cfg := {{.CurveData.Curve}}Fields.GetDefaultNttConfig()
	rouMont, _ := fft.Generator(uint64(1 << largestTestSize))
	rou := rouMont.Bits()
	rouIcicle := {{.CurveData.Curve}}.ScalarField{}

	rouIcicle.FromLimbs(rou[:])
	e := {{.CurveData.Curve}}Fields.InitDomain(rouIcicle, cfg.Ctx, false)
	if e.IcicleErrorCode != core.IcicleErrorCode(0) {
		panic("initDomain failed")
	}

	// execute tests
	os.Exit(m.Run())

	// release domain
	e = {{.CurveData.Curve}}Fields.ReleaseDomain(cfg.Ctx)
	if e.IcicleErrorCode != core.IcicleErrorCode(0) {
		panic("ReleaseDomain failed")
	}
}

package {{.PackageName}}

// #cgo CFLAGS: -I./include/
// #include "vec_ops.h"
import "C"

import (
	"github.com/ingonyama-zk/icicle/v3/wrappers/golang/core"
	"github.com/ingonyama-zk/icicle/v3/wrappers/golang/runtime"
)

func VecOp(a, b, out core.HostOrDeviceSlice, config core.VecOpsConfig, op core.VecOps) (ret runtime.EIcicleError) {
	aPointer, bPointer, outPointer, cfgPointer, size := core.VecOpCheck(a, b, out, &config)

	cA := (*C.scalar_t)(aPointer)
	cB := (*C.scalar_t)(bPointer)
	cOut := (*C.scalar_t)(outPointer)
	cConfig := (*C.VecOpsConfig)(cfgPointer)
	cSize := (C.int)(size)

	switch op {
	case core.Sub:
		ret = (runtime.EIcicleError)(C.{{.Field}}_vector_sub(cA, cB, cSize, cConfig, cOut))
	case core.Add:
		ret = (runtime.EIcicleError)(C.{{.Field}}_vector_add(cA, cB, cSize, cConfig, cOut))
	case core.Mul:
		ret = (runtime.EIcicleError)(C.{{.Field}}_vector_mul(cA, cB, cSize, cConfig, cOut))
	}

	return ret
}

func TransposeMatrix(in, out core.HostOrDeviceSlice, columnSize, rowSize int, config core.VecOpsConfig) runtime.EIcicleError {
	inPointer, _, outPointer, cfgPointer, _ := core.VecOpCheck(in, in, out, &config)

	cIn := (*C.scalar_t)(inPointer)
	cRowSize := (C.int)(rowSize)
	cColumnSize := (C.int)(columnSize)
	cConfig := (*C.VecOpsConfig)(cfgPointer)
	cOut := (*C.scalar_t)(outPointer)

	err := (C.{{.Field}}_matrix_transpose(cIn, cRowSize, cColumnSize, cConfig, cOut))
	return runtime.EIcicleError(err)
}

{{if eq .FieldPrefix "Extension"}}
func MixedVecOp(a, b, out core.HostOrDeviceSlice, config core.VecOpsConfig, op core.VecOps) (ret runtime.EIcicleError) {
	aPointer, bPointer, outPointer, cfgPointer, size := core.VecOpCheck(a, b, out, &config)

	cA := (*C.scalar_t)(aPointer)
	cB := (*C.scalar_t)(bPointer)
	cOut := (*C.scalar_t)(outPointer)
	cConfig := (*C.VecOpsConfig)(cfgPointer)
	cSize := (C.int)(size)

	switch op {
	case core.Mul:
		ret = (runtime.EIcicleError)(C.{{.Field}}_vector_mixed_mul(cA, cB, cSize, cConfig, cOut))
	}

	return ret
}
{{end}}
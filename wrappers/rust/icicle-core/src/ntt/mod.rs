use icicle_cuda_runtime::{device_context::DeviceContext, error::CudaResult};
use std::os::raw::c_int;

use crate::curve::CurveConfig;

/**
 * @enum Ordering
 * How to order inputs and outputs of the NTT. If needed, use this field to specify decimation: decimation in time
 * (DIT) corresponds to `Ordering::kRN` while decimation in frequency (DIF) to `Ordering::kNR`. Also, to specify
 * butterfly to be used, select `Ordering::kRN` for Cooley-Tukey and `Ordering::kNR` for Gentleman-Sande. There's
 * no implication that a certain decimation or butterfly will actually be used under the hood, this is just for
 * compatibility with codebases that use "decimation" and "butterfly" to denote ordering of inputs and outputs.
 *
 * Ordering options are:
 * - kNN: inputs and outputs are natural-order (example of natural ordering: \f$ \{a_0, a_1, a_2, a_3, a_4, a_5, a_6,
 * a_7\} \f$).
 * - kNR: inputs are natural-order and outputs are bit-reversed-order (example of bit-reversed ordering: \f$ \{a_0,
 * a_4, a_2, a_6, a_1, a_5, a_3, a_7\} \f$).
 * - kRN: inputs are bit-reversed-order and outputs are natural-order.
 * - kRR: inputs and outputs are bit-reversed-order.
 */
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Ordering {
    kNN,
    kNR,
    kRN,
    kRR,
}

/**
 * @struct NTTConfig
 * Struct that encodes NTT parameters to be passed into the [ntt](@ref ntt) function.
 */
#[repr(C)]
#[derive(Debug)]
pub struct NTTConfig<'a, S> {
    /** Coset generator. Used to perform coset (i)NTTs. Default value: `S::one()` (corresponding to no coset being used). */
    pub coset_gen: S,
    /** Ordering of inputs and outputs. See [Ordering](@ref Ordering). Default value: `Ordering::kNN`. */
    pub ordering: Ordering,
    /** True if inputs are on device and false if they're on host. Default value: false. */
    pub are_inputs_on_device: bool,
    /** If true, output is preserved on device for subsequent use in config and not freed after calculation. Default value: false. */
    pub are_outputs_on_device: bool,
    /** The number of NTTs to compute. Default value: 1. */
    pub batch_size: c_int,
    /** Whether to run the NTT asyncronously. If set to `true`, the NTT function will be non-blocking and you'd need to synchronize
     *  it explicitly by running `cudaStreamSynchronize` or `cudaDeviceSynchronize`. If set to false, the NTT
     *  function will block the current CPU thread. */
    pub is_async: bool,
    /** Details related to the device such as its id and stream id. See [DeviceContext](@ref device_context::DeviceContext). */
    pub ctx: DeviceContext<'a>,
}

// /**
//  * @struct Domain
//  * Struct containing information about the domain on which (i)NTT is evaluated: twiddle factors and coset generator.
//  * Twiddle factors are private, static and can only be set using [GenerateDomain](@ref GenerateDomain) function.
//  * The internal representation of twiddles is prone to change in accordance with changing [NTT](@ref NTT) algorithm.
//  */
// #[repr(C)]
// #[derive(Debug)]
// pub struct Domain<'a, T> {
//     /** Scalar elements that specify a coset to be used in (i)NTT. Default value: None (no coset or alternatively coset
//      *  generated by `S::one()` is used). */
//     pub coset_table: Option<&'a [T]>,
// }

pub trait NTT<C: CurveConfig> {
    fn ntt(
        input: &[C::ScalarField],
        is_inverse: bool,
        cfg: &NTTConfig<C::ScalarField>,
        output: &mut [C::ScalarField],
    ) -> CudaResult<()>;
    fn initialize_domain(primitive_root: C::ScalarField, ctx: &DeviceContext) -> CudaResult<()>;
    fn get_default_ntt_config() -> NTTConfig<'static, C::ScalarField>;
}

#[macro_export]
macro_rules! impl_ntt {
    (
      $curve_prefix:literal,
      $curve_config:ident
    ) => {
        extern "C" {
            #[link_name = concat!($curve_prefix, "NTTCuda")]
            fn ntt_cuda<'a>(
                input: *const ScalarField,
                size: usize,
                is_inverse: bool,
                config: &NTTConfig<'a, ScalarField>,
                output: *mut ScalarField,
            ) -> CudaError;

            #[link_name = concat!($curve_prefix, "DefaultNTTConfig")]
            fn default_ntt_config() -> NTTConfig<'static, ScalarField>;

            #[link_name = concat!($curve_prefix, "InitializeDomain")]
            fn initialize_ntt_domain(primitive_root: ScalarField, ctx: &DeviceContext) -> CudaError;
        }

        impl NTT<$curve_config> for $curve_config {
            fn ntt(
                input: &[<$curve_config as CurveConfig>::ScalarField],
                is_inverse: bool,
                cfg: &NTTConfig<<$curve_config as CurveConfig>::ScalarField>,
                output: &mut [<$curve_config as CurveConfig>::ScalarField],
            ) -> CudaResult<()> {
                if input.len() != output.len() {
                    return Err(CudaError::cudaErrorInvalidValue);
                }

                unsafe {
                    ntt_cuda(
                        input as *const _ as *const <$curve_config as CurveConfig>::ScalarField,
                        input.len(),
                        is_inverse,
                        cfg,
                        output as *mut _ as *mut <$curve_config as CurveConfig>::ScalarField,
                    )
                    .wrap()
                }
            }

            fn initialize_domain(primitive_root: ScalarField, ctx: &DeviceContext) -> CudaResult<()> {
                unsafe { initialize_ntt_domain(primitive_root, ctx).wrap() }
            }

            fn get_default_ntt_config() -> NTTConfig<'static, ScalarField> {
                unsafe { default_ntt_config() }
            }
        }
    };
}

#[macro_export]
macro_rules! impl_ntt_tests {
    (
      $curve_config:ident
    ) => {
        fn reverse_bit_order(n: u32, order: u32) -> u32 {
            fn is_power_of_two(n: u32) -> bool {
                n != 0 && n & (n - 1) == 0
            }
            assert!(is_power_of_two(order));
            let mask = order - 1;
            let binary = format!("{:0width$b}", n, width = (32 - mask.leading_zeros()) as usize);
            let reversed = binary
                .chars()
                .rev()
                .collect::<String>();
            u32::from_str_radix(&reversed, 2).unwrap()
        }

        fn list_to_reverse_bit_order<T: Copy>(l: &[T]) -> Vec<T> {
            l.iter()
                .enumerate()
                .map(|(i, _)| l[reverse_bit_order(i as u32, l.len() as u32) as usize])
                .collect()
        }

        #[test]
        fn test_ntt() {
            let test_size = 1 << 16;
            let ctx = get_default_device_context();
            // two roughly analogous calls for icicle and arkworks. one difference is that icicle call creates
            // domain for all NTTs of size <= `test_size`. also for icicle domain is a hidden static object
            <$curve_config as NTT<$curve_config>>::initialize_domain(
                <$curve_config as CurveConfig>::ScalarField::from_ark(Fr::get_root_of_unity(test_size as u64).unwrap()),
                &ctx,
            )
            .unwrap();
            let ark_domain = GeneralEvaluationDomain::<Fr>::new(test_size).unwrap();

            let scalars: Vec<<$curve_config as CurveConfig>::ScalarField> = generate_random_scalars(test_size);

            let config = <$curve_config as NTT<$curve_config>>::get_default_ntt_config();
            let mut ntt_result = vec![<$curve_config as CurveConfig>::ScalarField::zero(); test_size];
            <$curve_config as NTT<$curve_config>>::ntt(&scalars, false, &config, &mut ntt_result).unwrap();
            assert_ne!(ntt_result, scalars);

            let ark_scalars = scalars
                .iter()
                .map(|v| v.to_ark())
                .collect::<Vec<Fr>>();
            let mut ark_ntt_result = ark_scalars.clone();
            ark_domain.fft_in_place(&mut ark_ntt_result);
            assert_ne!(ark_ntt_result, ark_scalars);

            let ntt_result_as_ark = ntt_result
                .iter()
                .map(|p| p.to_ark())
                .collect::<Vec<Fr>>();
            assert_eq!(ark_ntt_result, ntt_result_as_ark);

            let mut intt_result = vec![<$curve_config as CurveConfig>::ScalarField::zero(); test_size];
            <$curve_config as NTT<$curve_config>>::ntt(&ntt_result, true, &config, &mut intt_result).unwrap();

            assert_eq!(intt_result, scalars);
            // check that ntt_result wasn't mutated by the latest `ntt` call
            assert_eq!(ntt_result_as_ark[1], ntt_result[1].to_ark());
        }

        #[test]
        fn test_ntt_coset_from_subgroup() {
            let test_size = 1 << 16;
            let small_size = test_size >> 1;
            let test_size_rou = Fr::get_root_of_unity(test_size as u64).unwrap();
            let ctx = get_default_device_context();
            // two roughly analogous calls for icicle and arkworks. one difference is that icicle call creates
            // domain for all NTTs of size <= `test_size`. also for icicle domain is a hidden static object
            <$curve_config as NTT<$curve_config>>::initialize_domain(
                <$curve_config as CurveConfig>::ScalarField::from_ark(test_size_rou),
                &ctx,
            )
            .unwrap();
            let ark_small_domain = GeneralEvaluationDomain::<Fr>::new(small_size)
                .unwrap()
                .get_coset(test_size_rou)
                .unwrap();
            let ark_large_domain = GeneralEvaluationDomain::<Fr>::new(test_size).unwrap();

            let mut scalars: Vec<<$curve_config as CurveConfig>::ScalarField> = generate_random_scalars(small_size);

            let mut config = <$curve_config as NTT<$curve_config>>::get_default_ntt_config();
            config.ordering = Ordering::kNR;
            let mut ntt_result = vec![<$curve_config as CurveConfig>::ScalarField::zero(); test_size];
            <$curve_config as NTT<$curve_config>>::ntt(&scalars, false, &config, &mut ntt_result[..small_size])
                .unwrap();
            assert_ne!(ntt_result[..small_size], scalars);
            config.coset_gen = <$curve_config as CurveConfig>::ScalarField::from_ark(test_size_rou);
            <$curve_config as NTT<$curve_config>>::ntt(&scalars, false, &config, &mut ntt_result[small_size..])
                .unwrap();
            let mut ntt_large_result = vec![<$curve_config as CurveConfig>::ScalarField::zero(); test_size];
            // back to non-coset NTT
            config.coset_gen = <$curve_config as CurveConfig>::ScalarField::one();
            scalars.resize(test_size, <$curve_config as CurveConfig>::ScalarField::zero());
            <$curve_config as NTT<$curve_config>>::ntt(&scalars, false, &config, &mut ntt_large_result).unwrap();
            assert_eq!(ntt_result, ntt_large_result);

            let mut ark_scalars = scalars
                .iter()
                .map(|v| v.to_ark())
                .collect::<Vec<Fr>>();
            let mut ark_large_scalars = ark_scalars.clone();
            ark_small_domain.fft_in_place(&mut ark_scalars);
            let ntt_result_as_ark = ntt_result
                .iter()
                .map(|p| p.to_ark())
                .collect::<Vec<Fr>>();
            assert_eq!(
                ark_scalars[..small_size],
                list_to_reverse_bit_order(&ntt_result_as_ark[small_size..])
            );
            ark_large_domain.fft_in_place(&mut ark_large_scalars);
            assert_eq!(ark_large_scalars, list_to_reverse_bit_order(&ntt_result_as_ark));

            config.coset_gen = <$curve_config as CurveConfig>::ScalarField::from_ark(test_size_rou);
            config.ordering = Ordering::kRN;
            let mut intt_result = vec![<$curve_config as CurveConfig>::ScalarField::zero(); small_size];
            <$curve_config as NTT<$curve_config>>::ntt(&ntt_result[small_size..], true, &config, &mut intt_result)
                .unwrap();
            assert_eq!(intt_result, scalars[..small_size]);

            ark_small_domain.ifft_in_place(&mut ark_scalars);
            let intt_result_as_ark = intt_result
                .iter()
                .map(|p| p.to_ark())
                .collect::<Vec<Fr>>();
            assert_eq!(ark_scalars[..small_size], intt_result_as_ark);
        }
    };
}


// #cgo CFLAGS: -I../../../icicle/curves//{{toLower .CurveName}}/
// #cgo LDFLAGS: -L${SRCDIR}/../../ {{.SharedLib}}
// #include "ntt.h"
import "C"
import "unsafe"

const (
	NONE = 0
	DIF  = 1
	DIT  = 2
)

func Ntt{{.CurveName}}(scalars *[]ScalarField, isInverse bool, decimation int, deviceId int) uint64 {
	scalarsC := (*C.{{.CurveName}}_scalar_t)(unsafe.Pointer(&(*scalars)[0]))

	ret := C.ntt_cuda_{{.Prefix}}(scalarsC, C.uint32_t(len(*scalars)), C.bool(isInverse), C.size_t(decimation), C.size_t(deviceId))

	return uint64(ret)
}

func NttBatch{{.CurveName}}(scalars *[]ScalarField, isInverse bool, batchSize, deviceId int) uint64 {
	scalarsC := (*C.{{.CurveName}}_scalar_t)(unsafe.Pointer(&(*scalars)[0]))
	isInverseC := C.bool(isInverse)
	batchSizeC := C.uint32_t(batchSize)
	deviceIdC := C.size_t(deviceId)

	ret := C.ntt_batch_cuda_{{.Prefix}}(scalarsC, C.uint32_t(len(*scalars)), batchSizeC, isInverseC, deviceIdC)

	return uint64(ret)
}

func EcNtt{{.CurveName}}(values *[]Point{{.CurveName}}, isInverse bool, deviceId int) uint64 {
	valuesC := (*C.{{.CurveName}}_projective_t)(unsafe.Pointer(&(*values)[0]))
	deviceIdC := C.size_t(deviceId)
	isInverseC := C.bool(isInverse)
	n := C.uint32_t(len(*values))

	ret := C.ecntt_cuda_{{.Prefix}}(valuesC, n, isInverseC, deviceIdC)

	return uint64(ret)
}

func EcNttBatch{{.CurveName}}(values *[]Point{{.CurveName}}, isInverse bool, batchSize, deviceId int) uint64 {
	valuesC := (*C.{{.CurveName}}_projective_t)(unsafe.Pointer(&(*values)[0]))
	deviceIdC := C.size_t(deviceId)
	isInverseC := C.bool(isInverse)
	n := C.uint32_t(len(*values))
	batchSizeC := C.uint32_t(batchSize)

	ret := C.ecntt_batch_cuda_{{.Prefix}}(valuesC, n, batchSizeC, isInverseC, deviceIdC)

	return uint64(ret)
}

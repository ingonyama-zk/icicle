import (
	"unsafe"
	{{ template "import_ecc" . }}
)

// #cgo CFLAGS: -I${SRCDIR}/icicle/curves/{{toLower .CurveName}}/
// #cgo LDFLAGS: -L${SRCDIR}/../../ {{.SharedLib}}
// #include "c_api.h"
// #include "ve_mod_mult.h"
import "C"

func BatchConvertFromG2Affine(elements []{{.PackageName}}.G2Affine) []G2PointAffine {
	var newElements []G2PointAffine
	for _, gg2Affine := range elements {
		var newElement G2PointAffine
		newElement.FromGnarkAffine(&gg2Affine)

		newElements = append(newElements, newElement)
	}
	return newElements
}

// G2 extension field

type G2Element [4]uint64

type ExtentionField struct {
	A0, A1 G2Element
}

type G2PointAffine struct {
	x, y ExtentionField
}

type G2Point struct {
	x, y, z ExtentionField
}

func (p *G2Point) eqg2(pCompare *G2Point) bool {
	// Cast *Point{{.CurveName}} to *C.{{.CurveName}}_projective_t
	// The unsafe.Pointer cast is necessary because Go doesn't allow direct casts
	// between different pointer types.
	// It's your responsibility to ensure that the types are compatible.
	pC := (*C.{{.CurveName}}_g2_projective_t)(unsafe.Pointer(p))
	pCompareC := (*C.{{.CurveName}}_g2_projective_t)(unsafe.Pointer(pCompare))

	// Call the C function
	// The C function doesn't keep any references to the data,
	// so it's fine if the Go garbage collector moves or deletes the data later.
	return bool(C.eq_g2_{{.PackageName}}(pC, pCompareC))
}

func (p *G2PointAffine) ToProjective() G2Point {
	return G2Point{
		x: p.x,
		y: p.y,
		z: ExtentionField{
			A0: G2Element{1, 0, 0, 0},
			A1: G2Element{0, 0, 0, 0},
		},
	}
}

func (g *G2PointAffine) FromGnarkAffine(gnark *{{.PackageName}}.G2Affine) *G2PointAffine {
	g.x.A0 = gnark.X.A0.Bits()
	g.x.A1 = gnark.X.A1.Bits()
	g.y.A0 = gnark.Y.A0.Bits()
	g.y.A1 = gnark.Y.A1.Bits()

	return g
}

func (g *G2PointAffine) FromGnarkJac(gnark *{{.PackageName}}.G2Jac) *G2PointAffine {
	var pointAffine {{.PackageName}}.G2Affine
	pointAffine.FromJacobian(gnark)

	g.x.A0 = pointAffine.X.A0.Bits()
	g.x.A1 = pointAffine.X.A1.Bits()
	g.y.A0 = pointAffine.Y.A0.Bits()
	g.y.A1 = pointAffine.Y.A1.Bits()

	return g
}

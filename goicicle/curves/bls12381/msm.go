
	// Copyright 2023 Ingonyama
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	
// Code generated by Ingonyama DO NOT EDIT

package bls12381

import (
	"errors"
	"fmt"
	"unsafe"
)

// #cgo CFLAGS: -I../../../icicle/curves/bls12_381/
// #cgo LDFLAGS: -L${SRCDIR}/../../ -lbn12_381
// #include "msm.h"
import "C"

func MsmBLS12381(points []PointAffineNoInfinityBLS12381, scalars []ScalarField, device_id int) (*PointBLS12381, error) {
	if len(points) != len(scalars) {
		return nil, errors.New("error on: len(points) != len(scalars)")
	}

	out := new(PointBLS12381)

	pointsC := (*C.BLS12381_affine_t)(unsafe.Pointer(&points[0]))
	scalarsC := (*C.BLS12381_scalar_t)(unsafe.Pointer(&scalars[0]))
	outC := (*C.BLS12381_projective_t)(unsafe.Pointer(out))

	ret := C.msm_cuda_bls12_381(outC, pointsC, scalarsC, C.size_t(len(points)), C.size_t(device_id))

	if ret != 0 {
		return nil, fmt.Errorf("msm_cuda_bls12_381 returned error code: %d", ret)
	}

	return out, nil
}

func MsmBatchBLS12381(points *[]PointAffineNoInfinityBLS12381, scalars *[]ScalarField, batchSize, deviceId int) ([]*PointBLS12381, error) {
	// Check for nil pointers
	if points == nil || scalars == nil {
		return nil, errors.New("points or scalars is nil")
	}

	if len(*points) != len(*scalars) {
		return nil, errors.New("error on: len(points) != len(scalars)")
	}

	// Check for empty slices
	if len(*points) == 0 || len(*scalars) == 0 {
		return nil, errors.New("points or scalars is empty")
	}

	// Check for zero batchSize
	if batchSize <= 0 {
		return nil, errors.New("error on: batchSize must be greater than zero")
	}

	out := make([]*PointBLS12381, batchSize)

	for i := 0; i < len(out); i++ {
		out[i] = NewPointBLS12381Zero()
	}

	outC := (*C.BLS12381_projective_t)(unsafe.Pointer(&out[0]))
	pointsC := (*C.BLS12381_affine_t)(unsafe.Pointer(&(*points)[0]))
	scalarsC := (*C.BLS12381_scalar_t)(unsafe.Pointer(&(*scalars)[0]))
	msmSizeC := C.size_t(len(*points) / batchSize)
	deviceIdC := C.size_t(deviceId)
	batchSizeC := C.size_t(batchSize)

	ret := C.msm_batch_cuda_bls12_381(outC, pointsC, scalarsC, batchSizeC, msmSizeC, deviceIdC)
	if ret != 0 {
		return nil, fmt.Errorf("msm_batch_cuda_bls12_381 returned error code: %d", ret)
	}

	return out, nil
}

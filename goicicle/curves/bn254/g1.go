// Copyright 2023 Ingonyama
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by Ingonyama DO NOT EDIT

package bn254

import (
	"unsafe"

	"encoding/binary"
	"fmt"

	"github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark-crypto/ecc/bn254/fp"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
)

// #cgo CFLAGS: -I./include/
// #cgo LDFLAGS: -L${SRCDIR}/../../ -lbn254
// #include "c_api.h"
// #include "ve_mod_mult.h"
import "C"

const SCALAR_SIZE = 8
const BASE_SIZE = 8

type G1ScalarField struct {
	s [SCALAR_SIZE]uint32
}

type G1BaseField struct {
	s [BASE_SIZE]uint32
}

type Field interface {
	ToGnarkFr() *fr.Element
}

/*
 * Common Constrctors
 */

func NewFieldZero[T G1BaseField | G1ScalarField]() *T {
	var field T

	return &field
}

func NewFieldFromFrGnark[T G1BaseField | G1ScalarField](element fr.Element) *T {
	s := ConvertUint64ArrToUint32Arr(element.Bits()) // get non-montgomry

	return &T{s}
}

func NewFieldFromFpGnark[T G1BaseField | G1ScalarField](element fp.Element) *T {
	s := ConvertUint64ArrToUint32Arr(element.Bits()) // get non-montgomry

	return &T{s}
}

/*
 * BaseField Constrctors
 */

func (f *G1BaseField) SetOne() *G1BaseField {
	var s [BASE_SIZE]uint32

	s[0] = 1

	f.s = s
	return f
}

func (f *G1BaseField) FromLimbs(limbs [BASE_SIZE]uint32) *G1BaseField {
	copy(f.s[:], limbs[:])

	return f
}

/*
 * BaseField methods
 */

func (f *G1BaseField) Limbs() [BASE_SIZE]uint32 {
	return f.s
}

func (f *G1BaseField) ToBytesLe() []byte {
	bytes := make([]byte, len(f.s)*4)
	for i, v := range f.s {
		binary.LittleEndian.PutUint32(bytes[i*4:], v)
	}

	return bytes
}

func (f *G1BaseField) ToGnarkFr() *fr.Element {
	fb := f.ToBytesLe()
	var b32 [32]byte
	copy(b32[:], fb[:32])

	v, e := fr.LittleEndian.Element(&b32)

	if e != nil {
		panic(fmt.Sprintf("unable to create convert point %v got error %v", f, e))
	}

	return &v
}

func (f *G1BaseField) toGnarkFp() *fp.Element {
	fb := f.ToBytesLe()
	var b32 [32]byte
	copy(b32[:], fb[:32])

	v, e := fp.LittleEndian.Element(&b32)

	if e != nil {
		panic(fmt.Sprintf("unable to create convert point %v got error %v", f, e))
	}

	return &v
}

/*
 * ScalarField methods
 */

func (f *G1ScalarField) SetOne() *G1ScalarField {
	var s [SCALAR_SIZE]uint32
	s[0] = 1
	f.s = s

	return f
}

func (a *G1ScalarField) Equals(b *G1ScalarField) bool {
	for i, v := range a.s {
		if b.s[i] != v {
			return false
		}
	}
	return true
}

/*
 * ScalarField methods
 */

func (f *G1ScalarField) Limbs() [SCALAR_SIZE]uint32 {
	return f.s
}

func (f *G1ScalarField) ToBytesLe() []byte {
	bytes := make([]byte, len(f.s)*4)
	for i, v := range f.s {
		binary.LittleEndian.PutUint32(bytes[i*4:], v)
	}

	return bytes
}

func (f *G1ScalarField) ToGnarkFr() *fr.Element {
	fb := f.ToBytesLe()
	var b32 [32]byte
	copy(b32[:], fb[:32])

	v, e := fr.LittleEndian.Element(&b32)

	if e != nil {
		panic(fmt.Sprintf("unable to create convert point %v got error %v", f, e))
	}

	return &v
}

func (f *G1ScalarField) toGnarkFp() *fp.Element {
	fb := f.ToBytesLe()
	var b32 [32]byte
	copy(b32[:], fb[:32])

	v, e := fp.LittleEndian.Element(&b32)

	if e != nil {
		panic(fmt.Sprintf("unable to create convert point %v got error %v", f, e))
	}

	return &v
}

/*
 * PointBN254
 */

type PointBN254 struct {
	x, y, z G1BaseField
}

func (f *PointBN254) SetZero() *PointBN254 {
	var yZero G1BaseField
	yZero.SetOne()

	f.x = *NewFieldZero[G1BaseField]()
	f.y = yZero
	f.z = *NewFieldZero[G1BaseField]()

	return f
}

func (p *PointBN254) Eq(pCompare *PointBN254) bool {
	// Cast *PointBN254 to *C.BN254_projective_t
	// The unsafe.Pointer cast is necessary because Go doesn't allow direct casts
	// between different pointer types.
	// It's your responsibility to ensure that the types are compatible.
	pC := (*C.BN254_projective_t)(unsafe.Pointer(p))
	pCompareC := (*C.BN254_projective_t)(unsafe.Pointer(pCompare))

	// Call the C function
	// The C function doesn't keep any references to the data,
	// so it's fine if the Go garbage collector moves or deletes the data later.
	return bool(C.eq_bn254(pC, pCompareC))
}

func (p *PointBN254) StripZ() *G1PointAffine {
	return &G1PointAffine{
		x: p.x,
		y: p.y,
	}
}

func (p *PointBN254) ToGnarkAffine() *bn254.G1Affine {
	px := p.x.toGnarkFp()
	py := p.y.toGnarkFp()
	pz := p.z.toGnarkFp()

	zInv := new(fp.Element)
	x := new(fp.Element)
	y := new(fp.Element)

	zInv.Inverse(pz)

	x.Mul(px, zInv)
	y.Mul(py, zInv)

	return &bn254.G1Affine{X: *x, Y: *y}
}

func (p *PointBN254) ToGnarkJac() *bn254.G1Jac {
	var p1 bn254.G1Jac
	p1.FromAffine(p.ToGnarkAffine())

	return &p1
}

func (p *PointBN254) FromG1AffineGnark(gnark *bn254.G1Affine) *PointBN254 {
	var z G1BaseField
	z.SetOne()

	p.x = *NewFieldFromFpGnark[G1BaseField](gnark.X)
	p.y = *NewFieldFromFpGnark[G1BaseField](gnark.Y)
	p.z = z

	return p
}

// converts jac fromat to projective
func (p *PointBN254) FromJacGnark(gnark *bn254.G1Jac) *PointBN254 {
	var pointAffine bn254.G1Affine
	pointAffine.FromJacobian(gnark)

	var z G1BaseField
	z.SetOne()

	p.x = *NewFieldFromFpGnark[G1BaseField](pointAffine.X)
	p.y = *NewFieldFromFpGnark[G1BaseField](pointAffine.Y)
	p.z = z

	return p
}

func (p *PointBN254) FromLimbs(x, y, z *[]uint32) *PointBN254 {
	var _x G1BaseField
	var _y G1BaseField
	var _z G1BaseField
	
	_x.FromLimbs(getFixedLimbs(x))
	_y.FromLimbs(getFixedLimbs(y))
	_z.FromLimbs(getFixedLimbs(z))

	p.x = _x
	p.y = _y
	p.z = _z

	return p
}

/*
 * PointAffineNoInfinityBN254
 */

type G1PointAffine struct {
	x, y G1BaseField
}

func (p *G1PointAffine) SetZero() *G1PointAffine {
	p.x = *NewFieldZero[G1BaseField]()
	p.y = *NewFieldZero[G1BaseField]()

	return p
}

func (p *G1PointAffine) ToProjective() *PointBN254 {
	var z G1BaseField
	z.SetOne()

	return &PointBN254{
		x: p.x,
		y: p.y,
		z: z,
	}
}

func (p *G1PointAffine) ToGnarkAffine() *bn254.G1Affine {
	return p.ToProjective().ToGnarkAffine()
}

func (p *G1PointAffine) FromLimbs(x, y *[]uint32) *G1PointAffine {
	var _x G1BaseField
	var _y G1BaseField

	_x.FromLimbs(getFixedLimbs(x))
	_y.FromLimbs(getFixedLimbs(y))

	return p
}

/*
 * Multiplication
 */

func MultiplyVec(a []PointBN254, b []G1ScalarField, deviceID int) {
	if len(a) != len(b) {
		panic("a and b have different lengths")
	}

	pointsC := (*C.BN254_projective_t)(unsafe.Pointer(&a[0]))
	scalarsC := (*C.BN254_scalar_t)(unsafe.Pointer(&b[0]))
	deviceIdC := C.size_t(deviceID)
	nElementsC := C.size_t(len(a))

	C.vec_mod_mult_point_bn254(pointsC, scalarsC, nElementsC, deviceIdC)
}

func MultiplyScalar(a []G1ScalarField, b []G1ScalarField, deviceID int) {
	if len(a) != len(b) {
		panic("a and b have different lengths")
	}

	aC := (*C.BN254_scalar_t)(unsafe.Pointer(&a[0]))
	bC := (*C.BN254_scalar_t)(unsafe.Pointer(&b[0]))
	deviceIdC := C.size_t(deviceID)
	nElementsC := C.size_t(len(a))

	C.vec_mod_mult_scalar_bn254(aC, bC, nElementsC, deviceIdC)
}

// Multiply a matrix by a scalar:
//
//	`a` - flattenned matrix;
//	`b` - vector to multiply `a` by;
func MultiplyMatrix(a []G1ScalarField, b []G1ScalarField, deviceID int) {
	c := make([]G1ScalarField, len(b))
	for i := range c {
		c[i] = *NewFieldZero[G1ScalarField]()
	}

	aC := (*C.BN254_scalar_t)(unsafe.Pointer(&a[0]))
	bC := (*C.BN254_scalar_t)(unsafe.Pointer(&b[0]))
	cC := (*C.BN254_scalar_t)(unsafe.Pointer(&c[0]))
	deviceIdC := C.size_t(deviceID)
	nElementsC := C.size_t(len(a))

	C.matrix_vec_mod_mult_bn254(aC, bC, cC, nElementsC, deviceIdC)
}

/*
 * Utils
 */

func getFixedLimbs(slice *[]uint32) [BASE_SIZE]uint32 {
	if len(*slice) <= BASE_SIZE {
		limbs := [BASE_SIZE]uint32{}
		copy(limbs[:len(*slice)], *slice)
		return limbs
	}

	panic("slice has too many elements")
}

func BatchConvertFromFrGnark[T G1BaseField | G1ScalarField](elements []fr.Element) []T {
	var newElements []T
	for _, e := range elements {
		converted := NewFieldFromFrGnark[T](e)
		newElements = append(newElements, *converted)
	}

	return newElements
}

func BatchConvertFromFrGnarkThreaded[T G1BaseField | G1ScalarField](elements []fr.Element, routines int) []T {
	var newElements []T

	if routines > 1 && routines <= len(elements) {
		channels := make([]chan []T, routines)
		for i := 0; i < routines; i++ {
			channels[i] = make(chan []T, 1)
		}

		convert := func(elements []fr.Element, chanIndex int) {
			var convertedElements []T
			for _, e := range elements {
				converted := NewFieldFromFrGnark[T](e)
				convertedElements = append(convertedElements, *converted)
			}

			channels[chanIndex] <- convertedElements
		}

		batchLen := len(elements) / routines
		for i := 0; i < routines; i++ {
			start := batchLen * i
			end := batchLen * (i + 1)
			elemsToConv := elements[start:end]
			if i == routines-1 {
				elemsToConv = elements[start:]
			}
			go convert(elemsToConv, i)
		}

		for i := 0; i < routines; i++ {
			newElements = append(newElements, <-channels[i]...)
		}
	} else {
		for _, e := range elements {
			converted := NewFieldFromFrGnark[T](e)
			newElements = append(newElements, *converted)
		}
	}

	return newElements
}

func BatchConvertToFrGnark[T Field](elements []T) []fr.Element {
	var newElements []fr.Element
	for _, e := range elements {
		converted := e.ToGnarkFr()
		newElements = append(newElements, *converted)
	}

	return newElements
}

func BatchConvertToFrGnarkThreaded[T Field](elements []T, routines int) []fr.Element {
	var newElements []fr.Element

	if routines > 1 {
		channels := make([]chan []fr.Element, routines)
		for i := 0; i < routines; i++ {
			channels[i] = make(chan []fr.Element, 1)
		}

		convert := func(elements []T, chanIndex int) {
			var convertedElements []fr.Element
			for _, e := range elements {
				converted := e.ToGnarkFr()
				convertedElements = append(convertedElements, *converted)
			}

			channels[chanIndex] <- convertedElements
		}

		batchLen := len(elements) / routines
		for i := 0; i < routines; i++ {
			elemsToConv := elements[batchLen*i : batchLen*(i+1)]
			go convert(elemsToConv, i)
		}

		for i := 0; i < routines; i++ {
			newElements = append(newElements, <-channels[i]...)
		}
	} else {
		for _, e := range elements {
			converted := e.ToGnarkFr()
			newElements = append(newElements, *converted)
		}
	}

	return newElements
}

func BatchConvertFromG1Affine(elements []bn254.G1Affine) []G1PointAffine {
	var newElements []G1PointAffine
	for _, e := range elements {
		var newElement PointBN254
		newElement.FromG1AffineGnark(&e)

		newElements = append(newElements, *newElement.StripZ())
	}
	return newElements
}
